{"meta":{"title":"guowj","subtitle":"The fear of Jehovah is the beginning of wisdom, And the knowledge of the Holy One is understanding.","description":"个人技术博客","author":"guowj","url":"https://gwjacqueline.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-04-04T12:54:25.000Z","updated":"2019-04-04T12:54:25.000Z","comments":true,"path":"categories/index.html","permalink":"https://gwjacqueline.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-04T12:52:08.000Z","updated":"2019-04-04T12:52:08.000Z","comments":true,"path":"tags/index.html","permalink":"https://gwjacqueline.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"generator生成器","slug":"generator生成器","date":"2019-04-13T11:31:01.000Z","updated":"2019-04-13T14:41:14.000Z","comments":true,"path":"generator生成器/","link":"","permalink":"https://gwjacqueline.github.io/generator生成器/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generator 生成器是 ES6 提供主要用来解决异步编程深度嵌套的问题。generator 和其他函数不同的是：一般的函数只有一次返回值，generator 可以返回多次值。我们可以把它理解为一个函数内部状态的遍历器，我们每执行一次，函数的内部的状态就会发生一次改变。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generator 生成器是 ES6 提供主要用来解决异步编程深度嵌套的问题。generator 和其他函数不同的是：一般的函数只有一次返回值，generator 可以返回多次值。我们可以把它理解为一个函数内部状态的遍历器，我们每执行一次，函数的内部的状态就会发生一次改变。 定义及调用定义：12345function* gen() &#123; yield &quot;Lucy&quot;; yield &quot;DaMing&quot;; return &quot;OK&quot;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generator 在形态上与普通函数有两点区别：一是，function 和函数名之间有一个”*“号；二是，函数体内部使用 yield(产出)语句，定义函数内部不同的状态。yield 关键字用来暂停和继续一个生成器函数,我们可以在需要的时候控制函数的运行。yield 语句的特点是必须等上一条 yield 语句执行完毕才会执行下一条 yield 语句。这样的好处是可以帮助我们用同步的方式写异步代码。避免陷入回调地狱。 调用：12345console.log(gen()); //gen &#123;&lt;suspended&gt;&#125;console.log(g1.next()); //&#123;value: &quot;Lucy&quot;, done: false&#125;console.log(g1.next()); //&#123;value: &quot;DaMing&quot;, done: false&#125;console.log(g1.next()); //&#123;value: &quot;OK&quot;, done: true&#125;console.log(g1.next()); //&#123;value: undefined, done: true&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们看到控制台将 gen()直接打印出来，是一个 Iterator 实例，然后我们再去执行 Iterator 实例的 next()方法，那么这个函数才开始真正运行，并把 yield 后面的值包装成固定对象的并返回，遇到 return 或者函数结束没有更多的值返回时,再返回 undefined。也就是函数在执行过程中的时候，如果没有遇到 return 语句或者没有 return 时，控制权无法交回被调用的代码。 返回多个值的函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回多个值有什么用？斐波那契数列就是一个很好的例子。接下来，我们分别用普通函数和 generator 生成器看下是怎么实现一个产生斐波那契数列的函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;斐波那契数列：前两个值相加等于第三个值，再前面两个值相加等于后面的值（比如：0，1，1，2，3，5） 普通函数: 123456789function fb(max) &#123; let a = 0, b = 1, arr = [0, 1]; while (arr.length &lt; max) &#123; [a, b] = [b, a + b]; arr.push(b); &#125; return arr;&#125;console.log(fb(6)); //[0, 1, 1, 2, 3, 5] generator: 12345678910111213141516function* fb(max) &#123; let a = 0, b = 1, n = 0; while (n &lt; max) &#123; yield a; [a, b] = [b, a + b]; n++; &#125; return;&#125;var f = fb(5);console.log(f.next()); //&#123;value: 0, done: false&#125;console.log(f.next()); //&#123;value: 1, done: false&#125;console.log(f.next()); //&#123;value: 1, done: false&#125;console.log(f.next()); //&#123;value: 2, done: false&#125;console.log(f.next()); //&#123;value: 3, done: false&#125;console.log(f.next()); //&#123;value: undefined, done: false&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到以上都是采用手动调用的方式，非常的麻烦，接下来我们看下怎么能够实现自动遍历。 自动遍历 generatorfor..of&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterate 是一个迭代器，只要是迭代器就可以循环输出，for…of 循环可以自动遍历 Generator 函数生成的 Iterator 对象。但是，return 的东西不会遍历，主要遍历 yield 的东西。 12345678910function* gen() &#123; yield &quot;Lucy&quot;; yield &quot;DaMing&quot;; return &quot;OK&quot;&#125;let g1 = gen();//for..of遍历for (var item of gen(3)) &#123; console.log(item); //Lucy,DaMing&#125; 解构赋值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解构解的是 yield 的值 1234567891011function* gen() &#123; yield &quot;Lucy&quot;; yield &quot;DaMing&quot;; return &quot;OK&quot;&#125;let g1 = gen();//解构赋值const [a, b, c] = gen();console.log(a, b, c); //Lucy DaMing undefinedconst [x, ...y] = gen();console.log(x, y); //Lucy [&quot;DaMing&quot;] 扩展运算符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还可以配合扩展运算符去使用 12345678function* gen() &#123; yield &quot;Lucy&quot;; yield &quot;DaMing&quot;; return &quot;OK&quot;&#125;let g1 = gen();//扩展运算符console.log(...gen()); //Lucy DaMing 结合 axios 数据请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generator 在实际应用中往往需要配合 promise 去使用，接下来我们写个实例，看看它是怎么用的。这里会用到 axios，用法这边就不详细说了 123456789101112131415//引入axios&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;function* gener() &#123; let username = yield &quot;GWJacqueline&quot;; //获取个人信息 yield axios.get(`https://api.github.com/users/$&#123;username&#125;`);&#125;let genera = gener();//先将username包装成固定对象的并返回console.log(genera.next().value); //GWJacqueline//获取信息var backname = genera.next().value.then((res) =&gt; &#123; console.log(res.data);&#125;);console.log(backname); //&#123;login: &quot;undefined&quot;, id: 11791361, node_id: &quot;MDQ6VXNlcjExNzkxMzYx&quot;, avatar_url: &quot;https://avatars3.githubusercontent.com/u/11791361?v=4&quot;, gravatar_id: &quot;&quot;, …&#125; 以上的例子主要的通过 generator 去获取 github 上面有关于我的一些信息。 实例：同学录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我分别使用 generator 和迭代器实现了一个”同学录浏览功能“，可以点击同学录查看具体效果。迭代器主要代码： 12345678910function showMessage(msg) &#123; let nextIndex = 0; return &#123; next() &#123; return nextIndex &lt; msg.length ? &#123; value: msg[nextIndex++], done: false &#125; : &#123; value: undefined, done: true &#125; &#125; &#125;&#125; generator 主要代码： 12345678function* showMessage() &#123; yield data[0]; yield data[1]; yield data[2]; yield data[3]; yield data[4];&#125; &#125;&#125; 对比完两种方式，明显 generator 比迭代器实现的更加优雅，完整代码可以上我的github查看;","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://gwjacqueline.github.io/tags/ES6/"},{"name":"异步","slug":"异步","permalink":"https://gwjacqueline.github.io/tags/异步/"}]},{"title":"js如何禁用物理返回键","slug":"js如何禁用物理返回键","date":"2019-04-13T01:36:36.000Z","updated":"2019-04-13T07:17:16.000Z","comments":true,"path":"js如何禁用物理返回键/","link":"","permalink":"https://gwjacqueline.github.io/js如何禁用物理返回键/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;最近做的几个项目都有涉及如何禁用 android 和 ios 的物理返回键，今天有空就把怎么禁用以及禁用原理记录一下吧~","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近做的几个项目都有涉及如何禁用 android 和 ios 的物理返回键，今天有空就把怎么禁用以及禁用原理记录一下吧~ 效果展示我的 demo,是不是已经成功禁用了呢？ 核心方法history.pushState(state, title[, url])&nbsp;&nbsp;&nbsp;&nbsp;pushState()是 H5 的 API 中新添加的方法，是实现物理键禁用的核心方法，所以先简单记录下该方法. &nbsp;&nbsp;&nbsp;&nbsp;pushState()是在 history 栈中添加一个新的条目。通过 window.history 方法创建新的历史项。但是它只改变地址栏 url，不刷新页面。pushState()带有三个参数：一个状态对象 state，一个标题（目前没有用，可以传 null），以及一个可选的 URL 地址。和 pushState()用法以及参数一致的方法是 replaceState()。它和 pushState()的区别是：pushState()是在 history 栈中添加一个新的条目，而 replaceState()是替换当前的记录值。因为本篇文章没有用到 replaceState(），所以这里就不进行详细说明了。 popstate &nbsp;&nbsp;&nbsp;&nbsp;当活动历史记录条目更改时，就会触发该事件。这样就可以帮助我们后面去监听用户点击返回的事件了。需要注意的是调用 history.pushState()或 history.replaceState() 不会触发 popstate 事件。当调用以上两个方法去替换新的历史项，popstate 事件的 state 属性会包含历史项状态对象的拷贝。只有在做出浏览器动作时，才会触发 popstate 事件，比如用户点击浏览器的前进回退按钮。这边经过测试，不同的浏览器在加载页面时处理 popstate 事件的形式存在差异，Chrome 和 Safari 通常会触发 popstate 事件，但 Firefox 则不会。 实现原理&nbsp;&nbsp;&nbsp;&nbsp;明白了以上两个核心方法后，就能很好的看懂禁用物理键返回的原理了。实际上就是：在监听到用户点击返回键时，在 history 栈中添加一个当前的地址。这样用户就怎么也返回不了啦~ 主要代码1234567891011121314const back = &#123;&#125;;back.onPopState = function () &#123; back.record(&quot;back&quot;);&#125;;back.record = function (state) &#123; history.pushState(state, null, location.href);&#125;back.init = function () &#123; //每次监听到返回键，都使用pushState插入一条历史记录,popstate 事件的 state 属性会包含历史项状态对象的拷贝 window.addEventListener(&quot;popstate&quot;, back.onPopState); // 在初始化的时候，先插入一条历史记录，避免用户按返回键 back.record(&quot;back&quot;);&#125;back.init();","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"物理返回键","slug":"物理返回键","permalink":"https://gwjacqueline.github.io/tags/物理返回键/"}]},{"title":"手机端调用搜索键盘","slug":"手机端调用搜索键盘","date":"2019-04-12T08:12:27.000Z","updated":"2019-04-12T14:16:05.000Z","comments":true,"path":"手机端调用搜索键盘/","link":"","permalink":"https://gwjacqueline.github.io/手机端调用搜索键盘/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;本文主要记录下如何调用系统的搜索键盘，经过实际测试以下代码可以兼容 ios 和 Android 系统","text":"&nbsp;&nbsp;&nbsp;&nbsp;本文主要记录下如何调用系统的搜索键盘，经过实际测试以下代码可以兼容 ios 和 Android 系统 大家可以用手机测试下我的 demo是否能正常调用系统的搜索键盘呢？ Html注意点： 必须在 input 输入框外用 form 表单包起来，并且要加”action”，否则在 ios 上键盘上无法弹出”搜索二字“ 123&lt;form id=&quot;formid&quot; action=&quot;#&quot;&gt; &lt;input name=&quot;name&quot; id=&quot;search&quot; type=&quot;search&quot; placeholder=&quot;我是一个输入框&quot;/&gt;&lt;/form&gt; js监听搜索按钮： 通过键盘键值匹配监听用户点击搜索按钮 12345document.getElementById(&quot;search&quot;).addEventListener(&quot;keydown&quot;, function(e) &#123; if (e.keyCode == &quot;13&quot;) &#123; alert(&quot;成功调用搜索框啦~&quot;); &#125;&#125;); 优化点部分手机在搜索框聚焦时，会出现下图所示的打叉样式： 可通过以下代码去除自带叉号样式：123input::-webkit-search-cancel-button &#123; display: none;&#125;","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://gwjacqueline.github.io/tags/移动端/"},{"name":"搜索","slug":"搜索","permalink":"https://gwjacqueline.github.io/tags/搜索/"},{"name":"返回","slug":"返回","permalink":"https://gwjacqueline.github.io/tags/返回/"}]},{"title":"天花乱坠的数组方法(二)","slug":"天花乱坠的数组方法(二)","date":"2019-04-07T11:35:39.000Z","updated":"2019-04-12T12:18:46.000Z","comments":true,"path":"天花乱坠的数组方法(二)/","link":"","permalink":"https://gwjacqueline.github.io/天花乱坠的数组方法(二)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上篇文章中很详细的说了 ES6 当中常用的数组方法，本篇文章快刀斩乱马的根据”原数组是否会被修改”的分类说下 ES5 中常见的数组方法吧","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上篇文章中很详细的说了 ES6 当中常用的数组方法，本篇文章快刀斩乱马的根据”原数组是否会被修改”的分类说下 ES5 中常见的数组方法吧 原数组不会被修改数组转换为字符串：join()二话不说，上代码： 12345var arrJoin= [1,2,3,4,5];console.log(arrJoin.join(&quot;&quot;)); //12345console.log(arrJoin.join(&quot;❤️&quot;)); //1❤️2❤️3❤️4❤️5// 事实证明：原数组不会被修改console.log(arrJoin); //[1, 2, 3, 4, 5] 来个实用的场景吧：将某个字符重复 n 次 12345function repeat(str,n)&#123; return new Array(n+1).join(str);&#125;console.log(repeat(&quot;哈&quot;,3)); //哈哈哈console.log(repeat(&quot;hi&quot;,5));//hihihihihi 数组的合并：concat()看看怎么用？ 12345678var arrConcat = [1,2,3];console.log(arrConcat.concat(4,5)); //[1, 2, 3, 4, 5]// 会被拉平为一维数组console.log(arrConcat.concat(4,5,[6,7])); //[1, 2, 3, 4, 5, 6, 7]//数组中还有数组时，不会被拉平console.log(arrConcat.concat(4,[5,[6,7]])); //[1, 2, 3, 4, 5,[6,7]]//concat()不会改变原数组console.log(arrConcat); //[1, 2, 3] 返回部分数组：slice()任性上代码： 1234567var arrSlice = [1,2,3,4,5];console.log(arrSlice.slice(1)); //[2,3,4,5]console.log(arrSlice.slice(0,2)); //[1,2]console.log(arrSlice.slice(1,4)); //[2,3,4]console.log(arrSlice.slice(1,-1)); //[2,3,4]console.log(arrSlice.slice(2,-1)); //[3,4]console.log(arrSlice); //[1,2,3,4,5] 看完代码后，我们可以总结下 slice()的用法:slice(start,end)start:必须参数，指从何处开始截取，包含该处end:可选参数，指从何处结束截取，不包含该处，该参数为负数时，指从数组尾部开始算起的位置 原数组会被修改数组逆序：reverse()1234var arrReverse = [1,2,3,4,5];console.log(arrReverse.reverse()); //[5, 4, 3, 2, 1]// 注意：原数组被修改了哦console.log(arrReverse); //[5, 4, 3, 2, 1] 数组排序：sort()1234567var arrSort = [&apos;a&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;,&apos;d&apos;]; console.log(arrSort.sort()); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;] // 注意：原数组被修改了哦 console.log(arrSort); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;] //让我们再来看看数字 var arrSortNumber = [1,19,2,25,8]; console.log(arrSortNumber.sort()); //[1, 19, 2, 25, 8] 可以看到 arrSortNumber 没有按照我们期望的输出，因为如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。让我们看看如何对数字进行正确的排序。 123456789var arrSortNumber = [1,19,2,25,8];// 升序排列console.log(arrSortNumber.sort(function(a,b)&#123; return a-b; //[1, 2, 8, 19, 25]&#125;));// 降序排列console.log(arrSortNumber.sort(function(a,b)&#123; return b-a; //[[25, 19, 8, 2, 1]&#125;)); 数组拼接：splice()12345678910var arrSplice = [&apos;a&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;,&apos;d&apos;];console.log(arrSplice.splice(2)); //[&apos;e&apos;,&apos;b&apos;,&apos;d&apos;]// 注意：原数组被修改了console.log(arrSplice); //[&quot;a&quot;, &quot;c&quot;]var arrSplice2 = [&apos;b&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;,&apos;d&apos;];console.log(arrSplice2.splice(2,2)); //[&apos;e&apos;,&apos;b&apos;]console.log(arrSplice2); //[[&quot;b&quot;, &quot;c&quot;, &quot;d&quot;]var arrSplice3 = [&apos;c&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;,&apos;d&apos;];console.log(arrSplice3.splice(2,2,&apos;h&apos;,&apos;j&apos;)); //[&quot;e&quot;, &quot;b&quot;]console.log(arrSplice3); //[&quot;c&quot;, &quot;c&quot;, &quot;h&quot;, &quot;j&quot;, &quot;d&quot;] 从以上代码可以总结下 splice()的使用方法splice(start,number,item);start：必选参数，代表要删除的起始位置，包括该位置number：可选参数，删除的个数item: 可选参数，插入的片段 数组增删：123456789101112131415161718192021var arrOperate = [];//push()数组尾部增加元素arrOperate.push(1,2);console.log(arrOperate); //[1,2]//通过length的方式在尾部增加元素arrOperate[arrOperate.length] = 3;console.log(arrOperate);//[1,2,3]//在数组头部增加元素arrOperate.unshift(-1,0);console.log(arrOperate); //[-1,0,1,2,3]//delete方法只是将对应元素改成Undefineddelete arrOperate[0];console.log(arrOperate); //[undefined,0,1,2,3]如果0位置设置为&quot;undefined&quot;，则为trueconsole.log(0 in arrOperate); //false//pop()删除元素的最后一位arrOperate.pop();console.log(arrOperate); //[undefined,0,1,2]//pop()删除元素的第一位arrOperate.shift();console.log(arrOperate); //[0,1,2]","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://gwjacqueline.github.io/tags/ES6/"},{"name":"数组","slug":"数组","permalink":"https://gwjacqueline.github.io/tags/数组/"}]},{"title":"天花乱坠的数组方法(一)","slug":"天花乱坠的数组方法(一)","date":"2019-04-06T09:52:39.000Z","updated":"2019-04-12T01:43:38.000Z","comments":true,"path":"天花乱坠的数组方法(一)/","link":"","permalink":"https://gwjacqueline.github.io/天花乱坠的数组方法(一)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组是 JS 当中很重要的一个部分，它有很多很多很多的方法，对于我这样记性不好的人来说，一些不常用的方法经常会被遗忘，经常需要再次查找才能想起来。今天为了能给自己加深对数组方法的记忆，将通过两个章节去整理下常用的数组方法。第一个章节将记录下 ES6 中常见的数组方法，其中将详细记录下部分数组，第二个章节将简单整理下 ES5 之前的数组方法。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组是 JS 当中很重要的一个部分，它有很多很多很多的方法，对于我这样记性不好的人来说，一些不常用的方法经常会被遗忘，经常需要再次查找才能想起来。今天为了能给自己加深对数组方法的记忆，将通过两个章节去整理下常用的数组方法。第一个章节将记录下 ES6 中常见的数组方法，其中将详细记录下部分数组，第二个章节将简单整理下 ES5 之前的数组方法。 ES6 中新增的数组方法数组元素遍历：for 循环/forEach()在 ES6 之前还没有 forEach()方法时，我们通常是使用 for 循环对数组进行遍历的。 ES5 之前：for 循环遍历数组实例：12345//通过for循环将数组中的元素遍历出来var color = [&apos;blue&apos;,&apos;yellow&apos;,&apos;red&apos;];for(var i=0;i&lt;color.length;i++)&#123; console.log(color[i]); //blue,yellow,red&#125; 有了 forEach()方法后，数组的遍历整体变得更加可观，直接用数组调用对应的内容 forEach()遍历数组实例：12345var colorES6 = [&apos;blue&apos;,&apos;yellow&apos;,&apos;red&apos;,&apos;white&apos;];//forEach()中放一个迭代函数，colorES6作为形参去接受数组里的每一个内容colorES6.forEach(function(colorES6)&#123; console.log(colorES6); //blue,yellow,red,white&#125;); forEach()遍历数组的优点：123456789//求数组元素的总和var numbers = [1,2,3,4,5];var sum = 0; //用于接收数组的总和//forEach可以将函数抽离出来function num(number)&#123; sum+=number;&#125;numbers.forEach(num);console.log(sum); //15 以上代码我们可以看出 forEach()的好处不止让代码变得更加可观，可以直接调用数组里的内容，还可以将函数抽离出来 forEach()遍历数组的过程：为了能加深对 forEach()的理解，可以用一个流程图来简单画出 forEach()遍历数组的过程： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图中画的是”forEach()遍历数组实例”中的过程：第一次先将blue放在迭代器里，将它打印出来，第二次再将yellow放在迭代器里，将它打印出来，以此类推。 直达找到最后一个没有的时候，那么当前的循环就结束了。 forEach()使用的场景：比如：一个表单有一个多选框，再提交表单时，需要遍历选中的元素并进行相应操作。 数组的映射：map()映射这两个字大家可能会觉得有点抽象，通俗点来说就是对数组进行一些转化。常用的场景有两种：1.在拷贝数组的过程中改变一些东西2.在数组中拿到一些固定的属性接下来我将用for循环和ES6新方法map()编写上面两种场景 场景一：将数组A以两倍的形式放到数组B中去ES5之前：for循环+push()实现场景一123456var oldA = [1,2];var oldB = [];for(var i=0;i&lt;oldA.length;i++)&#123; oldB.push(oldA[i]*2); //将数组A中的元素乘以2后放置到数组A中&#125;console.log(oldB); //[2,4] map()实现场景一123456var arrA = [1,2,3];//map返回的就是数组，所以不需要 var arrB =[];var arrB = arrA.map(function(x)&#123; //map里面依旧放迭代器函数 return 2 * x; &#125;);console.log(arrB); //[2,4,6] 场景二：有一个对象数组A，把数组A中对象的name属性存储到对象B上ES5之前：for循环+push()实现场景二123456789var oldarrObjectA = [ &#123;name: &quot;Lucy&quot;,age: 13&#125;, &#123;name: &quot;Tom&quot;,age: 14&#125;];var oldarrObjectB = [];for(i=0;i&lt;oldarrObjectA.length;i++)&#123; oldarrObjectB.push(oldarrObjectA[i].name);&#125;console.log(oldarrObjectB); //[&quot;Lucy&quot;, &quot;Tom&quot;] map()实现场景二123456789var arrObjectA = [ &#123;name: &quot;Lucy&quot;,age: 13&#125;, &#123;name: &quot;Tom&quot;,age: 14&#125;, &#123;name: &quot;Lili&quot;,age: 15&#125;];var arrObjectB = arrObjectA.map(function(x)&#123; return x.name;&#125;);console.log(arrObjectB); //[&quot;Lucy&quot;, &quot;Tom&quot;, &quot;Lili&quot;] map()和forEach()一样，里面放的都是迭代器函数。map()返回的是一个新的数组。这里我们需要注意一下map()是需要返回值的，如果不给返回值，则默认返回undefined。123456// 不给map返回值var arrA = [1,2,3];var arrB = arrA.map(function(x)&#123; 2 * x;&#125;);console.log(arrB); //[undefined, undefined, undefined] map()映射数组的过程：接下来，我们用一个流程图来简单画出场景一中map()映射数组的过程： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;场景一中A数组想要做的事情就是让B数组中装的是它的两倍，map里面的方法会拥有一个迭代器函数。比如a.map()，它会将a中的每个值放到迭代器函数中的形参里面，然后将值乘以2后返回到新数组中。例如拿到”1”后，乘以2再返回到新数组中去。 使用场景：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：基金产品中会有很多种基金，我们假设每个基金都是一个对象，每个基金都会有很多属性：比如基金名字、关注度、收益率等。后台人员需要获取每个基金的关注度时，就可以采取map()方法。 数组的过滤：filter()过滤数组是我们开发中经常会遇到的问题，接下来我会使用三个常见的场景加深对filter()方法的理解 场景一：把不想要的值过滤掉，拿出我们想要的值(假定有一个对象数组A，获取数组中指定类型的对象放到数组B中)12345678910111213141516171819//将typeA中为男性的对象抽取出来var typeA = [ &#123;name: &apos;Lily&apos;,gender: &apos;female&apos;&#125;, &#123;name: &apos;Lucy&apos;,gender: &apos;female&apos;&#125;, &#123;name: &apos;Peter&apos;,gender: &apos;male&apos;&#125;,];// ES5之前：for循环+push()的实现var typeB = [];for(var i=0;i&lt;typeA.length;i++)&#123; if(typeA[i].gender===&apos;male&apos;)&#123; typeB.push(typeA[i]); &#125;&#125;console.log(typeB); //[&#123;name: &quot;Peter&quot;, gender: &quot;male&quot;&#125;]// ES6 filter()的实现var typeC = typeA.filter(function(x)&#123; return x.gender===&apos;male&apos;; //[&#123;name: &quot;Peter&quot;, gender: &quot;male&quot;&#125;]&#125;);console.log(typeC); //&#123;name: &quot;Peter&quot;, gender: &quot;male&quot;&#125; 场景二：假定有一个对象数组A，过滤掉不满足以下条件的对象：条件：性别女，年龄大于13岁，班级不为3班的123456789var personA = [ &#123;name: &apos;Lily&apos;,gender: &apos;female&apos;,age:16,class:1&#125;, &#123;name: &apos;Lucy&apos;,gender: &apos;female&apos;,age:14,class:2&#125;, &#123;name: &apos;Peter&apos;,gender: &apos;male&apos;,age:17,class:3&#125;,];var choosePerson = personA.filter(function(x)&#123; return x.gender === &apos;female&apos; &amp;&amp; x.age&gt;13 &amp;&amp;x.class !==3&#125;);console.log(choosePerson); //[&#123;name: &quot;Lily&quot;, gender: &quot;female&quot;, age: 16, class: 1&#125;,&#123;name: &quot;Lucy&quot;, gender: &quot;female&quot;, age: 14, class: 2&#125;] 场景三：根据对象A的id值，过滤掉B数组中与对象A中id值不符的元素12345678910var objA = &#123;id:1,title:&apos;haha&apos;&#125;;var filterId = [ &#123;id:1,content:&apos;filter&apos;&#125;, &#123;id:2,content:&apos;filter&apos;&#125;, &#123;id:1,content:&apos;filter2&apos;&#125;];filterId = filterId.filter(function(x)&#123; return x.id === objA.id;&#125;);console.log(filterId); //[&#123;id: 1, content: &quot;filter&quot;&#125;,&#123;id: 1, content: &quot;filter2&quot;&#125;] filter()过滤数组的过程：看了以上三个场景后，对filter的使用方法应该有所了解了，接下来，我们结合场景一看看filter是怎样实现过滤的 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们在遍历数组typeA时，会将当前类型的值放到迭代器函数里面，去对它进行匹配，因为我们拿到的是每个对象，当每个对象下的gender值为male时，则为匹配成功，会以return true的形式返回，并放到typeC数组中。如果匹配不成功，则返回false,且不会放到typeC数组中。 数组的查找：find()通过find()方法可以帮我们找到对应的东西。还是根据两个常用的场景来看看find()怎么用吧。 场景一：假定有一个对象数组，找到符合条件的对象并存储起来1234567891011121314151617181920//快速找到findA中姓名为&apos;Billy&apos;的对象var findA = [ &#123;name: &apos;Lucy&apos;&#125;, &#123;name: &apos;Peter&apos;&#125;, &#123;name: &apos;Billy&apos;&#125;];var thisA;//ES5之前：for循环for(var i=0;i&lt;findA.length;i++)&#123; if(findA[i].name === &apos;Billy&apos;)&#123; thisA = findA[i]; break; //找到之后结束循环，避免浪费时间 &#125;&#125;console.log(thisA); //&#123;name: &quot;Billy&quot;&#125;//ES6 find()：找到第一个符合条件的对象，就不会再次循环var thisB = findA.find(function(x)&#123; return x.name === &apos;Billy&apos;&#125;);console.log(thisB); //&#123;name: &quot;Billy&quot;&#125; 场景二：假定有一个对象数组，根据指定对象的条件找到数组中符合条件的对象123456789101112var findArr = [ &#123;name: &apos;Lucy&apos;,age: 13&#125;, &#123;name: &apos;Billy&apos;,age: 17&#125;, &#123;name: &apos;Peter&apos;,age: 13&#125; ]; var choosefindArr =&#123;name: &apos;Bob&apos;,age: 13&#125;; function choose(findArr,choosefindArr)&#123; return findArr.find(function(x)&#123; return x.age === choosefindArr.age; &#125;); &#125; console.log(choose(findArr,choosefindArr)); //&#123;name: &quot;Lucy&quot;, age: 13&#125; find()的工作流程：find()的特点在于：找到对应的条件，就不会继续往下执行。能帮助我们快速查找到对应的内容。接下来，我们根据场景1来看看它的工作模式是什么样的吧 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们遍历findA这个数组通过find()时，会将每个name放到迭代器函数中，去判断目前的name和我们想要的name是否相等。如果不相等，则会返回一个false,就没有任何东西；如果相等，则返回true，并将对应的内容返回到thisA中。 一真即真，一假即假的：every()、some()every()所有条件都满足，才返回true；some(),只要一个条件满足，就返回true()。 场景一：查询班级成员成绩达标情况，成绩大于60表示达标，小于60为不达标1234567891011121314151617181920212223242526var classMark = [ &#123;name: &apos;Lucy&apos;,mark: 90&#125;, &#123;name: &apos;Peter&apos;,mark: 80&#125;, &#123;name: &apos;Billy&apos;,mark: 20&#125;];//ES5之前：for循环 方法var markeveryOK = true; //成绩全部达标var marksomeOK = false; //成绩部分达标 for(var i=0;i&lt;classMark.length;i++)&#123; if(classMark[i].mark &lt; 60)&#123; markeveryOK = false; &#125;else&#123; marksomeOK = true; &#125; &#125; console.log(markeveryOK,marksomeOK); //false true//every()/some()方法; //成绩全部达标,一旦返回的是假，后续的东西就不会再去遍历了var markeveryOKES6 = classMark.every(function(x)&#123; return x.mark &gt; 60;&#125;);//成绩部分达标，一旦返回的是真，后续的东西就不会再去遍历了var marksomeOKES6 = classMark.some(function(x)&#123; return x.mark &gt;60;&#125;);console.log(markeveryOKES6,marksomeOKES6); //false true 场景二：一个表单页面，判断所有输入框内容的长度是否大于01234567891011121314151617// 获取输入框的内容function Field(value)&#123; this.value = value;&#125;// 判断当前输入框内容的长度是否大于0Field.prototype.validate = function()&#123; return this.value.length &gt; 0;&#125;var filedName = new Field(&apos;Lucy&apos;);var filedage = new Field(&apos;&apos;);var filedpassword = new Field(&apos;123456&apos;);var fieldArr = [filedName,filedage,filedpassword];// 用every方法判断是否所有输入框内容的长度都大于0var result = fieldArr.every(function(x)&#123; return x.validate();&#125;);console.log(result); //false every()的工作流程：every()的特点：一旦返回的是假，就不会再去遍历了。接下来我们结合场景一简单说下every()的工作流程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学生的成绩分别是：90，80，20。我们首先把”90”放到迭代器函数中，然后和我们的60进行匹配。90不小于60，所以markeveryOKES6为true。20小于60，所以markeveryOKES6为false。最终会将返回值用&amp;&amp;运算符输出，即一假即假。some() some()的工作流程：every()的特点：一旦返回的是真，就不会再去遍历了 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次把90放到迭代器函数中，marksomeOKES6为true。当some()返回为true时，则不再进行遍历。即一真即真 把数组聚合成结果 reduce()reduce()可以替代大多数数组的方法，比如forEach、map()等，接下来我们看看它是怎么替代和应用的 场景一：代替forEach()计算数组中所有值的总和12345var reduce =[10,20,30];var sum = reduce.reduce(function(x,y)&#123; return x+y;&#125;,10); //这里放初始值console.log(sum); //70 场景二：代替map()将数组中对象的某个属性抽离到另外一个数组中12345678910var reduceArr =[ &#123;name:&apos;Lucy&apos;,age:11&#125;, &#123;name:&apos;David&apos;,age:19&#125;, &#123;name:&apos;Billy&apos;,age:13&#125;];var choosereduceArr = reduceArr.reduce(function(x,y)&#123; x.push(y.name); return x;&#125;,[]);console.log(choosereduceArr); // [&quot;Lucy&quot;, &quot;David&quot;, &quot;Billy&quot;] 场景三：判断字符串中括号是否对称例如：（（（））） 对称（）（）（） 对称(（（） 不对称12345678910function bracket(string)&#123; // 先将字符串变为数组 return !string.split(&apos;&apos;).reduce(function(x,y)&#123; if(y === &quot;(&quot;)&#123;++x;&#125;; if(y === &quot;)&quot;)&#123;--x;&#125;; return x; &#125;,0);&#125;console.log(bracket(&apos;(())&apos;)); //trueconsole.log(bracket(&apos;(())))))&apos;)); //false reduce()的工作流程：接下来我们结合场景一看看reduce()是如何把数组聚合成结果的吧 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;场景一中reduce arr是10、20、30，当我们在遍历的时候，这个参数的初始化值为10，然后我们拿到的就是10+20，然后第二个值就为20，然后再次与迭代器函数里的值相加，以此类推得到最后一个结果。 reduceRight()从字面很好理解，reduce()遍历的顺序是从左往右，相反它的从右往左。和redece()的区别就是遍历顺序。这里就不多做解释了。 数组的检索indexOf()该方法将根据我们查找的对象，从头到尾的去检索数组，返回我们查找对象的位置1234567var arr = [1,2,3,-1,2,3];console.log(arr.indexOf(2)); //1console.log(arr.indexOf(99)); //-1console.log(arr.indexOf(1,0)); //0console.log(arr.indexOf(2,2)); //4console.log(arr.indexOf(2,-1)); //-1console.log(arr.indexOf(2,-3)); //-4 从以上的例子可以总结下indexOf()的使用方法indexOf(i,p)会返回从p位置开始检索的对象i，检索完成后返回对象i在数组中的位置i：必传参数，查找的对象p: 可传参数，从数组的哪个位置开始找 数组的检索lastndexOf()indexOf的区别就是，lastIndexOf是从右往左找的。1234var arr = [1,2,3,-1,2,3];console.log(arr.lastIndexOf(2)); //4console.log(arr.lastIndexOf(1,0)); //0console.log(arr.lastIndexOf(2,-1)); //4 数组的检索indexOf()该方法将根据我们查找的对象，从头到尾的去检索数组，返回我们查找对象的位置1234567var arr = [1,2,3,-1,2,3];console.log(arr.indexOf(2)); //1console.log(arr.indexOf(99)); //-1console.log(arr.indexOf(1,0)); //0console.log(arr.indexOf(2,2)); //4console.log(arr.indexOf(2,-1)); //-1console.log(arr.indexOf(2,-3)); //-4 从以上的例子可以总结下indexOf()的使用方法indexOf(i,p)会返回从p位置开始检索的对象i，检索完成后返回对象i在数组中的位置i：必传参数，查找的对象p: 可传参数，从数组的哪个位置开始找 判断是否为数组 isArray()我们来回顾下原先没有isArray()的时候，我们通常是怎么判断是否为数组的1234var obj = [1,2,3,-1,2,3];console.log(Object.prototype.toString.call(obj)); //[object Array]console.log(obj instanceof Array); //trueconsole.log(obj.constructor === Array); //true 有了isArray()后，我们可以直接使用这个方法来判断数组啦~1234var obj = [1,2,3,-1,2,3];var obj2 = &#123;name:&apos;Lucy&apos;&#125;;console.log(Array.isArray(obj)); //trueconsole.log(Array.isArray(obj2)); //false 以上篇幅有些长，主要介绍了ES6新增的一些常用数组，接下来第二篇，将简单回顾下ES5一些数组的常用方法吧~","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://gwjacqueline.github.io/tags/ES6/"},{"name":"数组","slug":"数组","permalink":"https://gwjacqueline.github.io/tags/数组/"}]},{"title":"移动端常见兼容性问题","slug":"移动端常见兼容性问题","date":"2019-04-01T08:12:27.000Z","updated":"2019-04-13T01:34:46.000Z","comments":true,"path":"移动端常见兼容性问题/","link":"","permalink":"https://gwjacqueline.github.io/移动端常见兼容性问题/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;本文主要想记录下最近工作中遇到的一些移动端兼容问题，便于日后能够快速解决一些 Bug。","text":"&nbsp;&nbsp;&nbsp;&nbsp;本文主要想记录下最近工作中遇到的一些移动端兼容问题，便于日后能够快速解决一些 Bug。 ios fixed 定位+长表单 主要代码：12345678&lt;body&gt; &lt;header&gt; &lt;!-- fixed定位的头部 --&gt; &lt;header&gt; &lt;section&gt; &lt;!-- 自然布局 --&gt; &lt;/section&gt;&lt;/body&gt; bug描述：只有在ios上出现：当section过长(有滚动条时)，表单获取焦点时。上图红色框的头部会掉落至绿色部分。 bug解决：造成问题的原因：当表单获取焦点，键盘弹出时，可视高度变小。解决方式：表单获取焦点时，把fixed定位改成absolute;失去焦点时，改回来。个人建议：在实际开发中，避免让头部使用fixed定位。页面整体建议采用flex布局，减少页面高度计算。 Android footer 绝对定位 主要代码：1234567891011&lt;body&gt; &lt;header&gt; &lt;!-- absolute定位的头部 --&gt; &lt;header&gt; &lt;section&gt; &lt;!-- 自然布局 --&gt; &lt;/section&gt; &lt;section&gt; &lt;!-- fixed定位的footer --&gt; &lt;/section&gt;&lt;/body&gt; bug描述：只有在Android手机上出现：表单获取焦点时,系统键盘会将fixed定位的footer顶起来。 bug解决：造成问题的原因：系统键盘会顶走fixed布局元素。解决方式：1.表单获取焦点时，把fixed定位的元素改成static；失焦后，再改回来。2.表单获取焦点时，把fixed定位的元素设置为display:none；失焦后，再设置成为display:block。 ios 微信浏览器 长表单留白 bug描述：只有在ios微信浏览器上出现。当输入框聚焦，系统键盘把页面顶起后，键盘收起。会发现页面底部留白 bug解决：造成问题的原因：系统键盘弹出触发resize导致页面高度缩小。解决方式：12345$(&quot;input,textarea&quot;).blur(function () &#123; setTimeout(function () &#123; //若不加定时器，部分手机会失效 $(&quot;body&quot;).scrollTop($(body).scrollTop()+1); //让页面偷偷滚动一下，消除空白 &#125;,100);&#125;); transform弹窗不居中 主要代码：123456789101112/*弹窗*/.dialog-content &#123; position: absolute; top: 50%; left: 50%; z-index: 10003; width: 73%; padding-top: .66667rem; transform: translate(-50%,-50%); background-color: rgba(255,255,255,.95); border-radius: .21333rem;&#125; bug描述：在ios 8及以下的系统，弹窗不居中 bug解决：造成问题的原因：Safari支持代替的-webkit-transform属性，读取不到transform属性解决方式：加上-webkie-transform属性，注意兼容性写法顺序1234567891011121314/*弹窗*/.dialog-content &#123; position: absolute; top: 50%; left: 50%; z-index: 10003; width: 73%; padding-top: .66667rem; background-color: rgba(255,255,255,.95); border-radius: .21333rem; -webkit-transform: translate(-50%,-50%); //一定要加上兼容性的写法 -ms-transform: translate(-50%,-50%); //IE9以下不兼容，IE9支持代替的-ms-transform属性不过只支持2D transform: translate(-50%,-50%);&#125; ios 输入框背景色变黄 主要代码：1234567input&#123; border: none; background: 0 0; display: block; -webkit-tap-highlight-color: transparent; //只用于iOS。点击链接或者通过Javascript定义的可点击元素的时候，会出现一个半透明的灰色背景 -webkit-appearance: none; //消除输入框和按钮的原生外观，在iOS上加上这个属性才能给按钮和输入框自定义样式&#125; bug描述：自动填充表单时，输入框背景色变黄。 bug解决：造成问题的原因：如果不设置，autocomplete默认是on的解决方式：1.利用H5新增属性 autocomplete=”off”，直接关闭自动填充1&lt;input type=&quot;text&quot; autocomplete=&quot;off&quot;&gt; 2.给form表单增加autocomplete=”off”，一次性取消表单内所有输入框的自动填充功能123&lt;form autocomplete=&quot;off&quot;&gt; &lt;input type=&quot;text&quot; &gt;&lt;/form&gt; 3.利用css12345//给input设置内置阴影！阴影大小一定要比你的input本身大input:-webkit-autofill &#123; -webkit-box-shadow: 0 0 0px 1000px white inset !important;//输入框背景颜色 -webkit-text-fill-color: #000!important;//输入框文字颜色&#125; ios 弹出框被遮罩层盖住 主要代码：123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;header&gt; &lt;!-- 头部代码 --&gt; &lt;/header&gt; &lt;section class=&quot;content&quot;&gt; &lt;!-- 打开弹窗按钮 --&gt; &lt;section class=&quot;btn-wrap&quot;&gt; &lt;input value=&quot;打开&quot;&gt; &lt;/section&gt; &lt;!-- 弹出框 fixed定位--&gt; &lt;div class=&quot;keyboard&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;!-- 遮罩层 fixed定位--&gt; &lt;div class=&quot;mask-black&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;style&gt;.mask-black &#123; background-color: rgba(51,51,51,.75); position: fixed; z-index: 500; bottom: 0; right: 0; left: 0; top: 0;&#125;.keyboard &#123; position: fixed; bottom: 0; left: 0; width: 100%; z-index: 1000;&#125;&lt;/style&gt; bug描述：在PC端及安卓上显示正常，唯独在ios上弹窗被遮档 bug解决：造成问题的原因：虽然z-index的层级问题没错，但是代码结构不规范。个人感觉很多时候一些奇怪的bug来源于我们代码的不规范。解决方式：将弹出框移至外层123456789101112131415&lt;body&gt; &lt;header&gt; &lt;!-- 头部代码 --&gt; &lt;/header&gt; &lt;section class=&quot;content&quot;&gt; &lt;!-- 打开弹窗按钮 --&gt; &lt;section class=&quot;btn-wrap&quot;&gt; &lt;input value=&quot;打开&quot;&gt; &lt;/section&gt; &lt;/section&gt; &lt;!-- 弹出框 fixed定位--&gt; &lt;div class=&quot;keyboard&quot;&gt;&lt;/div&gt; //将弹出框移至外层 &lt;!-- 遮罩层 fixed定位--&gt; &lt;div class=&quot;mask-black&quot;&gt;&lt;/div&gt;&lt;/body&gt; ios 时间格式 主要代码：1var date = new Date(&quot;2019-07-21&quot;); bug描述：在ios上时间选择弹窗不能正常打开，报错显示NaN bug解决：造成问题的原因：ios对date()的支持不一样，ios只支持”/“的方式解决方式：修改时间格式1var date = new Date(&quot;2019/07/21&quot;); 个人建议：时间格式还是尽量用”/“的方式。 这个bug是我们组一个很腻害的小姐姐在编写时间插件的时候发现的，随即我就种草了哈哈哈 大家有兴趣可以看看她写的时间插件 ios fixed按钮上下飘动 主要代码：1234567891011121314&lt;body&gt; &lt;header&gt; &lt;!-- 头部代码 绝对定位--&gt; &lt;/header&gt; &lt;!-- 内容代码 绝对定位--&gt; &lt;section class=&quot;content&quot;&gt; &lt;!-- 列表 --&gt; &lt;ul&gt;&lt;/ul&gt; &lt;!-- fixed置底定位按钮 --&gt; &lt;section class=&quot;btn-wrap&quot;&gt; &lt;input value=&quot;打开&quot;&gt; &lt;/section&gt; &lt;/section&gt;&lt;/body&gt; bug描述：只出现在ios上，当列表ul过长时，快速滚动页面，fixed置底按钮会上下飘动 bug解决：解决方式：将fixed置底定位的按钮移到最外层123456789101112131415&lt;body&gt; &lt;header&gt; &lt;!-- 头部代码 绝对定位--&gt; &lt;/header&gt; &lt;!-- 内容代码 绝对定位--&gt; &lt;section class=&quot;content&quot;&gt; &lt;!-- 列表 --&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/section&gt; &lt;!-- fixed置底定位按钮 移到最外层--&gt; &lt;section class=&quot;btn-wrap&quot;&gt; &lt;input value=&quot;打开&quot;&gt; &lt;/section&gt;&lt;/body&gt; h5虚拟键盘，密码框假光标移动问题 描述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用h5虚拟键盘时，需要让输入框disabled,以至于没有系统光标。需要编写一个假光标，提升用户体验。因为输入框采用”type=”password”,所以会采用系统自带的密码遮掩点。每个系统密码遮掩点都不大一样。经过多台真机的多次调试，发现大致可分为四类：大部分安卓、vivo X9S、Vivo X20、ios。为了便于以后遇到类似问题，又需要大量时间进行调试，现在先记录下调试结果。 光标移动距离的计算： 光标移动距离=(密码个数*dotWidth)em;Ios: dotWidth=1vivo X9S: dotWidth=0.5Vivo X20: dotWidth=0.49其余机型：dotWidth=0.34获取机型的方法：123if(navigator.userAgent.indexOf(“vivo X9s”)!==-1)&#123; alert(&quot;是vivo X9s&quot;);&#125; 弹性盒子兼容问题描述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前做过基于Android的智能电视项目，最早的需求是说最低兼容到Android5.0以上，于是就疯狂舒畅自由的使用新版盒子模型的写法。可是需求总是多变的，在开发接近尾声的时候，改成了兼容到Android3还是4。于是在低版本电视上盒子布局的前端页面变得面目全非。导致后来在使用盒子模型的时候总是小心翼翼，毕竟低版本的电视和手机还是有人用的。现在就记录下常见盒子模型的兼容写法把，能够让我们在面对测试提出页面bug的时候，快速定位问题所在并且解决它~ 兼容写法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//flex 布局.flex&#123;display: -webkit-box; /_ 老版本语法 _/display: -moz-box; /_ 老版本语法: Firefox/display: -webkit-flex; /_ 新版本语法\\*/display: flex;&#125;//两端对齐.flex-between&#123;-webkit-box-pack: justify;-moz-justify-content: space-between;-webkit-justify-content: space-between;justify-content: space-between;&#125;//左右、上下居中.flex-center&#123;-webkit-box-pack: center; /_ 左右 _/-moz-justify-content: center;-webkit-justify-content: center;justify-content: center;-webkit-box-align: center; /_ 上下 _/-moz-align-items: center;-webkit-align-items: center;align-items: center;&#125;//垂直对齐.flex-column&#123;-webkit-box-direction: normal;-webkit-box-orient: vertical;-moz-flex-direction: column;-webkit-flex-direction: column;flex-direction: column;&#125;//盒子相应比例(scss 写法)@mixin flex-block($con:1)&#123; -webkit-box-flex: 1; -moz-box-flex: 1; -ms-flex: $con;-webkit-flex: $con; flex: $con;&#125;//引用方法：@include flex-block(\\$con),能够快速实现想要的比例 `","categories":[{"name":"css","slug":"css","permalink":"https://gwjacqueline.github.io/categories/css/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://gwjacqueline.github.io/tags/移动端/"},{"name":"兼容性","slug":"兼容性","permalink":"https://gwjacqueline.github.io/tags/兼容性/"}]}]}