{"meta":{"title":"guowj","subtitle":"The fear of Jehovah is the beginning of wisdom, And the knowledge of the Holy One is understanding.","description":"个人技术博客","author":"guowj","url":"https://gwjacqueline.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-04-04T12:54:25.000Z","updated":"2019-04-04T12:54:25.000Z","comments":true,"path":"categories/index.html","permalink":"https://gwjacqueline.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-04T12:52:08.000Z","updated":"2019-04-04T12:52:08.000Z","comments":true,"path":"tags/index.html","permalink":"https://gwjacqueline.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js运行机制","slug":"js运行机制","date":"2019-07-07T02:18:03.000Z","updated":"2019-07-11T06:23:54.550Z","comments":true,"path":"js运行机制/","link":"","permalink":"https://gwjacqueline.github.io/js运行机制/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文主要是记录下自己对js运行机制的理解。js是一门单线程语言。也就是说，同一时间只能做一件事。JS的主要用途是与用户互动以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。假定js同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，那么浏览器应该以哪个线程为准呢？所以为了避免复杂性，提高效率，就决定了js是一门单线程语言，这已经成了这门语言的核心特征。Event Loop是 javascript 的执行机制。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文主要是记录下自己对js运行机制的理解。js是一门单线程语言。也就是说，同一时间只能做一件事。JS的主要用途是与用户互动以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。假定js同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，那么浏览器应该以哪个线程为准呢？所以为了避免复杂性，提高效率，就决定了js是一门单线程语言，这已经成了这门语言的核心特征。Event Loop是 javascript 的执行机制。 js 是如何处理任务&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;js中所有任务可以分成两种，一种是同步任务，一种是异步任务。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说, js的处理任务机制如下： （1）同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入 Event Table 并注册函数。 （2）当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。 （3）主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。 （4）上述过程会不断重复，也就是常说的 Event Loop(事件循环)。 下面我们来看一段代码帮助我们更好的理解： 123456console.log(1);setTimeout(function() &#123; console.log(\"我是定时器\");&#125;, 0);console.log(2);//输出结果：1,2,我是定时器 (1) 进入主线程，遇到console.log,输出 1 (2) 遇到setTimeout,其回调函数被分发到 Event Queue 中。 (3) 遇到console.log(2)，输出 2。 (4) 主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行 微任务(Microtask)与宏任务(Macrotask)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;异步任务分为宏任务和微任务，宏任务队列可以有多个，微任务队列只有一个。 宏任务包括：script(全局任务), setTimeout, setInterval, setImmediate, I/O, UI rendering。 微任务包括: new Promise().then(回调), process.nextTick, Object.observe(已废弃), MutationObserver(html5 新特性) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当某个宏任务队列的中的任务全部执行完以后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，就查看是否有其他宏任务队列。 接下来我们来看个复杂的例子来彻底理解下 js 的运行机制 12345678910111213141516171819202122232425262728293031323334353637console.log(\"1\");setTimeout(function() &#123; console.log(\"2\"); process.nextTick(function() &#123; console.log(\"3\"); &#125;); new Promise(function(resolve) &#123; console.log(\"4\"); resolve(); &#125;).then(function() &#123; console.log(\"5\"); &#125;);&#125;);process.nextTick(function() &#123; console.log(\"6\");&#125;);new Promise(function(resolve) &#123; console.log(\"7\"); resolve();&#125;).then(function() &#123; console.log(\"8\");&#125;);setTimeout(function() &#123; console.log(\"9\"); process.nextTick(function() &#123; console.log(\"10\"); &#125;); new Promise(function(resolve) &#123; console.log(\"11\"); resolve(); &#125;).then(function() &#123; console.log(\"12\"); &#125;);&#125;);//完整的输出为1，7，6，8，2，4，3，5，9，11，10，12 第一轮事件循环流程分析如下： (1) 整体 script 作为第一个宏任务进入主线程，遇到 console.log，输出 1。 (2) 遇到 setTimeout，其回调函数被分发到宏任务 Event Queue 中。我们暂且记为 setTimeout1。 (3) 遇到 process.nextTick()，其回调函数被分发到微任务 Event Queue 中。我们记为 process1。 (4) 遇到 Promise，new Promise 直接执行，输出 7。then 被分发到微任务 Event Queue 中。我们记为 then1。 (5) 又遇到了 setTimeout，其回调函数被分发到宏任务 Event Queue 中，我们记为 setTimeout2。 (6) 第一轮事件循环宏任务结束时各 Event Queue 的情况，此时已经输出了 1 和 7 (7) 我们发现了 process1 和 then1 两个微任务执行 process1,输出 6。 (8) 执行 then1，输出 8 第二轮事件循环流程分析如下： (1)从 setTimeout1 宏任务开始。首先输出 2。 (2) 接下来遇到了 process.nextTick()，同样将其分发到微任务 Event Queue 中，记为 process2。 (3) new Promise 立即执行输出 4，then 也分发到微任务 Event Queue 中，记为 then2。 (4) 第二轮事件循环宏任务结束，我们发现有 process2 和 then2 两个微任务可以执行。 (5) 输出 3。 (6) 输出 5 第三轮事件循环流程分析如下： (1)第三轮事件循环开始，此时只剩 setTimeout2 了，直接输出 9。 (2) 将 process.nextTick()分发到微任务 Event Queue 中。记为 process3。 (3) 直接执行 new Promise，输出 11。 (4) 将 then 分发到微任务 Event Queue 中，记为 then3。 (5) 第三轮事件循环宏任务执行结束，执行两个微任务 process3 和 then3。 (6) 输出 10 (7) 输出 12","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"js运行机制","slug":"js运行机制","permalink":"https://gwjacqueline.github.io/tags/js运行机制/"}]},{"title":"浏览器的重排和重绘","slug":"浏览器的重排与重绘","date":"2019-06-30T06:48:56.000Z","updated":"2019-07-11T08:50:02.587Z","comments":true,"path":"浏览器的重排与重绘/","link":"","permalink":"https://gwjacqueline.github.io/浏览器的重排与重绘/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网页响应的非常缓慢时，就会带来很糟糕的用户体验。本文将记录下如何通过减少浏览器的重排和重绘来提高网页性能。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网页响应的非常缓慢时，就会带来很糟糕的用户体验。本文将记录下如何通过减少浏览器的重排和重绘来提高网页性能。 浏览器的渲染过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想要提高网页性能前，需要先知道网页是如何生成的。网页的生成过程，大致可以分成以下五步。 (1) HTML 代码转化成 DOM (2) CSS 代码转化成 CSSOM (3)DOM 和 CSSOM 合并就产生了 Render Tree (4)有了 RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上 注意： 这五步里面，第一步到第三步都非常快，耗时的是第四步和第五步。 由于浏览器使用流式布局，对 Render Tree 的计算通常只需要遍历一次就可以完成，但 table 及其内部元素除外，他们可能需要多次计算，通常要花 3 倍于同等元素的时间，这也是为什么要避免使用 table 布局的原因之一。 重排和重绘&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。以下三种情况，会导致网页重新渲染。 (1) 修改 DOM (2) 修改样式表 (3) 用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等） 重新渲染，就需要重新生成布局和重新绘制。前者叫做”重排”（reflow），后者叫做”重绘”（repaint）。 需要注意的是，”重绘”不一定需要”重排”，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。但是，”重排”必然导致”重绘”，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。 总结：重排必将引起重绘，重绘不一定会引起重排 重排 (Reflow)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为重排。 会导致重排的操作： 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或者删除可见的 DOM 元素 激活 CSS 伪类（例如：:hover） 查询某些属性或调用某些方法 会导致重排的方法： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft scrollIntoView()、scrollIntoViewIfNeeded() getComputedStyle() getBoundingClientRect() scrollTo() 重绘(Repaint)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility 等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 减少回流和重绘CSS 避免使用 table 布局。 尽可能在 DOM 树的最末端改变 class。 避免设置多层内联样式。 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上。 避免使用 CSS 表达式（例如：calc()）。 JS DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作 避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。 避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。 也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘 position 属性为 absolute 或 fixed 的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。","categories":[{"name":"网页性能管理","slug":"网页性能管理","permalink":"https://gwjacqueline.github.io/categories/网页性能管理/"}],"tags":[{"name":"提高网页性能","slug":"提高网页性能","permalink":"https://gwjacqueline.github.io/tags/提高网页性能/"},{"name":"浏览器","slug":"浏览器","permalink":"https://gwjacqueline.github.io/tags/浏览器/"},{"name":"回流","slug":"回流","permalink":"https://gwjacqueline.github.io/tags/回流/"},{"name":"重绘","slug":"重绘","permalink":"https://gwjacqueline.github.io/tags/重绘/"}]},{"title":"竞品分析","slug":"竞品分析","date":"2019-06-23T02:34:59.000Z","updated":"2019-06-23T12:28:48.000Z","comments":true,"path":"竞品分析/","link":"","permalink":"https://gwjacqueline.github.io/竞品分析/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;竞品分析是对所研发同类型的产品进行分析讨论，并给出类比归纳的分析结果，用以了解现有产品的相关信息以及它与竞争对手之间的差异，从而借鉴于产品研发中。最竞品分析我认为最重要的两点是：1.知己知彼，百战不殆。2.从竞争对手那里学到好的东西，比如手段和策略，并把这些好的东西转化为自己的优势。接下来，为了给自己加深记忆，我将记录下如何做一个竞品分析。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;竞品分析是对所研发同类型的产品进行分析讨论，并给出类比归纳的分析结果，用以了解现有产品的相关信息以及它与竞争对手之间的差异，从而借鉴于产品研发中。最竞品分析我认为最重要的两点是：1.知己知彼，百战不殆。2.从竞争对手那里学到好的东西，比如手段和策略，并把这些好的东西转化为自己的优势。接下来，为了给自己加深记忆，我将记录下如何做一个竞品分析。 竞品分析步骤了解自己&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们应该对自己所做的产品有详细的了解。我们需要分析自己产品业务类型的市场行情、明确产品定位和用户需求。对自己有认识后才能找到相近的竞品，调研的准确性会大大提升。 分析自己产品业务类型的市场行情&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们需要了解自己产品业务在当前市场上是怎么样的，是处于红海市场的风口浪尖？亦或是在蓝海市场中夹缝求生？明确自己的业务市场，会对我们后续的判断及决策起很大的作用。比如一些风口行业的产品行事会大胆求突破，而稳健型产品则会对用户体验的细节追求完美。 明确产品定位与用户需求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们要知道我们的产品是干什么的、对应的目标人群是什么、他们需要用我们产品的哪些功能以及我们的产品解决了哪些客户的痛点。 选择竞品选择渠道1.搜索：百度、知乎、易观智库、微博，各大 PM 社区等。如果有 APP，上苹果和各大安卓的应用商店搜索关键词。 2.善问：问朋友，问同事，问领域的专业人士找出合适的竞品 竞品分类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;竞品应分为三类：直接竞品、潜在竞品和转移性竞品。 直接竞品&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一类竞品就是与我们产品目标用户相同，内容相似构成直接竞品的产品。比如招商银行 APP 和平安银行 APP。 潜在竞品&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与我们产品目标用户相似，暂时没有我们产品的功能模块，但是通过后期升级，可以加上此类模块的产品。比如微信是做熟人社交的，默默是做陌生人社交的，虽然产品目标不同，但是后期微信加了摇一摇功能，就是潜在竞品像直接竞品的一个转化 转移性竞品&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目标人群有一定共性，但产品目标不同，但在特定场景下对用户使用时间形成竞争的产品。比如我们做的是运动 app,但是想边运动边听歌，那么有关听歌的产品就会成为我们的转移性竞品。可以再产品后续扩展功能点的时候进行。 竞品分析背景分析 基本信息：包含时间，手机环境，APP 名称，版本号信息 产品的概括或简介说明(比如唯品会：是一家专门做特卖的网站) 产品定位 用户需求分析 市场状况现状分析 运营方法与重大事记 竞品分析与产品分析流程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从体验者来说，是从具体往抽象去分析的。但是做产品的时候，是从抽象到具象的。 表现层 ———— 你看到的是什么&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表现层是 UI 界面，视觉直观可见。就比如我们在玩微信的时候，一开始看的肯定就是视觉层，好不好看。 框架层 ———— 这些区域和位置如何来决定表现层&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;框架层一般分为深度优先和广度优先。深度优先常用在移动端，比如天猫下面有男装，女装，童装等。广度优先常用在网页，因为屏幕足够大，所以一层就能说完。 结构层 ———— 每种列别应该出现在哪里&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结构层指的是产品的结构，是你对着产品，从产品功能上看，就能用脑图把主干分支梳理出脉络。 范围层 ———— 按照功能与特性，表现的是否合适，如何决定结构层&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;范围层指这个产品的思路是从满足用户需求的角度理解的，满足了哪些需求，通过什么样的产品设计、策略、流程满足的，简单来说就是功能。 战略层 ———— 需要什么样的功能与特性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后就是战略层，比如目标用户是什么，产品定位是什么。战略层是产品最深层的思考，产品的市场容量、目标用户、解决的核心需求、产品定位、商业化、产品循环等。 注意：这里不要把结构层和范围层混淆了，要注意结构层就是层级信息脉络，而范围层就是功能 竞品分析结论 制作简单的分析报告，说出自己的产品与横向竞品有哪些区别，比如为什么人家有的我也有，为什么人家有的我没有，为什么人家没有的我要有 我有哪些人家没有的附加功能，这些功能为哪些用户群体服务，为什么用户会选择我们，概况如下： 1.产品的概况或简介说明 2.产品的核心功能总结 3.产品的主要功能简介 4.产品的功能与界面优缺点","categories":[{"name":"产品","slug":"产品","permalink":"https://gwjacqueline.github.io/categories/产品/"}],"tags":[{"name":"产品","slug":"产品","permalink":"https://gwjacqueline.github.io/tags/产品/"},{"name":"竞品分析","slug":"竞品分析","permalink":"https://gwjacqueline.github.io/tags/竞品分析/"}]},{"title":"交互设计七大定律下","slug":"交互设计七大定律下","date":"2019-06-22T07:17:48.000Z","updated":"2019-06-23T12:28:58.000Z","comments":true,"path":"交互设计七大定律下/","link":"","permalink":"https://gwjacqueline.github.io/交互设计七大定律下/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇主要是继交互设计七大定律上的后续。这篇将详细记录下接近法则、防错原则、复杂性守恒定律和奥卡姆剃刀原理。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇主要是继交互设计七大定律上的后续。这篇将详细记录下接近法则、防错原则、复杂性守恒定律和奥卡姆剃刀原理。 接近法则&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据格式塔（Gestalt）心理学：当对象离得太近的时候，意识会认为它们是相关的。在交互设计中表现为一个提交按钮会紧挨着一个文本框，因此当相互靠近的功能块是不相关的话，就说明交互设计可能是有问题的。 接近法则在交互上的启示将相似的、有关联的信息尽量摆在一起。不要让用户迷茫，要他在潜意识里就知道在哪里能找到自己想要的信息。 接近法则的实际应用将相似的、有关联的信息尽量摆在一起 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如登录界面的输入框与按钮。我们在使用任何一款 APP 产品的时候都会遇到登录或者注册页面，而且输入内容部分下面一定会有个按钮，原因就在于输入内容和按钮本身存在联系。因为输入内容之后，需要通过点击按钮来提交输入的内容，通常输入框附近一定会有提交按钮。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如今日头条及爱奇艺视频信息布局。在今日头条和爱奇艺视频的的信息条目中，我们一眼都能发现，标题和图片是表示的同一类的信息，因为它们是放在一起，具有相关性。 防错原则&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;防错原则认为大部分的意外都是由设计的疏忽，而不是人为操作疏忽。通过改变设计可以把过失降到最低。 防错原则在交互上的启示在设计中建立必要的防错机制 防错原则的实际应用在设计中建立必要的防错机制 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如知乎安卓版本的登录操作。当用户在知乎中登录时，在没有填写完手机号码和密码前，底部的登录按钮是置灰不可点击的。只有两项都填写完整底部的登录按钮才会变为可点击状态，也就是蓝色的。这就是为了防止用户犯更多错误，也是防错原则的一种体现。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此，特别要注意在用户操作具有毁灭性效果的功能时要有提示，防止用户犯不可挽回的错误。比如安卓版微信发朋友圈动态时，点击返回按钮出现的提示弹窗。弹出框方式会增加不可逆操作的难度，当用户发一条动态一半的时候，因为误操作或者其它退出当前状态的时候，使用弹窗是个不错的选择。因为用户这个操作会让之前辛苦编辑的内容删除找不回，想要再发只能从头开始，对用户造成损失比较大。这就是防错原则的另外一种体现， 复杂度守恒定律 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指的是每一个过程都有其一定的的复杂性，存在一个临界点，超过了这个点过程就不能再简化了，你只能将固有的复杂性从一个地方移动到另外一个地方。就比如说我们做转账原型的时候，转账人的姓名。卡号，银行是不可以再简化的。所以我们通过智能联想，和银行自动判定去转化他的复杂性。 复杂度守恒定律在交互上的启示无论在产品开发环节还是在用户与产品的交互环节，这一固有的复杂度都无法依照我们的意愿去除，只能设法转移它的复杂性 复杂度守恒定律的实际应用通过技术手段转移它的复杂性 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如手机设计演变我们先来看下左一的经典诺基亚手机。在诺基亚手机称霸的那个年代，基本上所有的手机样式都是一块显示屏幕加上底部的操作按键。屏幕负责显示内容，而底部的按键来实现各种操作，比如，打电话、发短信、上网、聊 QQ、等等。我们能清楚的看到它的布局还是蛮复杂的，尤其是密密麻麻的物理按键，屏幕也相对较小，阅读体验现在看来还是蛮差的。自从苹果发布苹果了全面屏智能手机之后，彻底改变了手机的设计风格和操作体验，也就是我们现在看到的安卓和苹果的智能手机样式，更大的屏幕、更简单的操作，想打开哪个 APP 就直接点击就好了。从手机的演变过程来看，智能手机简化了物理操作按键，它是通过技术手段降低了手机操作的复杂度，尤其是复杂的交互手势操作，复杂度的降低是通过大量的技术和资金投入解决，这就体现了复杂守恒定律。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如今日头条的个性化信息推荐。今日头条的首页推荐内容，都是根据个人的浏览爱好或者倾向进行信息的推荐的，除了首页置顶内容外，其它内容的推荐每个人都是不一样的。我和一个同事可能微信是好友，所以还有一点类似。对于用户来讲，这样的私人定制信息体验很好，浏览的信息都是相关或者叫做用户自己喜欢的内容。对于用户来讲这是一件好事情，但是，对于产品的开发和设计者来说，这是一个很难的事情，因为实现这样的效果或者体验，需要很强的技术能力和大量服务器的支持，这种做法就是通过技术手段，将用户复杂度降低，转移到了开发者本身，使得用户的阅读体验在同类产品中做到独树一帜。 奥卡姆剃刀原理 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该原理的含义指的是不必要的元素会降低设计的效率，而且增加没有想到的后果的发生概率。无法让用户捕捉到重要元素。这个原理就被称为“如无必要，勿增实体”，即如有两个功能相等的设计，那么选择最简单的。除非是用户真的需要，否则不要添加功能和交互。 奥卡姆剃刀原理在交互上的启示1.只放置必要的东西 2.减少点击次数 3.减少段落的次数 4.「外婆」规则 奥卡姆剃刀原理的实际应用只放置必要的东西 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如百度搜索首页界面。说到要快速搜索某项东西，我们一般都会想起百度搜索，不仅是因为搜索内容准确快，也因为搜索页面简洁，页面上搜索框是最显眼的，能让用户专注搜索。其他相关信息被放置在不起眼的右上角，也有更多产品的按钮，给用户提供入口。 减少点击次数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如兴业银行充值与支付宝充值流程。如上图所示，兴业银行充值界面要完成整个的话费充值流程，需要点击动作 8 次，而支付宝的充值界面完成整个话费充值流程只需要点击一次，页面流程更短，效率更高。因此，我们可以看出减少用户的点击次数，能提升产品的用户体验。 减少段落的次数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如雅虎搜索首页界面。雅虎跟谷歌和百度一样，都是做搜索引擎的，而且是做的最早的一家，可是现在却没有谷歌和百度使用的人多，有部分原因在于首页设计的失误上。大家都知道谷歌和百度首页最显眼的就是搜索框，没有太多的干扰信息，而我们看看图中的雅虎首页，最大片的内容区域给了各种新闻和广告，最重要的搜索框在顶部所占的位置却很小，用户本来是搜索内容的，进入首页却看到大段的无关信息，分散了大多数用户只想搜索这个需求的注意力。 「外婆」规则 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就比如微信的界面设计。之前看到新闻说，微信也越来越关注如何服务好老年用户，比如开通语音和视频聊天功能，提升通话稳定性和质量等。微信算是大多数老年人使用最多的一款 APP。之前有人统计过，在发红包上，老年用户的活跃度甚至超过了 95 后，月均发送 25 次红包。从以上数据来看，微信是符合外婆规则的。","categories":[{"name":"产品","slug":"产品","permalink":"https://gwjacqueline.github.io/categories/产品/"}],"tags":[{"name":"产品","slug":"产品","permalink":"https://gwjacqueline.github.io/tags/产品/"},{"name":"交互设计","slug":"交互设计","permalink":"https://gwjacqueline.github.io/tags/交互设计/"}]},{"title":"交互设计七大定律上","slug":"交互设计七大定律上","date":"2019-06-22T05:48:40.000Z","updated":"2019-06-23T12:28:54.000Z","comments":true,"path":"交互设计七大定律上/","link":"","permalink":"https://gwjacqueline.github.io/交互设计七大定律上/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“除非有更好的选择，否则就遵从标准”，这是交互设计之父阿兰·库珀说过的。在交互设计领域，有些法则是从用户的行为逻辑中总结出来的，掌握这些法则能让我们高效的完成自己的设计。因为讲的比较仔细，所以会分为上下两篇展开记录。本篇主要记录下菲茨定律、席克定律和神奇数字 7±2 法则。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“除非有更好的选择，否则就遵从标准”，这是交互设计之父阿兰·库珀说过的。在交互设计领域，有些法则是从用户的行为逻辑中总结出来的，掌握这些法则能让我们高效的完成自己的设计。因为讲的比较仔细，所以会分为上下两篇展开记录。本篇主要记录下菲茨定律、席克定律和神奇数字 7±2 法则。 菲茨定律&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从起始位置到最终目标的距离由到目标的距离和目标的大小决定。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;菲茨定律是指从起始位置到最终目标所需要的时间是由到目标的距离（也就是图片中的 d)和目标的大小（S）决定的。所以我们得出两个结论： 目标越小，就越难点中，目标越大，完成点击的速度越快。 目标离的越远，到达就越费劲。目标越近，完成点击的时间越短 菲茨定律在交互上的启示1.按钮等可点击区域在合理的范围之内越大越容易点击，反之，可点击区域越小，越不容易操作 2.出现在用户正在操作的对象旁边的菜单，也就是我们常见的右键菜单比下拉菜单或工具栏可以被打开的更快，因为不需要移动到屏幕的其他位置 3.因为边角是巨大的目标，它们无限高或无限宽，但是你不可能用鼠标超过它们。即不管你移动了多远，鼠标最终会停在屏幕的边缘，并定位到按钮或菜单的上面 菲茨定律的实际应用按钮等可点击区域在合理的范围之内越大越容易点击 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如淘宝和中国银行的手机网页端的登录页面。左边淘宝登录界面的信息输入区域很明显比右边中国银行登录界面信息输入区域相互之间的距离和输入面积更大一点，在视觉及输入体验上面，淘宝也要比中国银行的好很多。再看两个页面的登录按钮，右边中国银行界面的按钮视觉上很小，而且距离上方验证码输入框的距离很近，这样的按钮不仅不好点击还容易产生误操作。相对而言，左图淘宝页面的按钮间距和大小就很合适了，输入和点击体验比右图好很多。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再看一下小黄车和 hello 单车首页扫码按钮。放在同样的位置，单看按钮大小，小黄车的明显要比小蓝单车的大很多在使用过程中，个人觉得小黄车的操作按钮比 hello 单车的要舒服很多。不需要太聚焦就可以很轻松的点到。 出现在用户正在操作对象旁边的控制菜单（右键菜单）可以被更快的打开 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个分别是安卓及 iOS 长按应用图标出现的快捷操作菜单栏，使用其中的功能不需要再反复打开 app,只需要长按就可以快捷打开，这样极大的提升了使用 APP 主要功能的效率。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个是在 PC 端的应用。我们在 Mac 系统或者 Windows 系统桌面上对于文件夹的操作，通常是通过鼠标右键点击方式，在出现的操作菜单中对其进行相应的操作，非常方便。 屏幕的边和角很适合放置像菜单栏和按钮这样的元素 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个启示在 PC 端的应用是最经典的。Windows 桌面的默认导航栏是在固定底部的，而 Mac 导航的位置则是在顶部和底部都有。都是固定在屏幕的边缘。就算我们去设计导航栏的位置时，都是停留在屏幕边缘四周，不会出现在屏幕中央的位置。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是 BAT 的 APP 首页，最重要导航栏都是放在页面底部的。包括所有做的好的 APP 都是在底部的。这不是恰巧，而是有理据的在移动的设备上，手指就是我们的鼠标。和菲茨定律有所不同，它运用到的是拇指可达性法则。 拇指可达性法则 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大多数用户都用一只手来使用手机。拇指就像用户的鼠标，但有局限性。屏幕上有些地方是拇指无法触及的，这些区域的面积将由用户的手指长度和手机屏幕的大小来决定。屏幕的顶部是拇指最难触达的区域。苹果在设计的时候就很注意这些交互的细节。所以说我们把菜单放在顶部会让用户更难浏览你的界面，但用户使用菜单的频率非常高。我们有必要把优先级最高的菜单放在拇指触手可及的地方，这样用户就能更快地完成他们的任务。而且如果把菜单放在最上面会迫使用户调整手机位置，或者用另一只手进行导航。这都需要进行额外的物理操作，并减慢任务时间。很多共享单车最重要的功能就是扫码骑车。我们可以发现对于他们来说这个最重要的按钮全部都放置在舒适区中，这个是很有道理的。 席克定律 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图所示，x 轴代表选择的数量，y 轴代表做出反应所需要的时间。席克定律指的就是：一个人面临的选择越多，需要作出决定的时间就越长。 席克定律在交互上的启示设计中给用户尽量少的选择，减轻用户的决策成本 席克定律的实际应用设计中给用户尽量少的选择 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在使用网站或者移动端产品时，经常会遇到很多操作弹窗。就像图中的两个例子，基本上弹窗的操作选项只会有两个，二选一的成本，对于用户来讲很简单方便，选择成本最小 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户初次下载使用钉钉或者微信 APP 的时候，在进入正常的使用之前，用户会看到这个页面。我们看下面两个截图，页面上的操作按钮只有两个，一个登录按钮和一个注册按钮，这样的话，用户就很清晰接下来自己要干什么了 神奇的 7±2 法则&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;956 年乔治米勒对短时记忆能力进行了定量研究，他发现人类头脑最好的状态能记忆含有 7（±2）项信息块，在记忆了 5-9 项信息后人类的头脑就开始出错。与席克定律类似，神奇数字 7±2 法则也经常被应用在移动应用交互设计上，应用的选项卡不会超过 5 个. 神奇的 7±2 法则在交互上的启示1.PC 端导航或选项卡尽量不要超过 9 个，APP 应用的选项卡尽量不要超过 5 个 2.如果导航或选项卡内容很多，可以用一个层级结构来展示各段及其子段 3.把大块整段的信息分割成各个小段，并显著标记每个信息段的主体 神奇的 7±2 法则的实际应用PC 端导航或选项卡尽量不要超过 9 个，APP 应用的选项卡尽量不要超过 5 个 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如苹果、人人都是产品经理及 UI 中国官网导航栏,我们看到这三个主流网站的导航栏模块都没有超过 9 个，这样做的好处在于让用户对于网站的内容一目了然，更加快捷。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说完 PC 的，我们说下移动端的，在使用 APP 的时候，我们都会用到软件的底部导航区域。会发现任何软件的底部导航都不会超过 5 个，就像图中的百度，微信及 QQ 界面一样，底部导航也没有超过五个的。这个就运用到了神奇的 7±2 法则。就比如我们要去微信看朋友圈。我们大脑下意识就会去点击 我里面的朋友圈。不会再一个个的去看完选项卡的内容。因为我们大脑已经大致记住了各个导航的位置。如果导航栏实在多的情况下呢，我们来看看解决方法。 如果导航或选项卡内容很多，可以用一个层级结构来展示各段及其子段 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如天猫商城和亚马逊网站的商品分类选项卡,他们的导航是分为多个层级的。如果以后遇到导航的内容非常多的话，我们就可以将它整合归类来分层级收纳。就像天猫和亚马逊官网对于商品分类的处理方式一样，使用爷爷爸爸孩子的层级递进方式来归类展示商品。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再来看下京东及朴朴 APP 的商品分类模块界面，两个产品的商品分类布局形式很相似，都是用了选项卡的方式来分类商品，他们层级明确，用户如果想买哈密瓜就是水果里面找，这样就相应的提升了用户找寻商品的效率。 把大块整段的信息分割成各个小段，并显著标记每个信息段的主体 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如苹果官网 iPhone X 对于语言版本的介绍板块。如图所示，语言版本介绍模块把一整段语言，分成四个模块的信息来介绍，而且每个模块都要自己的标题，再加上段落之间的空间留白，使得此段信息看起来清晰明了。用户可以一目了然的了解每段的主题 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如支付宝和微信银行卡界面卡号信息的展示方式。无论是支付宝还是微信甚至是大多数银行，卡号信息都采用了分段的方式，让我们便于记忆。来介绍，而且每个模块都要自己的标题，再加上段落之间的空间留白，使得此段信息看起来清晰明了。用户可以一目了然的了解每段的主题","categories":[{"name":"产品","slug":"产品","permalink":"https://gwjacqueline.github.io/categories/产品/"}],"tags":[{"name":"产品","slug":"产品","permalink":"https://gwjacqueline.github.io/tags/产品/"},{"name":"交互设计","slug":"交互设计","permalink":"https://gwjacqueline.github.io/tags/交互设计/"}]},{"title":"kano模型","slug":"kano模型","date":"2019-06-16T03:38:45.000Z","updated":"2019-06-20T03:37:06.000Z","comments":true,"path":"kano模型/","link":"","permalink":"https://gwjacqueline.github.io/kano模型/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kano模型分析法是授野纪昭以客户满意度为模型设计了一种新的方法论。凭我们主观的去判断用户的需求是不太准确的。kano模型主要是分析用户对于某项事物到底满不满意，然后将数据汇总起来，用一个客观的数据去分析用户到底是喜欢的还是不喜欢的。它可以用数据去捕获用户真正的需求，帮助产品更好地迭代升级。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kano模型分析法是授野纪昭以客户满意度为模型设计了一种新的方法论。凭我们主观的去判断用户的需求是不太准确的。kano模型主要是分析用户对于某项事物到底满不满意，然后将数据汇总起来，用一个客观的数据去分析用户到底是喜欢的还是不喜欢的。它可以用数据去捕获用户真正的需求，帮助产品更好地迭代升级。 kano 模型的由来&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kano模型是受到双因素理论的启发。双因素理论认为引起人们工作动机的因素主要有两个：一个是保健因素，二是激励因素，只有激励因素才能够给人们带来满意感，而保健因素只能消除人们的不满，但不会到来满意感。简单来说，在传统的观念里，只有满意和不满意。但在双因素理论中，激励因素代表的是满意和没有满意，而保健因素代表的是没有不满意和不满意 kano 模型 Kano（卡诺）模型展示了不同类型的需求对用户满意度的影响,分为五类影响因素。 魅力因素(Attractive Quality Element)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此需求具备时，用户满意度会有很大提升，但如果不提供此需求，用户满意度也不会降低。 例子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;海底捞等位做美甲 期望因素(One-dimensional quality Element),又称一维因素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当提供此需求，用户满意度会提升，当不提供此需求，用户满意度会降低 例子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;火锅店的牛肉越便宜越爽，上网速度越快越爽 必备因素(Must-be quality Element)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当优化此需求，用户满意度不会提升，当不提供此需求，用户满意度会大幅降低； 例子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;手机一定能打电话，火锅店一定要有牛肉 无差异因素(Indifferent quality Element)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;论提供或不提供此需求，用户满意度都不会有改变，用户根本不在意 例子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;火锅店下水管质量非常好 反向因素(Reverse quality Element)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此需求具备时，会导致客户不满意，反之，不具备时，顾客反而会感到满意 例子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 游戏技能越改越差 从 KANO 模型的因素分类可以发现，KANO 并不是直接用来测量用户满意度的方法，而是通过对用户的不同需求进行区分处理，帮助产品找出提高用户满意度的切入点。它常用于对影响指标进行分类，帮助产品了解不同层次的用户需求，识别使用户满意的至关重要的因素。从以上五个要素得知，我们做产品设计时，需要尽量避免无差异属性、反向属性，至少做好必要属性、一维属性，努力做魅力属性。 注意：对于客户来说，产品的质量特性是动态的，上诉这五种要素会互相转换。 根据 KANO 模型进行用户需求分类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 根据kano模型，可以将五类影响因素与用户需求的优先级对于，便于实际的应用。主要分为：基本型需求(必备因素)、期望型需求(期望因素)、兴奋型需求(魅力因素)。 从上图可以看出处于金字塔底端的为用户基本型需求，也是核心需求，是产品必须做的功能。这里我们可以总结下kano模型 5 个需求的排序为： 1必备&gt;期望&gt;魅力&gt;无差异&gt;反向 kano 模型的应用问卷调查&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Kano（卡诺）模型的使用，我们一般会采用问卷的方式，让被调查者将各个需求按照 Kano 分析的质量分类表，选择相应需求的分类。 例如：如某一功能，一个调查者认为，有该功能我很喜欢，没有该功能，我很讨厌。那么根据 Kano 分析的质量分类表，这个功能的因素是 O。这说明，这个功能对于当前的这个调查者是期望需求 数据收集及系统分析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一次调查结束时，我们可能看得到某个功能，有 2 个 A，5 个 O，279 个 M，10 个 I，4 个 R，0 个 Q。首页，我们可以将反向因素（R）和可疑因素（Q）较多的需求排除。如果 M 和 O 的系数相近时，我们就不太好直接说这个功能是“期望”还是“必备”的。这个时候，我们就要进行系数分析了 系数分析&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通过 Better-Worse 系数来构建要素系数的象限，把落到相应象限的需求，划分到相应的需求分类中去。然后根据需求的不同，就可以进行需求的排序了。4 个需求的排序为：必备&gt;期望&gt;魅力&gt;无差异。 Better-Worse 系数计算12Better=(A+O)/(A+O+M+I);Worse=(O+M)/(A+O+M+I)； 得出的系数，需求归类如下: 第一象限：Better&gt;0.5，Worse&gt;0.5，属于期望需求；第二象限：Better&lt;0.5，Worse&gt;0.5，属于必备需求；第三象限：Better&lt;0.5，Worse&gt;0.5，属于无差异需求；第四象限：Better&gt;0.5，Worse&lt;0.5，属于魅力需求；","categories":[{"name":"产品","slug":"产品","permalink":"https://gwjacqueline.github.io/categories/产品/"}],"tags":[{"name":"产品","slug":"产品","permalink":"https://gwjacqueline.github.io/tags/产品/"},{"name":"kano","slug":"kano","permalink":"https://gwjacqueline.github.io/tags/kano/"},{"name":"工具","slug":"工具","permalink":"https://gwjacqueline.github.io/tags/工具/"}]},{"title":"vue 实现原理(二)","slug":"vue-实现原理(二)","date":"2019-06-15T11:08:54.000Z","updated":"2019-06-20T03:36:50.000Z","comments":true,"path":"vue-实现原理(二)/","link":"","permalink":"https://gwjacqueline.github.io/vue-实现原理(二)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇是继上篇vue 实现原理(一)&gt;)的续写。将继续实现下vue中的双向绑定和 computed。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇是继上篇vue 实现原理(一)&gt;)的续写。将继续实现下vue中的双向绑定和 computed。 双向绑定&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把 Model 绑定到 View 的同时也将 View 绑定到了 Model 上，这样就既可以通过更新 Model 来实现 View 的自动更新，也可以通过更新 View 来实现 Model 数据的更新。我的实现思路大致是这样的：首先获取节点元素上的所有属性并且用数组存储起来，循环遍历取出 v-model 和对应的 value 值，然后把对应的值赋给输入框。接下来就需要订阅一下，每次修改，就把对应的值赋进去。当输入框输入时，也要有值映射到属性上，从而会触发 set 的 notify 方法，则会更新 watcher，将值渲染到输入框里。 template 12345678&lt;div id=\"vue-app\"&gt; &lt;div class=\"btnGroup\"&gt; &lt;div&gt;&#123;&#123; mvvm &#125;&#125;&lt;/div&gt; &lt;!-- &lt;div&gt;&#123;&#123; a &#125;&#125;&lt;/div&gt; --&gt; &lt;div&gt;&#123;&#123; a.a &#125;&#125;&lt;/div&gt; &lt;input v-model=\"mvvm\" /&gt; &lt;/div&gt;&lt;/div&gt; js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function replace(fragment) &#123; Array.from(fragment.childNodes).forEach(node =&gt; &#123; let text = node.textContent; let reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; if (node.nodeType === 3 &amp;&amp; reg.test(text)) &#123; console.log(RegExp.$1); //mvvm,a ,a.a let arr = RegExp.$1.split('.'); let val = vm; arr.forEach(key =&gt; &#123; key = key.trim(); val = val[key]; console.log(val); &#125;); new Watcher(vm, RegExp.$1, function (newVal) &#123; node.textContent = text.replace(/\\&#123;\\&#123;(.*)\\&#125;\\&#125;/, newVal); &#125;); node.textContent = text.replace(/\\&#123;\\&#123;(.*)\\&#125;\\&#125;/, val); &#125; &lt;!-- 双向绑定 --&gt; // 判断元素是否为元素 if (node.nodeType === 1) &#123; // 获取当前dom节点上的属性 let nodeAttrs = node.attributes; // console.log(nodeAttrs); // 将类数组转化为数组进行循环遍历 Array.from(nodeAttrs).forEach(attr =&gt; &#123; let name = attr.name; let exp = attr.value; if (name.indexOf(\"v-\") == 0) &#123; // 默认v-就为v-model //把对应的值赋给输入框 node.value = vm[exp]; &#125; // 需要订阅一下，每次修改，就把对应的值赋给输入框 new Watcher(vm, exp, function (newVal) &#123; //当Watcher触发时，把最新的值赋给输入框 node.value = newVal; &#125;); //当输入框输入时，要有值映射到属性上 node.addEventListener('input', function (e) &#123; let newVal = e.target.value; //值改变，则会触发set方法中的notify,则会更新watcher,将值渲染到输入框里 vm[exp] = newVal; &#125;) &#125;); &#125; // 如果有子节点，需要再执行replace if (node.hasChildNodes()) &#123; replace(node); &#125; &#125;);&#125; computed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现完了 Vue 的双向绑定，我们来看看怎么实现 computed 吧。computed 是依赖其它的属性计算所得出最后的值，computed 的值再 getter 执行后是会有缓存的，只有在它依赖的属性值改变之后，下一次获取 computed 的值时才会重新调用对应的 getter 来计算。如果一个数据依赖于其它数据，那么我们常用 computed 去解决，如果需要在某个数据变化时做一些事情，那么就更适合用 watch 了。接下来说说我实现 computed 的一个大致思路吧。首先，我们需要把当前 computed 对象上的属性一一挂载到当前实例上，然后主要使用Object.defineProperty的 getter 方法，去判断对应属性值上的是否是个函数，如果是函数，就把他放回去，因为默认就是 get 方法，如果不是的话，就去执行 get 方法。 12345678910111213141516171819202122232425262728293031323334353637function Vue(options = &#123;&#125;) &#123; this.$options = options; var data = (this._data = this.$options.data); observer(data); for (let key in data) &#123; Object.defineProperty(this, key, &#123; enumerable: true, get() &#123; return this._data[key]; &#125;, set(newVal) &#123; this._data[key] = newVal; &#125; &#125;); &#125; // 让这里的this都是当前的实例 initComputed.call(this); new Compile(options.el, this);&#125;//初始化computedfunction initComputed() &#123; //保存this let vm = this; //获取computed属性 let computed = this.$options.computed; //通过Object.keys拿到computed上的key以数组的形式输出 Object.keys(computed).forEach(key =&gt; &#123; Object.defineProperty(vm, key, &#123; // 判断computed后的是否为函数，如果为函数，就还回去，默认执行get方法，如果不是函数，就执行get方法 get: typeof computed[key] === \"function\" ? computed[key] : computed[key].get, set() &#123;&#125; &#125;); &#125;);&#125; 有关 vue 实现原理的完整代码，可以上我的 Github中查看。 总结Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用 Object.defineProperty 的 getter 和 setter 来实现。 Compile 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。 Watcher 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。 Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发 notify 函数，再调用订阅者的 update 方法。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面 Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器 Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅 Watcher 来更新视图， 此时 Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用 Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。 感谢以下文章，对我理解 vue 的基本原理有很大的帮助: Vue.js 单向绑定与双向绑定 浅谈 Vue 的单向绑定和双向绑定 Vue 原理简介 Vue.js 和 MVVM 小细节 Vue.js 中的 MVVM","categories":[{"name":"Vue","slug":"Vue","permalink":"https://gwjacqueline.github.io/categories/Vue/"}],"tags":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://gwjacqueline.github.io/tags/vue/"},{"name":"ES5","slug":"ES5","permalink":"https://gwjacqueline.github.io/tags/ES5/"},{"name":"双向绑定","slug":"双向绑定","permalink":"https://gwjacqueline.github.io/tags/双向绑定/"},{"name":"computed","slug":"computed","permalink":"https://gwjacqueline.github.io/tags/computed/"},{"name":"原理","slug":"原理","permalink":"https://gwjacqueline.github.io/tags/原理/"},{"name":"发布订阅","slug":"发布订阅","permalink":"https://gwjacqueline.github.io/tags/发布订阅/"},{"name":"数据劫持","slug":"数据劫持","permalink":"https://gwjacqueline.github.io/tags/数据劫持/"}]},{"title":"vue 实现原理(一)","slug":"vue-实现原理(一)","date":"2019-06-15T07:00:37.000Z","updated":"2019-06-20T03:36:55.000Z","comments":true,"path":"vue-实现原理(一)/","link":"","permalink":"https://gwjacqueline.github.io/vue-实现原理(一)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习vue也有一段时间了。为了给自己加深记忆,本篇文章将通过从零开始仿写一个vue.js,实现vue中的单向绑定、双向绑定和 computed。因为篇幅较长，所以本篇主要实现单向绑定，下一篇将实现双向绑定和 computed。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习vue也有一段时间了。为了给自己加深记忆,本篇文章将通过从零开始仿写一个vue.js,实现vue中的单向绑定、双向绑定和 computed。因为篇幅较长，所以本篇主要实现单向绑定，下一篇将实现双向绑定和 computed。 Vue.js 中的 MVVM &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MVVM就是一种双向数据绑定，它的特点是数据影响视图，视图影响数据。MVVM 由View、ViewModel、Model三部分组成。View层代表的是视图、模板,负责将Model(数据模型)转化为 UI 展示出来。Model层代表的是模型、数据。可以在Model层中定义数据修改和操作的业务逻辑。ViewModel 是一个同步 View 和 Model 的对象。在MVVM的架构下，View层和Model层并没有直接联系，而是通过ViewModel层进行交互。ViewModel层通过双向数据绑定将View层和Model层连接起来。使得 View 层和 Model 层的同步工作完全是自动的。因此开发者只需关注业务逻辑，无需手动操作 DOM，复杂的数据状态维护交给 MVVM 统一来管理。MVVM的特点是数据影响视图，视图影响数据。Augular是通过脏值检测去实现双向绑定，Vue靠的是数据劫持和发布订阅模式。下图是Vue.js中**MVVM**的体现我们知道Vue不兼容IE8以下的版本，因为它的核心实现靠的是一个ES5的方法:Object.defineProperty`。 Object.definePropertyObject.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象,即第一个参数 obj 1Object.defineProperty(obj, prop, descriptor) obj：必需。目标对象`prop：必需。需定义或修改的属性的名字descriptor：必需。目标属性所拥有的特性 123456Object.defineProperty(obj, \"test\", &#123; configurable: true | false, // 目标属性是否可以使用delete删除或是否可以再次修改属性的特性（writable, configurable, enumerable） enumerable: true | false, //此属性是否可以被枚举（使用for...in或Object.keys()） value: 任意类型的值, //属性对应的值,可以使任意类型的值，默认为undefined writable: true | false //属性的值是否可以被重写&#125;); 注意：一旦使用 Object.defineProperty 给对象添加属性，如果不设置属性的特性，那么 configurable、enumerable、writable 这些值默认都为 false 属性 getter/setter 方法12345678910111213141516171819var obj = &#123;&#125;;var val = 3;Object.defineProperty(obj, \"test\", &#123; get: function() &#123; //当获取值的时候触发的函数 return val; &#125;, set: function(value) &#123; //当设置值的时候触发的函数,设置的新值通过参数value拿到 val = value; &#125;&#125;);//获取值console.log(obj.test); //3//设置值obj.test = 7;console.log(obj.test); //7 注意：Object.defineProperty 使用了 getter 或 setter 方法，不允许使用 writable 和 value 这两个属性。get 或 set 不是必须成对出现，任写其一就可以。如果不设置方法，则 get 和 set 的默认值为 undefined 属性 configurable 和 writable 一起使用的情况 configurable：true writable:true configurable：true writable:false configurable：false writable:true configurable：true writable:true 修改属性的值 ✔️ ✔️(可通过重设 value 标签修改) ✔️ ❌ 通过属性赋值修改属性的值 ✔️ ❌ ✔️ ❌ delete 该属性返回 true ✔️ ✔️ ❌ ❌ 修改 getter/setter 方法 ✔️ ✔️ ❌ ❌ 修改属性标签 ✔️ ✔️ ❌ ❌ 单向绑定&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解完Object.defineProperty后，我们就可以从零开始先实现 Vue 中的单向绑定。单向绑定是把 Model 绑定到 View，当我们用 JavaScript 代码更新 Model 时，View 就会自动更新。因此，我们不需要进行额外的 DOM 操作，只需要进行 Model 的操作就可以实现视图的联动更新。我将通过数据劫持、数据代理、模板编译和发布订阅四个部分来实现 vue 的单向绑定。一旦数据变化，就去更新页面(只有 data–&gt;DOM，没有 DOM–&gt;data)。若用户在页面上做了更新，就手动收集(双向绑定是自动收集)，合并到原有的数据中。 数据劫持 Observer()1var app1 = new Vue(&#123; el: '#vue-app', data: &#123; mvvm: 100, a: &#123; a: 1 &#125; &#125;, &#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据劫持部分将实现可以通过this.data.x的方式获取和修改 data 中的值。大致的思路是先获取 Vue 中的属性并把它挂在到 options 下。然后再获取 options 中的 data 属性。定义一个数据监听器的方法，能够劫持数据对象中的所有属性进行监听。将 data 中的每个对象通过 Object.defineProperty 的方式去定义。需要运用到递归，防止劫持对象中还有对象的问题，利用 getter/setter 的方法去实现。 1234567891011121314151617181920212223242526272829303132333435363738394041function Vue(options = &#123;&#125;) &#123; // 将所有属性挂载到$options this.$options = options; //this._data var data = (this._data = this.$options.data); //观察对象，每个去劫持一下 observer(data);&#125;// 主要逻辑function Observer(data) &#123; for (item in data) &#123; let val = data[item]; //递归，劫持对象中还有对象的问题 observer(val); // 把data属性通过Object.defineProperty的方式 定义属性 Object.defineProperty(data, item, &#123; //可枚举 enumerable: true, get() &#123; return val; &#125;, set(newVal) &#123; // 设置的值和以前相同 if (val === newVal) &#123; return; &#125; else &#123; //把最新的值赋给val,当取值的时候取到的就是新的newval val = newVal; //定义新值的时候，也需要把再去定义成属性 observer(newVal); &#125; &#125; &#125;); &#125;&#125;// 观察对象给对象增加Object.definePropertyfunction observer(data) &#123; //防止溢出 if (typeof data !== \"object\") return; return new Observer(data);&#125; 数据代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在数据劫持部分，我们可以通过this.data.x的方式去获取和修改值，但是这种方式并不优雅。在Vue中是直接通过this.x的方式获取的。这就是数据代理部分需要实现的效果。大致的思路就是通过遍历的方式将this.data.x中的值直接挂载到this.x中,用this代理this._data。 123456789101112131415161718192021function Vue(options = &#123;&#125;) &#123; // 将所有属性挂载到$options this.$options = options; //this._data var data = (this._data = this.$options.data); //观察对象，每个去劫持一下 observer(data); // 挂载到this上，便于直接通过this.x访问,this代理了this._data for (let key in data) &#123; Object.defineProperty(this, key, &#123; enumerable: true, get() &#123; return this._data[key]; &#125;, set(newVal) &#123; this._data[key] = newVal; &#125; &#125;); &#125;&#125; 编译模板 Compile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在以上两个部分我们已经成功的获取到 data 中的值，并且挂载到了 this 上。这个部分需要实现的是：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据。大致的实现思路是：创建文档碎片，将el中第一个子元素的内容放到而放入内存中。获取将子元素集合并转成数组，循环获取每个子元素的文本内容。然后将文本内容替换为对应this.x上的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function Vue(options = &#123;&#125;) &#123; // 将所有属性挂载到$options this.$options = options; //this._data var data = (this._data = this.$options.data); //观察对象，每个去劫持一下 observer(data); // 挂载到this上，便于直接通过this.x访问,this代理了this._data for (let key in data) &#123; Object.defineProperty(this, key, &#123; enumerable: true, get() &#123; return this._data[key]; &#125;, set(newVal) &#123; this._data[key] = newVal; &#125; &#125;); &#125; new Compile(options.el, this);&#125;// 模板编译function Compile(el, vm) &#123; //开始替换 // el表示替换的范围 vm.$el = document.querySelector(el); // 创建文档碎片 let fragment = document.createDocumentFragment(); // 将el中的内容移到内存中 //返回文档的首个子节点 while ((child = vm.$el.firstChild)) &#123; fragment.appendChild(child); &#125; replace(fragment); function replace(fragment) &#123; // 获取子节点集合并转化成数组,循环每一层 //fragment.childNodes是类数组，需要用Array,from转成数组 Array.from(fragment.childNodes).forEach(node =&gt; &#123; // 获取每个子节点的文本内容 let text = node.textContent; let reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; // 判断节点类型是否为文本 if (node.nodeType === 3 &amp;&amp; reg.test(text)) &#123; //与正则表达式匹配的第一个 子匹配(以括号为标志)字符串 console.log(RegExp.$1); //mvvm,a ,a.a //将类似a.a的字符串变成字符串数组 let arr = RegExp.$1.split(\".\"); let val = vm; arr.forEach(key =&gt; &#123; key = key.trim(); val = val[key]; console.log(val); &#125;); // 替换的逻辑 node.textContent = text.replace(/\\&#123;\\&#123;(.*)\\&#125;\\&#125;/, val); &#125; // 如果有子节点，需要再执行replace if (node.hasChildNodes()) &#123; replace(node); &#125; &#125;); &#125; vm.$el.appendChild(fragment);&#125; 发布订阅&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一步已经实现了获取 data 可以首次更新视图，但是当 data 改变的时候，视图就不会更新了。这部分我们将通过发布订阅模式来实现视图与数据的连接。首先，我们先来简单说说发布订阅模式。 发布订阅模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发布订阅模式是先订阅再发布。以下的代码就是根据发布订阅模式实现的。可以这么理解：有一些方法可以帮我们订阅一些事件，放在数组中[fn,fn,fn],要发布的时候，把数组依次循环执行。 1234567891011121314151617181920212223242526272829303132function Dep() &#123; //事件池 this.subs = [];&#125;//规定每个方法中都有一个updata属性//订阅Dep.prototype.addSub = function(sub) &#123; this.subs.push(sub);&#125;;//依次执行Dep.prototype.notify = function() &#123; this.subs.forEach(sub =&gt; &#123; sub.updata(); &#125;);&#125;;//创建Watcher类，通过Watcher创建的实例都有updata方法function Watcher(fn) &#123; this.fn = fn;&#125;Watcher.prototype.updata = function() &#123; this.fn();&#125;;// 监听函数let watcher = new Watcher(function() &#123; console.log(\"发布订阅模式\");&#125;);let dep = new Dep();dep.addSub(watcher);dep.notify(); 采用发布订阅模式实现视图与数据的连接&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何实现数据变化的时候，视图也跟着变化呢。以下实现的大致思路就是：当数据变化的时候，需要刷新视图，那么首先要找到编译替换的地方订阅下事件，并把新值传给订阅事件的回调函数。便于 update 的执行的时候将新值更新到视图上。取新值的时候，就会用到 get 方法，所以我们需要设置一个标志位，当有新值的时候将订阅的事件放到订阅队列里。接下来我们就会考虑到什么时候执行订阅好的事件呢？当然是 set 的时候，需要执行下订阅中的函数，去刷新视图。 大致思路： 1.当数据改变的时候，刷新视图，那么就需要找到编译替换的地方 2.找到编译替换的地方后，需要订阅下，当数据变化的时候再执行替换的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123function Compile(el, vm) &#123; vm.$el = document.querySelector(el); let fragment = document.createDocumentFragment(); while ((child = vm.$el.firstChild)) &#123; fragment.appendChild(child); &#125; replace(fragment); function replace(fragment) &#123; Array.from(fragment.childNodes).forEach(node =&gt; &#123; let text = node.textContent; let reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; if (node.nodeType === 3 &amp;&amp; reg.test(text)) &#123; let arr = RegExp.$1.split(\".\"); let val = vm; arr.forEach(key =&gt; &#123; key = key.trim(); val = val[key]; console.log(val); &#125;); // 替换的逻辑 //函数里需要取到新值,就需要根据当前的实例、实例的值(比如mvvm)拿到新值，传给回调函数 new Watcher(vm, RegExp.$1, function(newVal) &#123; //订阅下，当数据变化时再执行替换的逻辑 node.textContent = text.replace(/\\&#123;\\&#123;(.*)\\&#125;\\&#125;/, newVal); &#125;); node.textContent = text.replace(/\\&#123;\\&#123;(.*)\\&#125;\\&#125;/, val); &#125; // 如果有子节点，需要再执行replace if (node.hasChildNodes()) &#123; replace(node); &#125; &#125;); &#125; vm.$el.appendChild(fragment);&#125;// 主要逻辑function Observer(data) &#123; for (item in data) &#123; let val = data[item]; //递归，劫持对象中还有对象的问题 observer(val); //订阅 let dep = new Dep(); // 把data属性通过Object.defineProperty的方式 定义属性 Object.defineProperty(data, item, &#123; //可枚举 enumerable: true, get() &#123; //取到新值，把它加入到订阅队列中。相当于一个监控函数，里面放了[watcher...],然后执行完又将 Dep.target变为null Dep.target &amp;&amp; dep.addSub(Dep.target); return val; &#125;, set(newVal) &#123; // 设置的值和以前相同 if (val === newVal) &#123; return; &#125; else &#123; //把最新的值赋给val,当取值的时候取到的就是新的newval val = newVal; //定义新值的时候，也需要把再去定义成属性 observer(newVal); //让所有的watch.update方法执行 dep.notify(); &#125; &#125; &#125;); &#125;&#125;// 观察对象给对象增加Object.definePropertyfunction observer(data) &#123; //防止溢出 if (typeof data !== \"object\") return; return new Observer(data);&#125;//function Dep() &#123; //事件池 this.subs = [];&#125;//规定每个方法中都有一个updata属性//订阅Dep.prototype.addSub = function(sub) &#123; this.subs.push(sub);&#125;;//依次执行Dep.prototype.notify = function() &#123; this.subs.forEach(sub =&gt; &#123; sub.updata(); &#125;);&#125;;//创建Watcher类，通过Watcher创建的实例都有updata方法function Watcher(vm, exp, fn) &#123; //为了能让update拿到三个参数，所以需要将3个参数赋给this this.fn = fn; this.vm = vm; this.exp = exp; //添加一个不存在的属性作为标志位，判断新值是否取完 Dep.target = this; let val = vm; let arr = exp.split(\".\"); arr.forEach(key =&gt; &#123; key = key.trim(); val = val[key]; &#125;); Dep.target = null;&#125;Watcher.prototype.updata = function() &#123; //执行回调函数的时候，需要传一个新值。 let val = this.vm; let arr = this.exp.split(\".\"); arr.forEach(key =&gt; &#123; key = key.trim(); val = val[key]; &#125;); //把最新的值传给回调函数 this.fn(val);&#125;;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://gwjacqueline.github.io/categories/Vue/"}],"tags":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://gwjacqueline.github.io/tags/vue/"},{"name":"ES5","slug":"ES5","permalink":"https://gwjacqueline.github.io/tags/ES5/"},{"name":"原理","slug":"原理","permalink":"https://gwjacqueline.github.io/tags/原理/"},{"name":"发布订阅","slug":"发布订阅","permalink":"https://gwjacqueline.github.io/tags/发布订阅/"},{"name":"数据劫持","slug":"数据劫持","permalink":"https://gwjacqueline.github.io/tags/数据劫持/"},{"name":"单向绑定","slug":"单向绑定","permalink":"https://gwjacqueline.github.io/tags/单向绑定/"}]},{"title":"vue 知识点总结","slug":"vue-知识点总结","date":"2019-06-15T06:00:42.000Z","updated":"2019-06-20T03:37:01.000Z","comments":true,"path":"vue-知识点总结/","link":"","permalink":"https://gwjacqueline.github.io/vue-知识点总结/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了给自己加深记忆，就整理一篇关于vue知识点的文章吧。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了给自己加深记忆，就整理一篇关于vue知识点的文章吧。 vue 中的 mvvm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mvvm全称是 Model-View-ViewModel，是一种基于前端开发的架构模式，Model 层主要用来定义数据对象和操作的业务逻辑，vm.$data就是 vue 中的 Model 层。View 层就是负责将数据模型转化成 UI 展示出来，vm.$el是被 Vue 实例管理的 DOM 节点，当一个 vue 实例被创建时，它会递归遍历根元素的所有子节点，完成数据绑定并编译到template中，template中的内容就相当于 View 层。ViewModel 是一个同步 View 和 Model 的对象，是 Vue 的核心。在 mvvm 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互的，因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。var vm = new Vue({ /* options */ })在 Vue.js 中，每个 Vue 实例都是一个 ViewModel。因此，开发者只需要关注关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态同步的问题，复杂的数据转态维护完全由 MVVM 来统一管理。 具体请看vue 实现原理(一)&gt;)、vue 实现原理(二)&gt;) vue 的双向绑定的原理简介&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调 mvvm 和 mvc 的区别以及适合的场景&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mvvm 和 mvc 都是一种设计思想。主要是 mvc 中的 controller 演变成了 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验的问题。最大的区别就是 vue 是数据驱动，是通过数据来显示视图而不是节点操作。mvvm 适合数据操作比较多的场景。 vue 的特点 简洁：页面由 HTML 模板+Json 数据+Vue 实例组成 数据驱动：自动计算属性和追踪依赖的模板表达式 组件化：用可复用、解耦的组件来构造页面 轻量：代码量小，不依赖其他库 快速：精确有效批量 DOM 更新 模板友好：可通过 npm，bower 等多种方式安装，很容易融入 v-show 指令，v-if 的区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两者都是条件渲染执行。v-show的值无论为 false 或是 true，元素都会在 html 代码中，false 时display：none，true 为display:block。而v-if只有当值为 true 时，元素才会存在于 html 代码中。 如何让 css 只在当前组件中起作用1&lt;style scoped&gt;&lt;/style&gt; Vue 生命周期 具体请看之前的文章Vue 实例生命周期 Vue 路由 具体请看之前的文章Vue 路由 组件之间传值父组件与子组件传值：Props 子组件向父组件传递数据: 子组件通过\\$emit 方法传递参数,触发父组件 event vuex 的 mutation 和 action 的特性及区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutation 用于修改 state 的数据，是同步的。action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态，并且 action 可以包含任意异步操作。 有关 vuex 的请看之前的文章搭建 Vuex 中央状态管理 为什么使用 v-for 时必须添加唯一的 key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。采用的是就地复用策略。即列表数据修改的时候,他会根据 key 值去判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素。从而减少不必要的元素重渲染在 Diff 算法中 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染. computed 和 watched 的区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。如果一个数据依赖于其它数据，那么我们常用 computed 去解决，如果需要在某个数据变化时做一些事情，那么就更适合用 watch 了 当 vue 的 data 里边声明或者已经赋值过的对象或者数组（数组里边的值是对象）时，向对象中添加新的属性，如果更新此属性的值，是否会更新视图&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不会。 受 ES5 的限制，Vue.js 不能检测到对象属性的添加或删除。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue.js 转换它，才能让它是响应的。需要使用$set()方法。 123this.$set(this.object, key, value);//或者Vue.set(vm.obj, key, value); delete 和 Vue.delete 删除数组的区别1234567891011121314var a = [4, 5, 6];var b = [1, 2, 3];delete a[1];console.log(a);// [4, empty, 6, __ob__: Observer]// 0: 4// 2: 6//length: 3this.$delete(b, 1);console.log(b);//[2, 3, __ob__: Observer]//0: 2//1: 3//length: 2 以上代码可以看出delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。Vue.delete直接删除了数组 改变了数组的键值 如何优化 SPA 应用的首屏加载速度慢的问题 将公用的 JS 库通过 script 标签外部引入，减小 app.bundel 的大小，让浏览器并行下载资源文件，提高下载速度 在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的 js 文件 加一个首屏 loading 图，提升用户体验 指令 keep-alive在 vue-router 写着 ，keep-alive 的含义：如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令 感谢以下文章对我总结 vue 的帮助： https://juejin.im/post/5aae19aa6fb9a028d4445d1ahttps://zhuanlan.zhihu.com/p/53703176http://web.jobbole.com/95670/https://juejin.im/post/5d046560f265da1b961301d8","categories":[{"name":"Vue","slug":"Vue","permalink":"https://gwjacqueline.github.io/categories/Vue/"}],"tags":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://gwjacqueline.github.io/tags/vue/"}]},{"title":"函数的节流与防抖","slug":"函数的节流与防抖","date":"2019-06-15T02:27:43.000Z","updated":"2019-06-16T06:51:06.000Z","comments":true,"path":"函数的节流与防抖/","link":"","permalink":"https://gwjacqueline.github.io/函数的节流与防抖/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们在做 WEB 客户端开发时，会经常使用resize、scroll、mousemove、input等在极短的时间内高频的调用回调函数。如果回调中又伴随着 DOM 操作，从而引发浏览器的重排与重绘，会造成浏览器非常大的计算压力，同时也会大量占用内存，性能差的浏览器可能就会直接假死，这样会大大降低用户体验。所以我们需要降低触发回调的频率。接下来我们通过函数节流和防抖看下如何降低回调的频率。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们在做 WEB 客户端开发时，会经常使用resize、scroll、mousemove、input等在极短的时间内高频的调用回调函数。如果回调中又伴随着 DOM 操作，从而引发浏览器的重排与重绘，会造成浏览器非常大的计算压力，同时也会大量占用内存，性能差的浏览器可能就会直接假死，这样会大大降低用户体验。所以我们需要降低触发回调的频率。接下来我们通过函数节流和防抖看下如何降低回调的频率。 函数节流(throttle)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节流指的是在规定的单位时间内，只能有一次触发事件的回调函数执行，如果在规定的单位时间内某事件被触发多次，那么只能有一次生效。我们以监听window对象的scroll事件为例： 无节流时： 123456 $(window).on( &quot;scroll&quot;, function() &#123; console.log(&quot;触发滚动事件&quot;); &#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在没有加上函数节流之前，滚动的时候，浏览器会无时无刻地去触发滚动的方法，这样做事比较消耗性能的。在实际场景中，我们需要的是滚动时每隔一段时间去执行一次滚动的回调，而不是无时无刻的。所以我们需要加上函数节流，当触发滚动时，每隔一个单位时间才会去执行滚动的回调。 节流后： 123456789101112131415161718192021function throttle(callback, duration = 300) &#123; //触发滚动方法时计算当前时间 let time = new Date().getTime(); return function() &#123; //执行回调函数前再次计算当前时间 let nowTime = new Date().getTime(); //确保下次执行必须在300ms以后 if (nowTime - time &gt; duration) &#123; //执行回调 callback(); //执行后需要把当前时间变成执行回调后的时间 time = nowTime; &#125; &#125;;&#125;$(window).on( &quot;scroll&quot;, throttle(function() &#123; console.log(&quot;触发滚动事件&quot;); &#125;, 500)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们用一张图简单看下节流的具实现思路把。最开始会先执行 f1 函数，当 f2 又被触发后，先去判断它是否在单位时间 500ms 内，如果在，则不执行。接下来 f3 又被触发了，同理也是判断是否在单位时间 500ms 内，不在的话，则执行 f3。 节流应用场景短时间高频触发scroll、touchmove等事件DOM元素拖拽 函数防抖(debounce)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节流指的是在规定的单位时间内，只能有一次触发事件的回调函数执行，如果在同一单位时间内某事件被触发多次，那么只能有一次生效，我们用输入框的input事件为例来看看函数防抖。 123456$(&quot;#debounce&quot;).on( &quot;input&quot;, function() &#123; console.log($(&quot;#debounce&quot;).val()); &#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到，只要输入框值改变，就会触发回调。从资源上说，这是一种浪费的行为，而且在实际场景中，也是用户输入完整的字符后，才需要执行进一步的回调，接下来，我们用函数防抖优化下： 防抖后： 123456789101112131415161718function debounce(callback, delay = 500) &#123; //初设起始时间为null var time = null; return function() &#123; //每次执行后都清空时间 clearTimeout(time); time = setTimeout(() =&gt; &#123; //延迟500ms后执行回调 callback(); &#125;, delay); &#125;;&#125;$(&quot;#debounce&quot;).on( &quot;input&quot;, debounce(function() &#123; console.log($(&quot;#debounce&quot;).val()); &#125;, 600)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还是用一张图来看看防抖的实现思路把。当第一次触发了 f1 后，我们先将它延迟 500ms 后执行。如果在 500ms 期间，又触发了一次，我们叫它 f2，则会将 500ms 清空，反正 f1 也还没有执行，则会重新延迟 500ms 后再执行 f2，依次类推。通过闭包保存一个标记用来存储setTimeout返回的值，当再次触发后，就会把前一个setTimeout clear 掉，然后再创建一个新的setTimeout。 防抖应用场景输入框搜索联想给按钮加函数防抖防止表单多次提交对于输入框连续输入进行AJAX验证时，用函数防抖能有效减少请求次数触发resize,不断的调整浏览器窗口大小","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/tags/js/"},{"name":"节流","slug":"节流","permalink":"https://gwjacqueline.github.io/tags/节流/"},{"name":"防抖","slug":"防抖","permalink":"https://gwjacqueline.github.io/tags/防抖/"}]},{"title":"严格模式","slug":"严格模式","date":"2019-06-14T06:03:41.000Z","updated":"2019-06-20T05:42:16.000Z","comments":true,"path":"严格模式/","link":"","permalink":"https://gwjacqueline.github.io/严格模式/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近又重温了一下犀牛书，想对严格模式下的语言规范进行一下梳理和总结。“use strict” 是 ES5 引入的一条指令，它只能出现在脚本代码的开始或者函数体的开始、任何实体语句之前。使用”use strict”令的目的是说明（脚本或函数中）后续的代码将会解析为严格代码。严格模式是一种特殊的执行模式，它修复了部分语言上的不足，提供更强的错误检查，并增强安全性。不建议在整个脚本中使用严格模式，建议按照一个个函数去开启严格模式。避免合并脚本带来的问题 123function A()&#123; “use strict”&#125; 1234&quot;use strict&quot;function A()&#123;&#125;","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近又重温了一下犀牛书，想对严格模式下的语言规范进行一下梳理和总结。“use strict” 是 ES5 引入的一条指令，它只能出现在脚本代码的开始或者函数体的开始、任何实体语句之前。使用”use strict”令的目的是说明（脚本或函数中）后续的代码将会解析为严格代码。严格模式是一种特殊的执行模式，它修复了部分语言上的不足，提供更强的错误检查，并增强安全性。不建议在整个脚本中使用严格模式，建议按照一个个函数去开启严格模式。避免合并脚本带来的问题 123function A()&#123; “use strict”&#125; 1234&quot;use strict&quot;function A()&#123;&#125; 不允许用with语句123456!function()&#123;&#125;( &quot;use strict&quot;; with(&#123;x:1&#125;)&#123; console.log(x); &#125;;); 报错：语法错误 SyntaxError 不允许未声明的变量被赋值12345!function()&#123; &quot;use strict&quot;; x = 1; console.log(window.x);&#125;() 报错：引用错误 ReferenceError(在作用域中找不到)，在非严格模式下，这种隐式声明的全局变量的方法是给全局对象新增加一个新属性，但是在严格模式下，所有的变量都要先声明。 调用的函数（不是方法）中this指的是 undefined12345function A()&#123; &quot;use strict&quot;; return this;&#125;A() === undefined; //true 1234function A()&#123; return this;&#125;A() === window 一般函数中this指的是 window，严格模式下，this指的是 undefined 使用apply、call、bind时，当传入的参数为’null 或 undefined’时，this 指向‘null 或 undefined’1234567!function()&#123; &quot;use strict&quot;; function A()&#123;return this&#125;; console.log(apply(null)); //null console.log(call(undefined)); //undefined console.log(bind(null)); //null&#125;() 123456!function()&#123; function A()&#123;return this&#125;; console.log(apply(null)); //window console.log(call(undefined)); //window console.log(bind(null)); //window&#125;() 不允许给只读属性赋值和不可扩展的对象创建新成员只读属性 123456789!function()&#123; &quot;use strict&quot;; var obj = &#123; get x()&#123; return 8; &#125;; &#125;; obj.x = 6;&#125;() 报错：类型错误 TypeError，在非严格模式下，只是简单的操作失败 不可扩展的对象 123456!function()&#123; &quot;use strict&quot;; var obj = &#123; name:&apos;Lucy&apos; &#125;; Object.preventExtensions(obj); obj.age = 17;&#125;() 报错：类型错误 TypeError，在非严格模式下，只是简单的操作失败 eval 具有独立的作用域12345!function()&#123; &quot;use strict&quot; eval(&apos;var age = 15;&apos;); console.log(typeof age); //undefined&#125;() 1234!function()&#123; eval(&apos;var age = 15;&apos;); console.log(typeof age); //number&#125;() arguments 变为静态的参数副本12345!function(x)&#123; &quot;use strict&quot;; arguments[0] = 10; console.log(x); //1&#125;(1) 1234!function(x)&#123; arguments[0] = 10; console.log(x); //10&#125;(1) 严格模式下，argument 不可被修改，但是我们可以通过传对象的方式修改 12345!function(a)&#123; &quot;use strict&quot;; arguments[0].x =10; console.log(a.x); //10&#125;(&#123;x:1&#125;) 不能删除非法的标识符（比如变量、函数、函数参数）1234!function(a)&#123; &quot;use strict&quot;; delete a;&#125;(1) 报错：语法错误 SyntaxError 123!function(a)&#123; console.log(delete a); //false&#125;() 在非严格模式下，返回 false,无意义但不会报错 不能删除不可配置的属性12345678!function(a)&#123; &quot;use strict&quot;; var obj = &#123;&#125;; Object.defineProperty(obj,&apos;a&apos;,&#123; configurable:false &#125;); delete obj.a;&#125;(1) 报错：类型错误 TypeError 1234567!function(a)&#123; var obj = &#123;&#125;; Object.defineProperty(obj,&apos;a&apos;,&#123; configurable:false &#125;); console.log(delete obj.a); //false&#125;(1) 在非严格模式下，delete 表达式操作失败，并返回 false 对象字面量重复属性报错12345!function()&#123; &quot;use strict&quot;; var obj=&#123;x:1,x:2&#125;; console.log(obj.x);&#125;() 报错：严格模式下报语法错误 SyntaxError 1234!function()&#123; var obj=&#123;x:1,x:2&#125;; console.log(obj.x); //2&#125;() 非严格模式下最后一个重名对象将覆盖之前的 函数参数名重复报错1234!function(x,x,y)&#123; &quot;use strict&quot;; console.log(x+y);&#125;(1,2,3) 报错：严格模式下报语法错误 SyntaxError 1234!function(x,x,y)&#123; &quot;use strict&quot;; console.log(x+y); //5&#125;(1,2,3) 非严格模式下，最后一个重名参数会覆盖之前的重名参数 禁止八进制字面量1234!function()&#123; &quot;use strict&quot;; console.log(0123);&#125;() 报错：严格模式下报语法错误 SyntaxError 123!function()&#123; console.log(0123); //83&#125;() eval、arguments 变为关键字，不能作为变量、函数名1234!function()&#123; &quot;use strict&quot;; function eval()&#123;&#125;;&#125;() 报错：严格模式下报语法错误 SyntaxError 1234!function()&#123; function eval()&#123;&#125;; console.log(eval); //function eval()&#123;&#125;&#125;() 禁用arguments.caller、arguments.callee","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/tags/js/"},{"name":"严格模式","slug":"严格模式","permalink":"https://gwjacqueline.github.io/tags/严格模式/"},{"name":"ES5","slug":"ES5","permalink":"https://gwjacqueline.github.io/tags/ES5/"}]},{"title":"异步加载js","slug":"异步加载js","date":"2019-06-08T12:22:47.000Z","updated":"2019-06-16T06:50:59.000Z","comments":true,"path":"异步加载js/","link":"","permalink":"https://gwjacqueline.github.io/异步加载js/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载 JS 最常见的方法就是在&lt;head&gt;中插入&lt;script type=&quot;text/javascript&quot; src=&quot;balabala&quot;&gt;&lt;/script&gt;在浏览器解析过程中，一旦发现&lt;script&gt;，就会阻止浏览器的后续处理。直至等待脚本下载并执行完后，才继续恢复解析 HTML 网页。这是因为 JS 中可能会修改 DOM 还有重定向行为等。所以默认同步执行才是安全的，否则会导致复杂的线程竞赛问题。所以一般建议把&lt;script&gt;放在&lt;body&gt;结尾处，这样尽可能减少页面阻塞。如果 JS 是来源于网页开发者自己的 JS 代码，内容是开发者可以控制的。那么我们可以采用以下三种方式去提高性能：1、合并文件：当有多个script标签引用时，我们根据需求合并至单个。这样有助于建立一次 TCP 连接，就可完成下载。2、压缩文件：利用压缩工具压缩 JS，去除多余的空格和注释，减少文件大小。 3、末尾加载：把&lt;script&gt;写在&lt;body&gt;结尾处，因为整个文档正文已经加载完毕。如果我们使用的是第三方 JS，类似高德地图等由其他服务提供商提供的，这时 JS 代码并不受我们控制，就很有可能出现加载时间很长，甚至失败的情况。时间太长则会造成浏览器“假死”，页面一片空白。如果第三方 JS 代码越多，则这种风险就越大。所以就要考虑如果在加载第三方 JS 的情况下，保证自己网站的加载速度。如果这个时间还采用同步加载，带来的体验往往并不好。所以我们可以采用异步加载这些第三方 JS。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载 JS 最常见的方法就是在&lt;head&gt;中插入&lt;script type=&quot;text/javascript&quot; src=&quot;balabala&quot;&gt;&lt;/script&gt;在浏览器解析过程中，一旦发现&lt;script&gt;，就会阻止浏览器的后续处理。直至等待脚本下载并执行完后，才继续恢复解析 HTML 网页。这是因为 JS 中可能会修改 DOM 还有重定向行为等。所以默认同步执行才是安全的，否则会导致复杂的线程竞赛问题。所以一般建议把&lt;script&gt;放在&lt;body&gt;结尾处，这样尽可能减少页面阻塞。如果 JS 是来源于网页开发者自己的 JS 代码，内容是开发者可以控制的。那么我们可以采用以下三种方式去提高性能：1、合并文件：当有多个script标签引用时，我们根据需求合并至单个。这样有助于建立一次 TCP 连接，就可完成下载。2、压缩文件：利用压缩工具压缩 JS，去除多余的空格和注释，减少文件大小。 3、末尾加载：把&lt;script&gt;写在&lt;body&gt;结尾处，因为整个文档正文已经加载完毕。如果我们使用的是第三方 JS，类似高德地图等由其他服务提供商提供的，这时 JS 代码并不受我们控制，就很有可能出现加载时间很长，甚至失败的情况。时间太长则会造成浏览器“假死”，页面一片空白。如果第三方 JS 代码越多，则这种风险就越大。所以就要考虑如果在加载第三方 JS 的情况下，保证自己网站的加载速度。如果这个时间还采用同步加载，带来的体验往往并不好。所以我们可以采用异步加载这些第三方 JS。 async 属性12&lt;!-- 指定async属性,异步加载完马上执行。以及 onload 回调--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;balabala.js&quot; async=&quot;async&quot; onload=&quot;init()&quot;&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async是 HTML5 新增的属性，IE10 和大部分浏览器都是支持该属性的。该属性的作用是让脚本能异步加载，也就是会开启一个线程去加载 JS，会在下载完后立即执行。但是一些旧浏览器并不支持。从而导致 JS 文件在这些浏览器中不是异步的，并且会阻止掉页面渲染。但是如果我们做的是移动端的产品，移动端的浏览器大多支持aysnc，我们就可以大胆放心的用啦。带有async属性的脚本在 script 文件下载完成后会立即执行，并且其执行时间一定在 window 的 load 事件触发之前。所以这意味着多个带有async属性的脚本并不保证会按其在页面中的出现先后顺序执行。因此要确保带有async属性的脚本之间互不依赖非常重要。如果对执行的先后顺序有要求，那让我们来看看defer。 defer 属性12&lt;!-- 指定defer属性,异步加载完延迟执行。--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;balabala.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个属性和async类似，都用于改变处理脚本的行为。都是只适用于外部脚本文件，都会开启一个线程去下载 JS 文件。但是与async不同的是，defer会告诉浏览器延迟执行。就是在 DOM 渲染后之后再按顺序执行 JS。也就是说 async 是乱序的，而 defer 是顺序执行。 要注意的是两者都不应该使用 document.write，这个导致整个页面被清除 defer 和 async 一起用1&lt;script type=&quot;text/javascript&quot; src=&quot;balabala.js&quot; async=&quot;async&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试后发现在谷歌浏览器上表现和只使用async一致.当浏览器同时使用了 async 和 defer 属性之后，浏览器会忽略 defer属性.对于不支持 async 的浏览器,会自动使用defer属性。 动态创建 script 标签123456789101112131415161718192021222324function loadScript(url, callback) &#123; var script = document.createElement(&quot;script&quot;); script.type = &quot;text/javascript&quot;; if (typeof callback != &quot;undefined&quot;) &#123; if (script.readyState) &#123; //IE script.onreadystatechange = function() &#123; if ( this.readyState == &quot;complete&quot; ||script.readyState == &quot;loaded&quot; ) &#123; script.onreadystatechange = null; callback(); &#125; &#125;; &#125; else &#123; //其他浏览器 script.onload = function() &#123; callback(); &#125;; &#125; &#125; script.src = url; document.body.appendChild(script);&#125; 如果需要失败的回调，可以通过设置定时器的方式来实现 12345678910111213141516171819202122//失败成功回调var timer;function time()&#123; timer=setTimeout(function()&#123; if(timer)&#123; timer=&quot;&quot;; //定时器未在指定时间内收到请求,终止调用，执行错误回调 &#125;else&#123; //调用成功 &#125; &#125;,20000); loadScript(&quot;balabala.js&quot;,set);&#125;var set = function()&#123; if(timer)&#123; clearTimeout(timer); timer=&quot;&quot;; //收到请求，执行成功回调并清空定时器 &#125;else&#123; //收到清空，已执行错误回调 &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法是在页面中&lt;script&gt;标签内，用 js 创建一个 script 元素并插入到 document 中。这样就做到了非阻塞的下载 js 代码。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上列出的三种方案。动态创建 script 标签是目前兼容性最好、普适性最高的方案。如果我们的用户大多是移动端或者不需要兼容 IE10 以下的浏览器，那么async属性使最合适的。如果我们不介意 JS 的执行会被延后到文档解析完毕后再执行，而且对加载顺序有所要求，那么defer是最合适的方案。","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"异步","slug":"异步","permalink":"https://gwjacqueline.github.io/tags/异步/"},{"name":"网页性能优化","slug":"网页性能优化","permalink":"https://gwjacqueline.github.io/tags/网页性能优化/"}]},{"title":"搭建Vuex中央状态管理","slug":"搭建Vuex中央状态管理","date":"2019-06-02T07:29:16.000Z","updated":"2019-06-02T10:39:01.000Z","comments":true,"path":"搭建Vuex中央状态管理/","link":"","permalink":"https://gwjacqueline.github.io/搭建Vuex中央状态管理/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vuex 通过创建一个集中的数据存储，供程序中所有组件访问。主要应用于 Vue.js 中管理数据状态的一个库。接下来我用一张图来帮助我们更好的理解什么是 Vuex。图中 store 是一个仓库，装的是数据源。下面的 c1-c4,分别代表 component1-component4. 这里面的组件都可以去使用我们 store 里面的数据。Vuex 帮助我们实现了数据统一管理的功能 。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vuex 通过创建一个集中的数据存储，供程序中所有组件访问。主要应用于 Vue.js 中管理数据状态的一个库。接下来我用一张图来帮助我们更好的理解什么是 Vuex。图中 store 是一个仓库，装的是数据源。下面的 c1-c4,分别代表 component1-component4. 这里面的组件都可以去使用我们 store 里面的数据。Vuex 帮助我们实现了数据统一管理的功能 。 Vue.js 和 Vuex.js 使用场景中的数据处理Vue.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们来看下单一使用 Vue 场景下，我们一般是怎么处理数据的。图中最上面有一个根组件，假设里面的 data 有很多数据。在根组件之下，又有两个组件，分别是组件 1 和组件 2，再往下，这两个组件又有自己的子组件。我们知道根组件下面的 2 个组件如果想要获取到根组件的数据，需要通过 vue 当中的prop进行传值。组件下面的 2 个子组件，我们也可以通过prop进行属性传值。但是如果子组件想要去修改一些数据的话，那么子组件就需要触发某一个事件然后传给父组件，然后父组件也需要触发某个事件，再传给他的根组件，这样我们的数据就发送变化了。当我们的数据发生变化后，data 就会分别传给下面的组件 1 和组件 2。这样就会有一个问题，比如最下面的两个子组件想要数据共用的话，就很麻烦。因为要从子组件 2 中一直往上传，基本上是绕了一大圈，然后才到子组件 1。这样是可以做到数据传递的，但是它的使用方式非常的麻烦， Vuex.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来我们看看 Vuex 场景中的数据处理是什么样的。我们有一个store用来存储数据，如果我们要添加、更改一些数据。我们就可以用mutation方法去更改一下。子组件中修改了数据，那么store就会把修改后的数据分散到对应的组件，这样就就能更清晰的管理数据了。 安装及使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在脚手架中没有安装Vuex的，可以使用以下命令安装并使用。脚手架安装过Vuex的，可以忽略这一步。 1.安装 1npm install vuex —save 2.创建 store.js 并引入对应组件 12345678import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)export default new Vuex.Store(&#123;&#125;) 3.在 main.js 中引入 12345import store from &apos;./store&apos;new Vue(&#123; store, render: h =&gt; h(App)&#125;).$mount(&apos;#app&apos;) 核心概念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vuex 的核心概念有五个，分别是 State(状态)、Getter(获取状态)、Mutation(改变状态)、Action(通过异步操作 Mutation 改变状态) 以及 Module(将前面几个模块化)。 State&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来我将用vue父组件向子组件传值的例子来看看换成vuex的 State 应该怎么去实现。 vue 父组件向子组件传值父组件 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;product-view-one v-bind:products=&quot;products&quot;&gt;&lt;/product-view-one&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ProductViewOne from &quot;./components/ProductViewOne&quot;;import ProductViewTwo from &quot;./components/ProductViewTwo&quot;;export default &#123; name: &quot;app&quot;, data() &#123; return &#123; //父组件data products: [ &#123; name: &quot;Lucy&quot;, price: 2000 &#125;, &#123; name: &quot;Daming&quot;, price: 1000 &#125;, &#123; name: &quot;Henry&quot;, price: 100 &#125;, &#123; name: &quot;Jane&quot;, price: 10 &#125; ] &#125;; &#125;, components: &#123; &quot;product-view-one&quot;: ProductViewOne &#125;&#125;;&lt;/script&gt; 子组件 1234567891011121314151617181920212223&lt;template&gt; &lt;div id=&quot;ProductViewOne&quot;&gt; &lt;p&gt;ProductViewOne&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(product,index) in products&quot; :key=&quot;index&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123;product.name&#125;&#125;&lt;/span&gt; &lt;span class=&quot;price&quot;&gt;&#123;&#123;product.price&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;ProductViewOne&quot;, //通过props传值 props: &#123; products: &#123; type: Array, required: true &#125; &#125;&#125;;&lt;/script&gt; State 存储数据1.将数据统一放在 store.js 中的 state 中 12345678910111213141516import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex);export default new Vuex.Store(&#123; //状态 state:&#123; products: [ &#123; name: &quot;Lucy&quot;, price: 2000 &#125;, &#123; name: &quot;Daming&quot;, price: 1000 &#125;, &#123; name: &quot;Henry&quot;, price: 100 &#125;, &#123; name: &quot;Jane&quot;, price: 10 &#125; ] &#125;&#125;); 2.对应组件中获取数据 store 实例中读取状态的方法就是在计算属性中返回某个状态，当 state 中对应的数据变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM 12345678910111213141516171819202122&lt;template&gt; &lt;div id=&quot;ProductViewOne&quot;&gt; &lt;p&gt;ProductViewOne&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(product,index) in products&quot; :key=&quot;index&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123;product.name&#125;&#125;&lt;/span&gt; &lt;span class=&quot;price&quot;&gt;&#123;&#123;product.price&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;ProductViewOne&quot;, computed: &#123; products() &#123; //组件能通过 this.$store.state去获取对应的数据 return this.$store.state.products; &#125;, &#125;,&#125;;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对比可以看出，Vuex 这种机制去处理庞大的数据是非常舒适的，也非常便捷，不需要使用属性去传值，也不要 event 事件给父级传值，减少代码的冗余度，对于庞大数据，是非常适合的。 mapState 辅助函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个组件需要获取多个转态时，使用以下的方式会让代码重复且冗余，为了解决这个问题，vuex为我们提供了mapState辅助函数帮我们生成计算属性，减少代码量 1234567891011121314export default &#123; computed: &#123; products() &#123; return this.$store.state.products; &#125;, products2() &#123; return this.$store.state.products2; &#125;, 当有多个状态时 ...products3(), ...products4(), ... &#125;,&#125; …mapState([…]); 对应组件 12345678&lt;script&gt;import &#123; mapState &#125; from &quot;vuex&quot;;export default &#123; computed: &#123; ...mapState([&quot;products&quot;,&quot;products2&quot;,&quot;...&quot;]) &#125;,&#125;&lt;/script&gt; Getter 获取数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时我们不单单需要从 store 中的 state 里直接拿取数据，而是需要从 state 中派生出一些转态，比如要拿 state 中某个数字字段的 2 倍。这时候我们就需要用到getter,我们可以把它当做是 store 的计算属性。getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 store.js 1234567891011121314151617181920212223export default new Vuex.Store(&#123; //状态 state: &#123; products: [ &#123; name: &quot;Lucy&quot;, price: 2000 &#125;, &#123; name: &quot;Daming&quot;, price: 1000 &#125;, &#123; name: &quot;Henry&quot;, price: 100 &#125;, &#123; name: &quot;Jane&quot;, price: 10 &#125; ] &#125;, getters: &#123; saleProducts: (state) =&gt; &#123; //接受 state 作为其第一个参数,简化this.$store.state的写法 let saleProducts = state.products.map(product =&gt; &#123; return &#123; name: &quot;**&quot; + product.name + &quot;**&quot;, price: product.price * 2 &#125;; &#125;); return saleProducts; &#125; &#125;,&#125;) 对应组件 1234567891011&lt;template&gt; &lt;div id=&quot;ProductViewOne&quot;&gt; &lt;p&gt;ProductViewOne&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(product,index) in saleProducts&quot; :key=&quot;index&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123;product.name&#125;&#125;&lt;/span&gt; &lt;span class=&quot;price&quot;&gt;&#123;&#123;product.price&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; mapGetters 辅助函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和mapState类似，mapGetters将 store 中的 getter 映射到局部计算属性,使用对象展开运算符的方式让我们的代码看上去更简洁。 …mapState([…]); 对应组件 12345678&lt;script&gt;import &#123; mapGetters &#125; from &quot;vuex&quot;;export default &#123; computed: &#123; ...mapGetters([&quot;saleProducts&quot;]) &#125;,&#125;&lt;/script&gt; Mutation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们触发事件后改变数据，就使用mutations,而不再使用computed,也不再使用getters。我们通过点击按钮触发事件的方式来看看mutation怎么用。说到这里，建议大家在谷歌浏览器下安装vue.js devtools的插件，便于我们进行调式。 vue.js devtools&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装完后开启 vue 的项目，会发现在检查元素中会多一个 vue 节点，点击后可以看到当前项目的组件信息，还可以看到 Vuex 中对应的信息。 vue.js 实现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们先来看看触发事件后改变数据在不用Mutation的情况下，是怎么实现的。 对应组件 123456789101112131415161718192021222324&lt;template&gt; &lt;div id=&quot;ProductViewOne&quot;&gt; &lt;p&gt;ProductViewOne&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(product,index) in saleProducts&quot; :key=&quot;index&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123;product.name&#125;&#125;&lt;/span&gt; &lt;span class=&quot;price&quot;&gt;&#123;&#123;product.price&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;reducePrice&quot;&gt;触发事件改变price&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; reducePrice() &#123; &lt;!-- 通过forEach()遍历数据 --&gt; this.$store.state.products.forEach(product =&gt; &#123; product.price -= 1; &#125;); &#125;, &#125;&#125;;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然在不使用Mutation的时候可以实现，但不是最优解，使用 mutations 可以通过vue.js devtools帮助我们追踪。而且这样写在严格模式下会报以下的错误。 1[vuex] do not mutate vuex store state outside mutation handlers. Mutation 实现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过Mutation实现，不仅便于我们就可以跟踪事件了，而且严格模式下也不会报错 store.js 12345678910111213141516171819export default new Vuex.Store(&#123; //状态 state: &#123; products: [ &#123; name: &quot;Lucy&quot;, price: 2000 &#125;, &#123; name: &quot;Daming&quot;, price: 1000 &#125;, &#123; name: &quot;Henry&quot;, price: 100 &#125;, &#123; name: &quot;Jane&quot;, price: 10 &#125; ] &#125;, //接受 state 作为第一个参数，payload为触发事件中的实参 mutations: &#123; reducePrice: (state, payload) =&gt; &#123; state.products.forEach(product =&gt; &#123; product.price -= payload; &#125;); &#125; &#125;,&#125;) 对应组件 12345678910111213141516171819202122&lt;template&gt; &lt;div id=&quot;ProductViewOne&quot;&gt; &lt;p&gt;ProductViewOne&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(product,index) in saleProducts&quot; :key=&quot;index&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123;product.name&#125;&#125;&lt;/span&gt; &lt;span class=&quot;price&quot;&gt;&#123;&#123;product.price&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; button @click=&quot;reducePrice(6)&quot;&gt;传参事件触发更改数据&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState,mapGetters,mapActions &#125; from &quot;vuex&quot;;export default &#123; methods: &#123; reducePrice(amout) &#123; //通过调用 store.commit 方法激活事件,commit中事件的名字取决于mutations this.$store.commit(&quot;reducePrice&quot;,amout); &#125;&#125;;&lt;/script&gt; 注意：Mutation 必须是同步函数 mapMutations 辅助函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; …mapMutations([…]); 对应组件 12345678&lt;script&gt;import &#123; mapMutations &#125; from &quot;vuex&quot;;export default &#123; methods: &#123; ...mapMutations([&quot;reducePriceTime&quot;]) &#125;,&#125;&lt;/script&gt; Action&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action类似于Mutation,其中最重要的区别就是Mutation必须是同步函数，而Action可以包含任意异步操作。Action提交的是Mutation,而不是直接改变转态。Action接受一个与 store 实例具有相同方法和属性的 context 对象，因此我们可以调用 context.commit 提交一个 Mutation。 store.js 12345678910111213141516171819202122232425262728export default new Vuex.Store(&#123; //状态 state: &#123; products: [ &#123; name: &quot;Lucy&quot;, price: 2000 &#125;, &#123; name: &quot;Daming&quot;, price: 1000 &#125;, &#123; name: &quot;Henry&quot;, price: 100 &#125;, &#123; name: &quot;Jane&quot;, price: 10 &#125; ] &#125;, mutations: &#123; reducePrice: (state, payload) =&gt; &#123; state.products.forEach(product =&gt; &#123; product.price -= payload; &#125;); &#125; &#125;, actions:&#123; //这里的context可以理解为this.$state reducePriceTime: (context, payload) =&gt; &#123; //模拟异步操作 setTimeout(function () &#123; //激活上面的reducePrice context.commit(&apos;reducePrice&apos;, payload); &#125;, 2000); &#125; &#125;,&#125;) 我们也可以直接用 ES6 解构的方式代替 1234567actions:&#123; reducePriceTime: (&#123;commit&#125;, payload) =&gt; &#123; setTimeout(function () &#123; commit(&apos;reducePrice&apos;); &#125;, 2000); &#125;&#125;, 对应组件 12345678910111213141516171819202122&lt;template&gt; &lt;div id=&quot;ProductViewOne&quot;&gt; &lt;p&gt;ProductViewOne&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(product,index) in saleProducts&quot; :key=&quot;index&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123;product.name&#125;&#125;&lt;/span&gt; &lt;span class=&quot;price&quot;&gt;&#123;&#123;product.price&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;reducePriceTime(6)&quot;&gt;模拟异步&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; reducePriceTime(amout) &#123; //通过 store.dispatch 方法触发 this.$store.dispatch(&quot;reducePriceTime&quot;, amout); &#125; &#125;&#125;; mapActions 辅助函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和mapState、mapGetters的功能和用法都类似，这边不再仔细记录了，直接上代码。 …mapActions([…]); 对应组件 12345678&lt;script&gt;import &#123; mapActions &#125; from &quot;vuex&quot;;export default &#123; methods: &#123; ...mapActions([&quot;reducePriceTime&quot;]) &#125;,&#125;&lt;/script&gt; Module&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们的状态比较多，然后对应的 getter、mutation 又很多时， 那么当前的 store 对象会变得相当臃肿，并且会让当前的代码变得冗余。所以为了解决这个问题，就出现了 module 这么个东西。 接下来我们用 module 把当前的 vuex 模块化并进行整理。 1.在 src 下新增 store 的文件夹 2.在 store 下再新建个文件夹叫 modules,专门用来管理模块化的东西 3.在 modules 中新建对应模块文件，比如 product.js 4.在 store 文件夹下创建 index.js,并删除 src 下的 store.js。main.js 中的 store 在找不到 store.js 的情况下就会去找 store 下的 index.js，目前我们项目 store 的结构如下图 5.store/index.js 123456789101112import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import product from &apos;./modules/product&apos;Vue.use(Vuex);export default new Vuex.Store(&#123; modules: &#123; //对应模块 product, &#125;&#125;); 6.据 state 进行分割，写入对应模块.js 123456789101112131415161718192021222324252627282930313233343536373839const state = &#123; products:[ &#123; name: &quot;Lucy&quot;, price: 2000 &#125;, &#123; name: &quot;Daming&quot;, price: 1000 &#125;, &#123; name: &quot;Henry&quot;, price: 100 &#125;, &#123; name: &quot;Jane&quot;, price: 10 &#125; ]&#125;const getters = &#123; saleProducts: (state) =&gt; &#123; let saleProducts = state.products.map(product =&gt; &#123; return &#123; name: &quot;**&quot; + product.name + &quot;**&quot;, price: product.price / 2 &#125;; &#125;); return saleProducts; &#125;&#125;const mutations = &#123; reducePrice: (state, payload) =&gt; &#123; state.products.forEach(product =&gt; &#123; product.price -= payload; &#125;); &#125;&#125;const actions = &#123; reducePriceTime: (context, payload) =&gt; &#123; setTimeout(function () &#123; //激活上面的reducePrice context.commit(&apos;reducePrice&apos;, payload); &#125;, 2000); &#125;&#125;export default &#123; state, getters, mutations, actions&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 vuex 写了一个待办事项，具体 demo 可以上github查看","categories":[{"name":"Vue","slug":"Vue","permalink":"https://gwjacqueline.github.io/categories/Vue/"}],"tags":[{"name":"异步","slug":"异步","permalink":"https://gwjacqueline.github.io/tags/异步/"},{"name":"JS框架","slug":"JS框架","permalink":"https://gwjacqueline.github.io/tags/JS框架/"},{"name":"渐进式","slug":"渐进式","permalink":"https://gwjacqueline.github.io/tags/渐进式/"},{"name":"Vuex","slug":"Vuex","permalink":"https://gwjacqueline.github.io/tags/Vuex/"}]},{"title":"Vue http请求","slug":"Vue-http请求","date":"2019-05-24T01:20:56.000Z","updated":"2019-05-29T08:02:04.000Z","comments":true,"path":"Vue-http请求/","link":"","permalink":"https://gwjacqueline.github.io/Vue-http请求/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在构建应用时通常需要访问一个 API 并展示其数据。做这件事的方式有好几种。这边我将在 firebase 上创建自己的数据库，然后通过 vue-resource、axios 和 fetch 三种方式对数据进行增删改查。让我们了解 vue 是怎样进行 http 请求的。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在构建应用时通常需要访问一个 API 并展示其数据。做这件事的方式有好几种。这边我将在 firebase 上创建自己的数据库，然后通过 vue-resource、axios 和 fetch 三种方式对数据进行增删改查。让我们了解 vue 是怎样进行 http 请求的。 vue-resource&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vue-resource 是 Vue.js 的一款通过 XMLHttpRequest 或 JSONP 发起请求并处理响应的插件。它能做的是和 ajax 一样，但是比 ajax 的 API 更为简洁。 1.安装 1npm install vue-resource --save-dev 2.引入并全局使用 main.js 12import VueResource from &apos;vue-resourceVue.use(VueResource) 3.post 请求 post(url, [body], [options]) 1234this.$http.post(&quot;https://vue-blog-62383.firebaseio.com/posts.json&quot;,this.blog).then(data =&gt; &#123; console.log(data); ////返回Response对象&#125;); 3.get 请求get(url, [options]) 12345678this.$http .get(&quot;https://vue-blog-62383.firebaseio.com/posts.json&quot;) .then(data =&gt; &#123; return data.json(); //返回Promise对象 &#125;) .then(data =&gt; &#123; console.log(data); //拿到数据库中的数据 &#125;); 4.删除对应数据delete(url, [options]) 12345678this.$http .delete( //删除对应数据 &quot;https://vue-blog-62383.firebaseio.com/posts/&quot; + this.id + &quot;.json&quot; ) .then(res =&gt; &#123; //删除后对应操作 &#125;); 5.修改对应数据put(url, [body], [options]) 1234567this.$http .put( &quot;https://vue-blog-62383.firebaseio.com/posts/&quot; + this.id + &quot;.json&quot;,this.blog ) //成功之后 .then(data =&gt; &#123; //修改后对应操作 &#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是使用 vue-resource 实现的增删改查。具体的配置项可以看看官网。vue-resources 目前官网已经不再进行更新维护了。目前官方推荐的是 axios。接下来我们看看 axios 吧。 axios&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;axios 是目前主流的 http 请求，是一个基于 promise 的 HTTP 库。也是目前官方推荐的。建议大家多去使用一些主流请求数据的方法。 1.安装 1npm install axios 2.引入 1import axios from ‘axios&apos; 3.post 请求 axios.post(url[, data[, config]]) 12345678axios.post(&quot;https://vue-blog-62383.firebaseio.com/posts.json&quot;,this.blog).then(data =&gt; &#123; //成功 console.log(data);&#125;).catch(error=&gt;&#123; //失败 console.log(error);&#125;); 4.get 请求 axios.get(url[, config]) 1234567axios.get(&quot;https://vue-blog-62383.firebaseio.com/posts.json&quot;) .then(res) =&gt; &#123; console.log(res); //获取数据 console.log(res.data); &#125;) console.log(res); 12345678910&#123;data&#125;: &#123;…&#125;, status: 200, statusText: &quot;OK&quot;, headers: &#123;…&#125;, config: &#123;…&#125;, …&#125;config:&#123;&#125;data: authors: &quot;Lucy&quot; categories: [&quot;vue.js&quot;] content: &quot;错误原因的内容&quot; phContent: &quot;请输入博客内容&quot; phTitle: &quot;请输入博客标题&quot; title: &quot;错误原因611&quot; __proto__: Object &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们把res打印出来，可以看到 res 中的 data 是我们想要拿到的数据。所以我们直接通过res.data的方式拿到数据。注意：这里和 vue-resource 不一样的在于，不需要 res.json()去解析，axios 直接解析出来的就是一个对象 4.删除对应数据 axios.delete(url[, config]) 123axios.delete(&quot;https://vue-blog-62383.firebaseio.com/posts/&quot; + this.id + &quot;.json&quot;).then(res =&gt; &#123; //删除后执行方法&#125;); 5.修改对应数据 12345678910axios .put( &quot;https://vue-blog-62383.firebaseio.com/posts/&quot; + this.id + &quot;.json&quot;, this.blog ) .then(res =&gt; &#123; //获取修改数据 console.log(res.data); &#125;); 6.请求配置(官网) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&#123; // `url` 是用于请求的服务器 URL url: &apos;/user&apos;, // `method` 是创建请求时使用的方法 method: &apos;get&apos;, // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &apos;https://some-domain.com/api/&apos;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 &apos;PUT&apos;, &apos;POST&apos; 和 &apos;PATCH&apos; 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 &apos;PUT&apos;, &apos;POST&apos;, 和 &apos;PATCH&apos; // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: &apos;Fred&apos; &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: &apos;janedoe&apos;, password: &apos;s00pers3cret&apos; &#125;, // `responseType` 表示服务器响应的数据类型，可以是 &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos; responseType: &apos;json&apos;, // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的 &#125;, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // &apos;proxy&apos; 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: &apos;127.0.0.1&apos;, port: 9000, auth: : &#123; username: &apos;mikeymike&apos;, password: &apos;rapunz3l&apos; &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 7.axios 全局配置 main.js 12345678910//在实际开发过程中，基本前面的域名是一样的，可以通过配置baseURL去简化代码// 配置axios请求的地址axios.defaults.baseURL = &apos;https://vue-blog-62383.firebaseio.com&apos;//在登录场景的时候后台人员通常会要求有一个token的值，只有token验证成功了，才能登录//设置请求头为 Authorizationaxios.defaults.headers.common(&apos;Authorization&apos;) = &apos;Token&apos;//设置post请求头 axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/urlencode&apos;;//设置get请求头axios.defaults.headers.get[&apos;Accepts&apos;] = &apos;application/json&apos; 无配置全局 baseURL 123axios.get(&quot;https://vue-blog-62383.firebaseio.com/posts/&quot; + this.id + &quot;.json&quot;).then(res =&gt; &#123; console.log(res.data);&#125;); 配置全局 baseURL 后 123axios.get(&quot;/posts/&quot; + this.id + &quot;.json&quot;).then(res =&gt; &#123; console.log(res.data);&#125;); 8.抽离 axios 到单独文件 比如 axios-auto.js 1234567891011import axios from &apos;axios&apos;// 创建实例时设置配置的默认值const instance = axios.create(&#123; baseURL: &apos;https://vue-blog-62383.firebaseio.com&apos;&#125;);// 在实例已创建后修改默认值instance.defaults.headers.common(&apos;Authorization&apos;) = &apos;Token&apos;//自定义 axios 实例添加拦截器instance.interceptors.request.use(function () &#123;&#125;);//暴露出去export default instance 如果想单独引用 axios.js 里面的配置，则根据路径直接在对应的地方引入 1import axios from &quot;../axios-auto&quot;; 9.拦截器 12345678910111213141516171819// 添加请求拦截器const myInterceptor = axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);//移除拦截器axios.interceptors.request.eject(myInterceptor);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); fetch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fetch 是 axios 的一个替代方案。使用 Fetch 有很多别的注意事项，这也是为什么官网更推荐我们用 axios 的原因。Fetch 是浏览器提供的原生 AJAX 接口。我们在使用它的时候不需要额外加载一个外部资源。关于 fetch 可以看看我之前的关于异步编程的文章。 1.post 请求 12345678910111213fetch(&quot;https://vue-blog-62383.firebaseio.com/posts.json&quot;, &#123; method: &quot;POST&quot;, headers:&#123; token:&quot;f0292837363794947&quot; &#125;, body:JOSN.stringify(&#123;id: 1,name: &apos;Lucy&apos;&#125;); &#125;) .then(result =&gt; &#123; return result.json(); &#125;) .then(data =&gt; &#123; console.log(data); &#125;); 2.get 请求 123456789fetch(&quot;https://vue-blog-62383.firebaseio.com/posts.json&quot;) .then((res) =&gt; res.json()) .then((data) =&gt; &#123; console.log(data); &#125;) .catch(err =&gt; &#123; console.log(err); &#125;);&#125;); 3.修改 12345678910111213fetch(&quot;https://vue-blog-62383.firebaseio.com/posts.json&quot;, &#123; method: &quot;PUT&quot;, headers:&#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, body:JOSN.stringify(&#123;id: 2,name: &apos;Lucy&apos;&#125;); &#125;) .then(result =&gt; &#123; return result.json(); &#125;) .then(data =&gt; &#123; console.log(data); &#125;); 4.删除 123456789101112fetch(&quot;https://vue-blog-62383.firebaseio.com/posts.json&quot;, &#123; method: &quot;DELETE&quot;, headers:&#123; token:&quot;f0292837363794947&quot; &#125;, &#125;) .then(result =&gt; &#123; return result.json(); &#125;) .then(data =&gt; &#123; console.log(&quot;删除成功&quot;); &#125;); 跨域问题如果看到以下报错，就是因为浏览器的同源策略导致了跨域 1234567Access to XMLHttpRequest at &apos;XXX&apos; from origin &apos;http://localhost:8084&apos; has been blocked by CORS policy:The value of the &apos;Access-Control-Allow-Origin&apos; header in the response must not be the wildcard &apos;*&apos; when the request&apos;s credentials mode is &apos;include&apos;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute. Vue Cli2+解决 config/index.js,在 proxyTable 中添写如下代码 1234567891011 //跨域请求设置,跨域完整地址：http://f.apiplus.cn/bj11x5.jsonproxyTable: &#123; //使用&quot;/apis&quot;来代替&quot;http://f.apiplus.cn &quot;,一定要有http,如果是对应的ip,也需要有http &apos;/apis&apos;: &#123; target: &apos;http://f.apiplus.cn/&apos;, //接口域名 changeOrigin: true, //是否跨域 pathRewrite: &#123; &apos;^/apis&apos;: &apos;&apos; //路径重写 &#125; &#125;&#125;, Vue Cli3+解决 根目录创建 vue.config.js 12345678910111213module.exports = &#123; devServer: &#123; proxy: &#123; &apos;/apis&apos;: &#123; target: &apos;http://f.apiplus.cn/&apos;, //接口域名 changeOrigin: true, //是否跨域 pathRewrite: &#123; &apos;^/apis&apos;: &apos;&apos; //路径重写 &#125; &#125; &#125;, &#125;&#125; 相应跨域请求 123456789//apis相当于http://f.apiplus.cnfetch(&quot;/apis/bj11x5.json&quot;, &#123; method: &quot;post&quot;&#125;) .then(result =&gt; &#123; return result.json(); &#125;) .then(data =&gt; &#123; console.log(data); &#125;); 通过以上代码实现的具体事例可以看这里","categories":[{"name":"Vue","slug":"Vue","permalink":"https://gwjacqueline.github.io/categories/Vue/"}],"tags":[{"name":"异步","slug":"异步","permalink":"https://gwjacqueline.github.io/tags/异步/"},{"name":"fetch","slug":"fetch","permalink":"https://gwjacqueline.github.io/tags/fetch/"},{"name":"JS框架","slug":"JS框架","permalink":"https://gwjacqueline.github.io/tags/JS框架/"},{"name":"渐进式","slug":"渐进式","permalink":"https://gwjacqueline.github.io/tags/渐进式/"},{"name":"http请求","slug":"http请求","permalink":"https://gwjacqueline.github.io/tags/http请求/"},{"name":"axios","slug":"axios","permalink":"https://gwjacqueline.github.io/tags/axios/"},{"name":"vue-resource","slug":"vue-resource","permalink":"https://gwjacqueline.github.io/tags/vue-resource/"}]},{"title":"Vue路由","slug":"Vue路由","date":"2019-05-18T06:20:43.000Z","updated":"2019-05-24T01:26:03.000Z","comments":true,"path":"Vue路由/","link":"","permalink":"https://gwjacqueline.github.io/Vue路由/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;路由是端到端的数据传输路径。说白了，和a标签实现的功能一样,就是跳转。使用 a 标签点击多少次，就会发送多少次的网络请求。也就是当前页面会实现不停的刷新。而 vue-router 是一个与 vue 核心深度集成的前端路由框架，性能也优化的更好。输入的 URL 地址不会直接向服务器发送请求，而是浏览器 自己来解析路由信息，包括地址，参数 ,然后来渲染组件。最后生成对应的视图。前端路由一般只向服务器获取数据，而不向服务器获取模板。Vue 路由可以帮助我们实现点击后，不会请求和页面刷新，直接就可以跳转到我们要去的位置。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;路由是端到端的数据传输路径。说白了，和a标签实现的功能一样,就是跳转。使用 a 标签点击多少次，就会发送多少次的网络请求。也就是当前页面会实现不停的刷新。而 vue-router 是一个与 vue 核心深度集成的前端路由框架，性能也优化的更好。输入的 URL 地址不会直接向服务器发送请求，而是浏览器 自己来解析路由信息，包括地址，参数 ,然后来渲染组件。最后生成对应的视图。前端路由一般只向服务器获取数据，而不向服务器获取模板。Vue 路由可以帮助我们实现点击后，不会请求和页面刷新，直接就可以跳转到我们要去的位置。 安装&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大多数使用 Vue CLi 搭建的时候有安装路由模块，如果没有安装的话可以使用以下命令安装 1npm install vue-router --save-dev 基本使用1.在 router/index.js 中引入对应组件 1234import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import About from &apos;@/components/about/About&apos;import Admin from &apos;@/components/Admin&apos; 2.在 router/index.js 使用 Router 1Vue.use(Router) 3.在 router/index.js 配置路由 1234567891011export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, //路由地址 name: &apos;Home&apos;, //路由名 component: Home, //如果抓到了路由地址，需要让它调用component &#125;, ], //去掉URL中的# mode: &apos;history&apos;,&#125;) 4.在对应组件中使用 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用router-link 组件来导航，默认会被渲染成一个&lt;a&gt;标签，属性 to指定链接 1234567 &lt;ul&gt; &lt;li&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; &lt;/li&gt;&lt;/ul&gt;//展示对应路由视图&lt;router-view/&gt; 进阶使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上的基本使用能帮我们搭建一个快速的路由。但是在实际的项目开发中开始远远不够的。接下来我们用官方提供的 API来总结一下常用的路由配置吧。 router-link 换标签&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;router-link 默认是一个 a 标签，想要换成其他标签，就需要用到tag属性 1&lt;router-link tag=“div&quot;&gt;&#123;&#123;nav.text&#125;&#125;&lt;/router-link&gt; 12//看，换成div了吧&lt;div data-v-61dd7a3d=&quot;&quot; class=&quot;nav-link&quot;&gt;注册&lt;/div&gt; 绑定动态路由地址1234567891011121314&lt;template&gt; //:to &lt;router-link :to=&quot;login&quot;&gt;登录&lt;/router-link&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Header&quot;, data() &#123; return &#123; login: &quot;/Login&quot;, &#125;; &#125;&#125;;&lt;/script&gt; 找不到路由时，默认返回某页&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们需要注意的是：含有通配符的路由应该放在最后，路由 { path: ‘*‘ } 通常用于客户端 404 错误。 1234567891011121314151617181920export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, name: &apos;Home&apos;, component: Home &#125;, &#123; path: &apos;/Menu&apos;, name: &apos;Menu&apos;, component: Menu &#125;, //上面这些东西没有匹配上，就会走*号,跳转回主页 &#123; path: &apos;*&apos;, redirect: &apos;/&apos; &#125;, ], mode: &apos;history&apos;,&#125;) 利用路由名跳转1&lt;router-link :to=&quot;&#123;name:&apos;Register&apos;&#125;&quot;&gt;注册&lt;/router-link&gt; 跳转到上一次浏览的页面1this.$router.go(-1); 跳转到指定地址123this.$router.replace(&quot;/Menu&quot;)//通过名字跳转this.$router.replace(&#123; name: &quot;Admin&quot; &#125;); 通过 push 进行跳转123this.$router.push(&quot;/Login&quot;);//通过名字this.$router.push(&#123; name: &quot;Login&quot; &#125;); 路由嵌套要在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置router/index.js 123456789101112131415161718192021222324252627282930313233343536export default new Router(&#123; routes: [ &#123; path: &apos;/about/About&apos;, name: &apos;About&apos;, component: About, //默认展示路由 redirect: &apos;/about/About/History&apos;, // 二级路由 children: [ //path可以自己定 &#123; path: &apos;/about/About/Contact&apos;, name: &apos;Contact&apos;, component: Contact, redirect: &apos;/about/About/Contact/Phone&apos;, //三级路由 children: [ &#123; path: &apos;/about/About/Contact/Phone&apos;, name: &apos;Phone&apos;, component: Phone &#125;, &#123; path: &apos;/about/About/Contact/PersonName&apos;, name: &apos;PersonName&apos;, component: PersonName &#125;, ] &#125;, &#123; path: &apos;/about/About/Delivery&apos;, name: &apos;Delivery&apos;, component: Delivery &#125;, &#123; path: &apos;/about/About/History&apos;, name: &apos;History&apos;, component: History &#125; ], &#125;, ]&#125;) 导航守卫&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导航守卫我们可以把它看做是 vue-router 的生命周期钩子。我们通过”用户在某网站在买东西，很多时候都需要先登录或注册“这么一个场景来更好的理解导航守卫吧。 全局守卫全局前置守卫 router.beforeEach&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们用 Vue 的全局守卫实现一个场景：当用户在未登录某网站前，每跳转一个页面，都提示用户”未登录，请登录“ 12345678910router.beforeEach((to, from, next) =&gt; &#123; //判断用户是否去登录或者注册页 if (to.name == &apos;Login&apos; || to.name == &apos;Register&apos;) &#123; next(); &#125; else &#123; alert(&quot;未登录，请登录&quot;); //未登录就引导到登录页面上，也可以这么写next(&#123; path: &apos;/&apos; &#125;) next(&apos;/Login&apos;); &#125;;&#125;); 我们用router.beforeEach 注册一个全局前置守卫。它进入组件之前触发它接受三个参数：1.to——要跳转到哪个组件里面去2.from——从哪个路由离开3.next: Function—— 一个方法，决定是否要展示看到路由的页面 全局后置钩子 router.afterEach&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有全局前置守卫，当然也有全局后置钩子啦。但是基本上全局前置守卫使用的较多，后置钩子使用的较少。 1234router.afterEach((to, from) =&gt; &#123; //进入组件后，展示出来 alert(&quot;after each&quot;);&#125;); 我们用router.afterEach 注册全局后置钩子。它进入组件之后触发它接受两个参数：1.to——要去的组件2.from——离开的组件 路由独享守卫 beforeEnter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在进入某个路由前，调用的方法。只针对路由控制的部分。我们还是用代码来实现一个场景帮助我们更好的理解吧。比如：用户在去购买页前，需要判断是否登录，如果没有登录，要先登录。 12345678910111213141516171819export default new Router(&#123; routes: [ &#123; path: &apos;/Buy&apos;, name: &apos;Buy&apos;, component: Buy, //路由独享守卫 beforeEnter: (to, from, next) =&gt; &#123; if (to.name == &apos;Login&apos; || to.name == &apos;Register&apos;) &#123; next(); &#125; else &#123; alert(&quot;未登录不能购买&quot;); //引导到登录页面上 next(&apos;/Login&apos;); &#125;; &#125;, &#125;, ],&#125;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在需要配置的路由上上定义 beforeEnter 守卫。它和全局前置守卫的方法参数一致。 组件内守卫&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以直接在路由组件内定义路由导航。在进入路由时，我们可以对它进行一些操作，离开路由后，我们也可以进行一些操作。 进入到当前组件的时 beforeRouteEnter123456789101112export default &#123; name: &quot;Menu&quot;, data() &#123; return &#123; name: &quot;Hery&quot; &#125;; &#125;, //进入到当前组件的时 beforeRouteEnter(to, from, next) &#123; alert(&quot;Hello&quot; + this.name); &#125;&#125;; 注意：以上的写法，我们会发现拿不到name,因为 data 渲染之前，beforeRouteEnter 就已经执行了。我们需要通过传一个回调给 next 来访问组件实例。因为是异步的，所以在 data 渲染完，就可以拿到值。 12345678910111213export default &#123; name: &quot;Menu&quot;, data() &#123; return &#123; name: &quot;Hery&quot; &#125;; &#125;, beforeRouteEnter(to, from, next) &#123; next(vm =&gt; &#123; alert(&quot;Hello&quot; + vm.name); &#125;); &#125;,&#125;; 离开当前组件时 beforeRouteLeave1234567891011121314151617export default &#123; name: &quot;Menu&quot;, data() &#123; return &#123; name: &quot;Hery&quot; &#125;; &#125;, //离开当前组件时 beforeRouteLeave(to, from, next) &#123; if (confirm(&quot;确定离开吗&quot;) == true) &#123; next(); &#125; else &#123; //不显示 next(false); &#125; &#125;,&#125;; 当前路由改变，但是该组件被复用时 beforeRouteUpdate123456export default &#123; //在动态路由情形下，比如 path: &apos;/user/:id&apos; 这条路由，当页面不变更只动态的改变参数id时，beforeRouteUpdate便会触发 beforeRouteUpdate (to, from, next) &#123; ... &#125;&#125;; 路由复用1.在需要复用的组件内给 router-view 进行赋值，实现路由的简单复用 12&lt;router-view name=&quot;OrderingGuide&quot;&gt;&lt;/router-view&gt;&lt;router-view name=&quot;Delivery&quot;&gt;&lt;/router-view&gt; 2.在展示组件的路由内配置 12345678910111213export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, name: &apos;Home&apos;, //组件复用 components: &#123; default: Home, &apos;OrderingGuide&apos;: OrderingGuide, &apos;Delivery&apos;: Delivery, &#125;, &#125;,&#125;) 控制滚动行为&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vue-router 可以让我们控制页面展示的位置。需要注意：这个功能只在支持 history.pushState 的浏览器中可用。 跳转到指定位置 123456export default new Router(&#123; routes: [...], scrollBehavior(to, from, savedPosition) &#123; return &#123;x: 0,y: 100&#125;; &#125;&#125;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scrollBehavior 方法接收 to 和 from 路由对象。第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。 跳转到某个选择器 123456export default new Router(&#123; routes: [...], scrollBehavior(to, from, savedPosition) &#123; return &#123;selector: &apos;.btn&apos;,&#125;; &#125;&#125;) 滚动到指定滚动到锚点 123456export default new Router(&#123; routes: [...], scrollBehavior(to, from, savedPosition) &#123; return &#123;selector: to.hash&#125;; &#125;&#125;) 返回到之前阅读的位置 12345678910export default new Router(&#123; routes: [...], scrollBehavior(to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition; &#125; else &#123; return &#123; x: 0, y: 0 &#125;; &#125; &#125;&#125;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上具体代码可以到这里查阅。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://gwjacqueline.github.io/categories/Vue/"}],"tags":[{"name":"JS框架","slug":"JS框架","permalink":"https://gwjacqueline.github.io/tags/JS框架/"},{"name":"渐进式","slug":"渐进式","permalink":"https://gwjacqueline.github.io/tags/渐进式/"},{"name":"路由","slug":"路由","permalink":"https://gwjacqueline.github.io/tags/路由/"}]},{"title":"Vue实例生命周期","slug":"Vue实例生命周期","date":"2019-05-12T02:37:54.000Z","updated":"2019-05-15T02:42:05.000Z","comments":true,"path":"Vue实例生命周期/","link":"","permalink":"https://gwjacqueline.github.io/Vue实例生命周期/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vue 是一个渐进式的 JS 框架，也就是一个没有太多限制的 JS 框架。和 Angular 相比，Vue 比 Angular 轻。Angular 是一个很重的框架，它给我们提供了一整套解决方案，Angular 就不是一个渐进式的框架，因为它有很多限制，就是用它的框架可以，但是必须要遵守它的规则，比如要使用它的组件机制，要使用对应的依赖注入，要使用对应它给我集成的东西。虽然可以集成第三方的东西，但是还是有一定的排他性，不太和其他的东西融合。Vue 和 Angular 相反，你可以使用我框架的同时去使用其他的库或者框架。都能很好的跟它们去集成起来。一些简单的语法可以去Vue 的官网学习。这篇文章主要是详细记录下 Vue 实例的生命周期。如果我们只是知道 Vue 的简单语法，可以去实现一些简单的项目。但是一旦发生问题是，我们就需要借助生命周期去寻找问题，甚至一些需求我们也可以根据生命周期的情况去定该把这个东西写在哪里，所以理解生命周期可以帮助我们：1.找错误，2.解决需求。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vue 是一个渐进式的 JS 框架，也就是一个没有太多限制的 JS 框架。和 Angular 相比，Vue 比 Angular 轻。Angular 是一个很重的框架，它给我们提供了一整套解决方案，Angular 就不是一个渐进式的框架，因为它有很多限制，就是用它的框架可以，但是必须要遵守它的规则，比如要使用它的组件机制，要使用对应的依赖注入，要使用对应它给我集成的东西。虽然可以集成第三方的东西，但是还是有一定的排他性，不太和其他的东西融合。Vue 和 Angular 相反，你可以使用我框架的同时去使用其他的库或者框架。都能很好的跟它们去集成起来。一些简单的语法可以去Vue 的官网学习。这篇文章主要是详细记录下 Vue 实例的生命周期。如果我们只是知道 Vue 的简单语法，可以去实现一些简单的项目。但是一旦发生问题是，我们就需要借助生命周期去寻找问题，甚至一些需求我们也可以根据生命周期的情况去定该把这个东西写在哪里，所以理解生命周期可以帮助我们：1.找错误，2.解决需求。 生命周期图解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们根据Vue 的官网给我们提供生命周期图示，来理解下实例的生命周期吧。 钩子函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 红框部分就是生命周期中涉及到的钩子函数，比如 beforeCreate，created 等等到 destoryed.其实我们真正能用到的也就几个，但是 Vue 给我们提供的方法有很多，我们等会具体说。 beforeCreate()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当我们实例 Vue()对象，在这个对象还没有创建之前，我们就会拥有一个方法叫 beforeCreate。如果还没有将 Vue 对象创建出来，我们就可以调用这个方法。这个时候，它只对你当前的事件做了一些配置，还没有真正去识别属性里的东西。因此，Vue 对象还没有诞生前，可以使用这个方法。我们常常在这个方法里做一些加载动画的行为。 created()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然后就开始进入到 created 这个方法中来了，当我们进入到 created 的时候，实例就已经出来了，组件就已经被创建好了，属性也成功的被绑定了。但是 DOM 还没有生成，因为这个时候我们还没有进入到下面,Element 这个属性还不存在。我们在这个方法中常常做的事情: 1.获取对应的数据，比如我们请求网络接口，请求下来之后，把我们请求接口的数据赋给我们的属性，然后再往下走的时候就可以展示 DOM 了 2.结束 loading 加载，准备去渲染当前的 DOM 渲染模板&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当我们执行完 created,也就是说 Vue 实例化对象已经创建好之后，这个时候页面还没有展示出来，还要继续往下走。然后它会去看看有没有“el”,也就是 element 这个属性，如果有的话，它就会继续查看’template’这个选项有没有。 12345new (&#123;el: &apos;#app&apos;,components: &#123; App &#125;,template: &apos;&lt;App/&gt;&apos;&#125;) 如果没有的话，它就会去查看 \\$mount 这个里面有没有东西。 1234new (&#123;el: &apos;#app&apos;,components: &#123; App &#125;&#125;).$mount(&quot;#app&quot;) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果这两者都没有的话，那么当前的生命周期就结束了。因为她没有可渲染的东西，当然就不会往下执行了。有其中一个的话，就会去看看 template。有两种情况，一个是 template 中会执行一个具体的组件(比如执行的是 App.vue)，一个是对应的标签。然后就会执行 render 方法去渲染模板中对应的内容. 12345678910111213141516new (&#123;//具体的组件el: &apos;#app&apos;,components: &#123; App &#125;,template: &apos;&lt;App/&gt;&apos;&#125;)//对应的标签new (&#123;el: &apos;#app&apos;,template: ` &lt;div id=&quot;app&quot;&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;/div&gt;`,components: &#123; App &#125;&#125;) beforeMount()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接下来，它就会进入到下一个钩子函数叫 beforeMount。Mount 是挂载，beforeMount 就是开始编译当前的模板了，这个方法是在虚拟 DOM 当中去执行的。也就是当前还不能看到对应的内容。它只是将这个东西挂载，但是还没有挂载上去，没有将真实的内容渲染到页面上去。可以在这里去做一些基础的工作，根据需求而定， mounted()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行完 beforeMount 之后，就可以执行另一个函数 mounted。beforeMount 到 mounted 的中间：执行完 beforeMount 之后，开始将 element 指向的元素，把 templeate 的东西往里面放。然后到 mounted 这个钩子函数时，模板已经编译完了，编译完之后就开始挂载了，挂载的时候呢，基本 mounted 这个方法一旦结束之后，页面就已经显示出来了。这个就是 mounted.所以如果我们有些东西想让它在页面显示出来之后再去操作，那么我们就要写在 mounted 这个方法里面。 beforeUpdate()、updated()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOM 生成后，我们就可以看到对应的内容。看到内容后，我们还会对当前项目做的事情就是对应的一些更改（增删改查），更改的话就是我们的 update。update 有两个，一个是 beforeUpdate,beforeUpdate 是当前组件在发生更新之前，需要调用的一个钩子函数。还有一个叫 updated，这个是组件更新之后，就是我们已经更新了当前组件，只要这个方法一旦执行完之后，页面就已经是展示出来的效果，如果想在更新之前做一些事情的话，就可以在 beforeUpdate 这个方法中去实现。一般来说，我们想要在当前组件发生一些改变的时候，我们需要调用的是 updated 这个方法， beforeDestory()、destroyed()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面结束之后，就进入到当前组件生命周期的尾部了，它在销毁之前，就调用一个 beforeDestory 这个钩子函数。此时实例仍然有功能。最后就是销毁之后，调用 destroyed。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 实例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我们来上手实践来帮助我们更好的理解钩子函数。以下是主要的代码，大家可以直接看看效果来帮助我更好的理解 Vue 实例的生命周期 12345678910111213141516171819202122232425262728293031323334353637export default &#123; name: &quot;LifeCycle&quot;, data() &#123; return &#123; title: &quot;Vue实例的生命周期&quot; &#125;; &#125;, methods: &#123; changeTitle() &#123; this.title = &quot;生命周期Update钩子&quot;; &#125; &#125;, beforeCreate() &#123; alert(&quot;组件实例化之前的函数&quot;); &#125;, created() &#123; alert(&quot;组件实例化完毕，但页面还未显示&quot;); &#125;, beforeMount() &#123; alert(&quot;组件挂载前，页面仍未展示，但虚拟DOM已经配置&quot;); &#125;, mounted() &#123; alert(&quot;组件挂载后，此方法执行后，页面显示&quot;); &#125;, beforeUpdate() &#123; alert(&quot;组件更新前，页面仍未更新，但虚拟DOM已经配置&quot;); &#125;, updated() &#123; alert(&quot;组件更新，此方法执行后，页面显示&quot;); &#125;, beforeDestroy() &#123; alert(&quot;组件销毁前&quot;); &#125;, destroyed() &#123; alert(&quot;组件销毁&quot;); &#125;&#125;;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://gwjacqueline.github.io/categories/Vue/"}],"tags":[{"name":"JS框架","slug":"JS框架","permalink":"https://gwjacqueline.github.io/tags/JS框架/"},{"name":"渐进式","slug":"渐进式","permalink":"https://gwjacqueline.github.io/tags/渐进式/"}]},{"title":"Git常用命令","slug":"Git常用命令","date":"2019-05-11T01:25:32.000Z","updated":"2019-05-14T13:04:12.000Z","comments":true,"path":"Git常用命令/","link":"","permalink":"https://gwjacqueline.github.io/Git常用命令/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Git 是一个版本管理工具，和 SVN 不同的是，SVN 是集中式的版本控制系统，Git 是分布式版本控制系统。这篇文章主要是简单总结下 Git 和一些常用的 git 命令。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Git 是一个版本管理工具，和 SVN 不同的是，SVN 是集中式的版本控制系统，Git 是分布式版本控制系统。这篇文章主要是简单总结下 Git 和一些常用的 git 命令。 GitGit 的区域1.工作区（working tree） 2.暂存区（stage） 3.版本库（repository） Git 文件的四种转态1.Untracked(未被跟踪)此文件在文件夹中,还没有加入到 git 库,不参与版本控制。通过 git add 状态变为 暂存状态2.Modified表示工作区修改了某个文件，但是还没有添加到暂存区3.Staged表示工作区修改的文件添加到了暂存区但是还没有添加到版本库4.committed表示数据被安全的存在本地库中 常用命令基础命令初始化本地仓库 1git init 查看工作区、暂存区的状态 1git status 将工作区新建/修改的内容添加到暂存区 1git add &lt;file&gt; 将暂存区的内容提交到本地库 1git commit -m &quot;备注&quot; 查看历史记录 1git log 新增、更改 Git 的各种设置 1234git config//例如配置系统级别签名git config --global user.name &quot;&lt;username&gt;&quot;git config --global user.email &quot;&lt;eamil&gt;&quot; 删除某个文件 1git rm --cached &lt;file&gt;; 上传到远程仓库 1234//增加一个名称为origin远程仓库git remote add origin &lt;address&gt;//推送远程仓库git push -f origin master 克隆到本地 1git clone &lt;address&gt; 撤销操作撤销上一次的提交，并将暂存区的文件重新提交，如果没有修改信息的话，就只是提交描述信息 1git commit —amend 拉取暂存区文件 并将其替换成工作区文件 1git checkout -- &lt;file&gt; 拉取最近一次提交到版本库的文件到暂存区，该操作不影响工作区 12//HEAD也可以直接换成版本号git rest HEAD &lt;file&gt; 以上两条操作会导致：暂存区和本地文件不一样，暂存区和版本库不一样。需要使git checkout –[file]命令来把 暂存区文件拉到工作区再将暂存区的文件拉回到工作区中。 分支操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建分支的好处是不会影响当前主线的文件。 比如再已上线的代码中新增需求时，在我们自己的分支中操作不会影响主线的项目。 查看当前分支 1git branch 创建分支 12//注意新分支创建后不会自动切换为当前分支git branch &lt;name&gt; 创建新分支并立即切换到新分支 1git checkout -b &lt;name&gt; 删除分支 12//d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项git branch -d [name] 切换分支 1git checkout &lt;name&gt; 切换主线 1git checkout master 提交分支到远程仓库 1git push -u origin &lt;name&gt; 删除远程分支 1git push -u origin --delete &lt;name&gt; Git 指针 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面这张图能够更快的帮我们理解git指针。版本号1，2，5为master主线，版本号3，4为dev分支。首先，当我们提交了一个版本的时候，就会有一个版本号，就有两个指针指向我们的版本。一个是master分支，一个是HEAD指针，指向当前分支的最后一个版本。当我们修改文件，再次提交后，会有一个新的版本号，同时，我们的分支和HEAD指针也会指向我们最后一次提交。最新版本中也有一个指针指向前一个版本。指针是我们文件中有一块地方保存其他模块的地址。当我们调用其他模块的时候，可以通过这个模块找到其他模块的地址。从而调用其他模块，达到方便访问其他模块的目的。master分支保存了M2版本的地址。同样的再提交一个版本，master指针和HEAD指针都会向前移。当我们再这里新建了一个分支时，比如dev分支。master分支仍会指向版本号二。新建的这个分支会指向版本号三，而HEAD指针从版本号2移到了版本号3.只有当从master分支的版本号2切换到dev 分支的版本号3的时候，HEAD指针会从版本号2移到版本号3。HEAD指针永远指向当前分支的最新版本。当提交到版本号4后，dev分支会和HEAD同时指向最新版本。当这个时候想合并我们的dev分支和master分支时。形成了版本号5分支，版本号5即指向我们的版本号2,又指向版本号4，也就是说他能很快速的访问版本号2,也可以很快速的访问版本号4。分支的指针仅仅保存的是地址。当我们切换版本时，当我们从一个版本回退到另一个版本的时候，分支的指针是直接将他们的地址进行更改。从我们的版本号5的地址换成了版本号2的地址。所以git版本的回退特别快。切换分支时，git是通过判断HEAD是不是指向当前版本。 合并分支及冲突解决合并分支 1git merge &lt;name&gt; 冲突解决在使用 Git 进行多人合作的时候 我们时常会出现冲突。比如我们在分支 A 修改了 index.html 文件并提交到了分支 A 的版本库，同时 master 分支也修改了该文件。即主分支和我们要合并的分支都发生了修改 这时系统就不知道我们要保留哪一个文件 就会发生冲突 1CONFLICT（content）：Merge conflict in index.html 修改冲突文件:我们发现系统把 Master 和 A 分支的内容都列出来了。这时我们想保留那个就把另一个删除即可。然后再添加并提交，就可以合并成功啦。 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD&lt;p&gt;Hello world!&lt;/p&gt;=======&lt;p&gt;Hello world2!&lt;/p&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A 版本差异比较比较工作区和暂存区文件的差异 1git diff 比较暂存区和版本库之间的差异 1git diff — staged 比较两个版本之间的差异 12//版本号最少选4个，git默认是7个，最好选8-10个，这样能保证唯一性git diff &lt;version&gt; &lt;version&gt; 两个分支之间的差异 1git diff &lt;branch&gt; &lt;branch&gt; 存储变更&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上切换分支前，需要把当前分支的修改提交，或者放到暂存区中，否则会报错。解决：将工作区修改的内容暂存起来,并自动切换到修改前的工作区状态 1git stash &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;暂存后，再切换分支就不会报错了。git 在进行分支切换时，它主要改变我们的版本库。当工作区有改变时，会将我们工作区的文件直接覆盖到另外一个分支上去，从而影响另外一个分支。所以使用 git stash 时，将工作区和暂存区的东西封存。git 也会自动将工作区的改变变回改变前的转态查看保存内容列表 1git stash list git stash list 后看到暂存区的东西 12stash@&#123;0&#125;: WIP on master: 452b08d rename hello as hello.cstash@&#123;1&#125;: WIP on master: 452b08d rename hello as hello.c 将暂存区的东西拉回工作区 1git stash apply stash@&#123;x&#125; 将暂存区的东西删除 1git stash drop stash@&#123;x&#125; 将暂存区的东西拉回工作区并删除 1git stash apply stash@&#123;x&#125; 忽略不想上传的文件将忽略的文件名/文件夹名放在.gitignore.gitignore 123node_modules//dist/npm-debug.log","categories":[{"name":"工具","slug":"工具","permalink":"https://gwjacqueline.github.io/categories/工具/"}],"tags":[{"name":"版本管理工具","slug":"版本管理工具","permalink":"https://gwjacqueline.github.io/tags/版本管理工具/"}]},{"title":"走进Webpack的大门","slug":"走进Webpack的大门","date":"2019-05-05T08:32:20.000Z","updated":"2019-05-13T05:42:56.000Z","comments":true,"path":"走进Webpack的大门/","link":"","permalink":"https://gwjacqueline.github.io/走进Webpack的大门/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Webpack 是一个 js 应用程序的静态模块打包器。本身只能打包 js 模块，我们可以通过 loader 让 webpack 去处理那些非 JS 文件。它会将所有类型的文件，转化为应用程序的依赖图。总而言之，webpack 是一个能实现模块化打包的工具。之前的项目一直采用 gulp 进行打包，gulp 和 webpack 相比，gulp 是一种能够优化前端的开发流程的工具，而 WebPack 是一种模块化的解决方案。接下来，我将从 webpack 的工作方式、安装、使用、构建本地服务器以及 entry(入口)、output(出口)、loader、plugins(插件)四个核心概念总结下 webpack。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Webpack 是一个 js 应用程序的静态模块打包器。本身只能打包 js 模块，我们可以通过 loader 让 webpack 去处理那些非 JS 文件。它会将所有类型的文件，转化为应用程序的依赖图。总而言之，webpack 是一个能实现模块化打包的工具。之前的项目一直采用 gulp 进行打包，gulp 和 webpack 相比，gulp 是一种能够优化前端的开发流程的工具，而 WebPack 是一种模块化的解决方案。接下来，我将从 webpack 的工作方式、安装、使用、构建本地服务器以及 entry(入口)、output(出口)、loader、plugins(插件)四个核心概念总结下 webpack。 工作方式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Webpack 会把你的项目当做一个整体，通过给定的主文件（例如：index.js）开始找到你项目所有的依赖文件，并使用 loaders 去处理它们，最后打包为一个或多个浏览器可识别的 JS 文件。把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack 将从这个文件开始找到你的项目的所有依赖文件，使用 loaders 处理它们，最后打包为一个（或多个）浏览器可识别的 JavaScript 文件。 安装1234//全局安装webpack以及脚手架npm install webpack webpack-cli -g//局部安装npm install webpack webpack-cli -S 使用1.新建空文件夹2.cd 到需要打包的项目 3.创建一个标准的 npm 说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等 1npm init 4.安装 webpack 到项目目录 1npm install webpack webpack-cli -S 5.配置webpack.config.js 6.启动 webpack 进行打包 1234//生产环境webpack --mode production//开发环境，可通过package.json快捷配置，下面说webpack --mode development 构建本地服务器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;webpack-dev-server基于 node.js 构建。能够帮助浏览器监听你的代码的修改，并自动刷新显示修改后的结果。我们需要先安装下。 1npm install webpack-dev-server -S webpack.config.js 中配置 1234567891011121314module.exports = &#123; devServer: &#123; //本地服务器加载的页面所在的目录 contentBase: &quot;./build&quot;, //实时刷新 inline: true, //如果设置为true，所有的跳转将指向index.html。针对单页面应用 historyApiFallback: false, //监听端口,默认为8080 port:4040, //默认为index.html index: &apos;main.html&apos; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体配置可以查看这里。接下来我们把运行命令配置到 npm 的 script 中。因为真正开发的时候 webpack 命令会敲很长，我们在 package.json 中设置 scripts 值就可以去调用对应的指令，是非常方便快捷的。 package.json 1234&quot;scripts&quot;: &#123; &quot;deploy&quot;: &quot;webpack --mode development&quot;, &quot;dev&quot;: &quot;webpack-dev-server --open --inline&quot; &#125;, 在根目录下执行命令 生成未压缩的代码 1npm run deploy 启动服务器 1npm run dev &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行后，webpack 会自动帮我们启动一个 web 服务器，并监听文件修改，然后自动重新合并代码。 entry(入口)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry 告诉 webpack 应该使用哪个模块作为内部依赖图的起始点。进入起始点后，webpack 会找出哪些模块和库是起始点所依赖的。每个依赖被处理后，最后会被输出到 bundles 文件中。 webpack.config.js 123456//里面采取commonJs的书写规范，比如module.exports语法module.exports = &#123; //唯一入口文件 //默认值为‘./src’ entry: &apos;./src/index.js&apos;&#125;; output(出口)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output 告诉 webpack 在哪里输出它所创建的 bundles，以及该如何命名这些文件。 webpack.config.js 123456789101112//path模块是从node.js导入的，主要用来控制生成文件的目录const path = require(&apos;path&apos;);module.exports = &#123;//默认值为‘./dist’ output: &#123; //将参数中的路径、路径片段解析成一个绝对地址。_dirname表示当前文件所在的绝对路径 path: path.resolve(__dirname, &apos;build&apos;), //打包后输出文件的文件名 filename: &apos;js/index-[hash].js&apos; &#125;,&#125;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 webpack.config.js 中配置了出入口后，我们只需在终端里运行 webpack，就会自动引用 webpack.config.js 文件中的配置选项。 loader&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;webpack 本身只支持 js,不支持 image、css、html…,如果要让 webpack 支持这些，就需要使用 loader。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后我们就可以利用 webpack 的打包能力，对它们进行处理。记录下我常用的 loader 吧。 scss,css 打包压缩安装编译打包 scss、css 1npm install style-loader css-loader node-sass sass-loader -S 使用 Extract Text Plugin 插件。将 css 各文件分离，生成的文件 不嵌入 bundle.js，而是放在单独的文件里。 1npm install extract-text-webpack-plugin@next -S 使用1.代码将打包到入口文件里 1import &quot;../scss/style.scss&quot;; 2.修改 webpack.config.js 123456789101112131415161718192021222324252627282930313233343536//css各文件分离const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; hashDigestLength: 8 // 默认长度是20 &#125; //loader module: &#123; rules: [ &#123; test: /\\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, //将 JS 字符串生成为 style 节点 use: [&#123; loader: &apos;css-loader&apos;, // \b将 CSS 转化成 CommonJS 模块 options: &#123; modules: true, // 指定启用css modules localIdentName: &apos;[name]__[local]--[hash:base64:5]&apos; // 指定css的类名格式 &#125; &#125;, &#123; loader: &apos;sass-loader&apos; // 将 Sass 编译成 CSS &#125;,] &#125;) &#125; ] &#125;, //插件 plugins: [ new ExtractTextPlugin(&apos;./css/[name]-[hash].css&apos;), //生成文件的文件名 ]&#125; css 模块化&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SS modules 的技术意在把 JS 的模块化思想带入 CSS 中来，通过 CSS 模块,所有的类名只作用于当前模块。通过在 CSS loader 进行配置，就可以直接把 CSS 的类名传递到组件的代码中，这样做有效避免了全局污染。 1.使用： webpack.config.js 1234options: &#123; modules: true, // 指定启用css modules localIdentName: &apos;[name]__[local]--[hash:base64:5]&apos; // 指定css的类名格式&#125; index.js 123import styles from &quot;../scss/style.scss&quot;;document.write(&apos;&lt;div class=&quot;&apos; + styles.green + &apos;&quot;&gt;绿色&lt;/div&gt;&apos;);let a = 10; style.scss 123.green &#123; color: green;&#125; 最后结果： 1&lt;div class=&quot;style__green--XLkki&quot;&gt;绿色&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，即使相同的类名也不会造成不同组件之间的污染 图片css 自动添加前缀1.安装 1npm install postcss-loader autoprefixer -S 2.使用 12345678910111213141516171819202122232425262728293031323334module.exports = &#123; //loader module: &#123; rules: [ &#123; test: /\\.(scss|css)$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&#123; loader: &apos;css-loader&apos;, options: &#123; modules: true, localIdentName: &apos;[name]__[local]--[hash:base64:5]&apos; &#125; &#125;, &#123; loader: &apos;sass-loader&apos; &#125;, &#123; //添加前缀 loader: &quot;postcss-loader&quot;, options: &#123; plugins: [ require(&apos;autoprefixer&apos;)(&#123; browsers: [&apos;last 100 versions&apos;] //必须设置支持的浏览器才会自动添加添加浏览器兼容 &#125;) ] &#125; &#125;,], publicPath: &quot;../&quot;, &#125; ), &#125;, ] &#125;&#125; css 中的图片处理安装1npm install file-loader -S 使用1.修改 webpack.config.js 1234567891011121314151617181920212223module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; hashDigestLength: 8 // 默认长度是20 &#125; //loader module: &#123; rules: [ &#123; test: /\\.(png|jepg|jpg)$/, use: [ //loader 后面 limit 字段代表图片打包限制，这个限制并不是说超过了就不能打包，而是指当图片大小小于限制时会自动转成 base64 码引用 //name 字段来指定图片打包的目录与文件名 &#123; loader: &apos;url-loader?limit=1024&amp;name=./image/[name]-[hash:8].[ext]&apos; &#125; ] &#125; ] &#125;&#125; html 中的图片&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用’url-loader‘只能将 css 中的图片进行打包，如果想将 html 中图片进行打包，需要用到html-withimg-loader插件 安装1npm install html-withimg-loader -S 使用123456789101112131415161718192021module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; hashDigestLength: 8 // 默认长度是20 &#125; //loader module: &#123; rules: [ &#123; test: /\\.html$/, use: [ &#123; loader: &apos;html-withimg-loader&apos; &#125; ] &#125; ] &#125;&#125; js 中的图片&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 js 中引用的图片应该通过模块化的方式引用图片路径，才可以成功打包。 使用12var imgUrl = require(&apos;../image/js.png&apos;);document.write(&apos;&lt;img src=&quot;&apos; + imgUrl + &apos;&quot; /&gt;&apos;); 字体图标12345678910111213141516171819module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; hashDigestLength: 8 // 默认长度是20 &#125; //loader module: &#123; rules: [ &#123; test:/\\.(woff|ttf|svg|eot|xttf|woff2)$/, use: &apos;url-loader?limit=1024&amp;name=./fonts/[name].[ext]&apos; &#125; ] &#125;&#125; Babel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Babel 能让帮助我们将 ES6、ES7 等新标准被当前使用的浏览器支持。能让我们使用基于 JS 进行的扩展语言，比如 React 的 JSX。 安装1npm install babel-core babel-loader@7 babel-preset-env babel-preset-react -S 使用12345678910111213141516171819202122module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; hashDigestLength: 8 // 默认长度是20 &#125; //loader module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: &quot;babel-loader&quot; &#125;, exclude: /node_modules/ //不要进行 babel-loader &#125;, ] &#125;&#125; plugins 插件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插件接口使 webpack 变得更加灵活。记录下我常用的插件把。 html-webpack-plugin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户可以使用模版，通过 webpack 生成 html 文件。 1.安装 1npm install html-webpack-plugin -S 2.使用 12345678910111213141516171819202122232425const path = require(&apos;path&apos;);//添加插件const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &apos;学习 webpack&apos;, template: &quot;./src/html/main.html&quot;, //模版的路径 filename: &apos;html/main.html&apos;, //生成html的文件 minify: &#123; removeAttributeQuotes: true,//去除引号 removeComments: true,//去除注释 removeEmptyAttributes: true,//去除空属性 collapseWhitespace: true//去除空格 &#125; &#125;) ]&#125; 3.注意： 当和“html-withimg-loader”一起使用时，会导致 html 文件中的类似&lt;%= htmlWebpackPlugin.options.title%&gt;无法解析。但是我们可以通过 requier 引入图片解决办法： 12//index.html&lt;img src=&quot;&lt;%= require(&apos;../image/html.png&apos;)%&gt;&quot; alt=&quot;picture&quot; /&gt; clean-webpack-plugin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加了 hash 之后，会导致改变文件内容后重新打包时，文件名不同而内容越来越多，clean-webpack-plugin可以帮助我们删除残余文件。 1.安装 1npm install clean-webpack-plugin -S 2.使用 1234567891011121314const path = require(&apos;path&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; &#125;, plugins: [ new CleanWebpackPlugin() ]&#125; BannerPlugin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加版权声明的插件 1.使用 1234567891011121314const path = require(&apos;path&apos;);const webpack = require(&apos;webpack&apos;);module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; &#125;, plugins: [ new webpack.BannerPlugin(&apos;版权所有&apos;), ]&#125; 2.效果 123//index.js/*! 版权所有 */!function(e)(); webpack.optimize.OccurenceOrderPlugin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该插件的作用是为组件分配 id，通过这个插件 webpack 会分析使用频率最多的模块，并未他们分配最小的 id，id 越小表示模块被找到的速度会更快。此为内置插件，所以不需要安装。使用 12345678910111213const webpack = require(&apos;webpack&apos;);module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; &#125;, plugins: [ new webpack.optimize.OccurrenceOrderPlugin(), ]&#125; webpack.ProvidePlugin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是一个全局挂载插件。可以自动加载模块，无需每处 import 或 require。如果项目中需要使用 jQuery 类似的工具，使用它，可以使 jquery 变成全局变量，这样在项目的任何地方都可以直接使用。它也是内置插件，不需要安装。使用 安装 jquery 依赖 1npm install jquery webpack.config.js 1234567891011121314151617const webpack = require(&apos;webpack&apos;);module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot;, &quot;window.jQuery&quot;: &quot;jquery&quot; &#125;), ]&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;webpack 的 loader 和 plugin 非常多，这里只列出了一些常用的。具体的请看官网。以上完整的 demo 在这里查看。","categories":[{"name":"工具","slug":"工具","permalink":"https://gwjacqueline.github.io/categories/工具/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"https://gwjacqueline.github.io/tags/模块化/"},{"name":"模块打包机","slug":"模块打包机","permalink":"https://gwjacqueline.github.io/tags/模块打包机/"}]},{"title":"Grid 网格布局","slug":"Grid-网格布局","date":"2019-05-04T02:32:25.000Z","updated":"2019-06-10T07:37:04.000Z","comments":true,"path":"Grid-网格布局/","link":"","permalink":"https://gwjacqueline.github.io/Grid-网格布局/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网页排版布局从最早的table,float,再到flexbox,都有很多限制，table主要是用来做表格的，float主要是用来解决浮动的，flexbox是一维布局，针对的是某一个轴线（横轴或纵轴）上的排列。而Grid是一个二维的布局，它将容器划分成行和列，产生一个个格子，再将一个个格子根据设计组成区块，它远比flexbox强大的多，也让网页布局设计变得更加简单。网格可以分为两类。一类是我们主动去定义的，比如定义了一个两行三列的表格，那么这 6 个格子就叫显性网格。另一类是系统自动产生的，比如定义了一个两行三列的表格，可是总共有 9 个格子，那么后面 3 个就叫隐性网格。接下来我将从显性网格和隐性网格这两大类去简单记录下 CSS 网格布局","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网页排版布局从最早的table,float,再到flexbox,都有很多限制，table主要是用来做表格的，float主要是用来解决浮动的，flexbox是一维布局，针对的是某一个轴线（横轴或纵轴）上的排列。而Grid是一个二维的布局，它将容器划分成行和列，产生一个个格子，再将一个个格子根据设计组成区块，它远比flexbox强大的多，也让网页布局设计变得更加简单。网格可以分为两类。一类是我们主动去定义的，比如定义了一个两行三列的表格，那么这 6 个格子就叫显性网格。另一类是系统自动产生的，比如定义了一个两行三列的表格，可是总共有 9 个格子，那么后面 3 个就叫隐性网格。接下来我将从显性网格和隐性网格这两大类去简单记录下 CSS 网格布局 显性网格建立网格1.让指定的容器(container)采用网格布局，这样直属的所有元素都会变成该网格的单元(item) 1display:grid; 如果需要设置为行内网格，则使用： 1display:inline-grid; 2.为指定的容器(container)设置栏数(column)与行数(row) 1234/* 设置栏三等分，每一栏为1fr */grid-template-columns: 1fr 1fr 1fr;/* 设置第一行为50px,第二行为100px,第三行也为50px,除了使用绝对单位，也可以使用百分比 */grid-template-rows: 50px 100px 50px; repeat()有时，写很多重复的数字会显得代码很冗余。当多次重复同样的大小时，可以使用repeat。它接受两个参数，第一个是重复的次数，第二个是大小。比如： 12//相当于grid-template-columns: 1fr 1fr 1fr;grid-template-columns: repeat(3,1fr); minmax()当我们的大小不是一个确定的值，而是一个范围的时候，就可以使用minmax.它接受两个参数，分别为最小值和最大值。 12//表示中间列宽不小于auto(表示浏览器自己决定长度)，不大于50%grid-template-columns: 200px minmax(auto, 50%) 200px; auto-fill有的时候，我们确定了单元格的大小，但是不确定容器的大小。只是希望每一行或者每一列容纳尽可能多的单元格，这个时候我们就需要使用auto-fill去自动填充。比如： 1grid-template-rows: repeat(auto-fill,50px); auto-fitauto-fit和auto-fill类似，唯一的区别就是：当容器能容纳更多的单元时，auto-fill会增加空白栏，而auto-fit会将多余的宽度平均分给每一栏去撑满容器宽度。 1grid-template-columns: repeat(auto-fit,minmax(100px,1fr)); 下图是auto-fit的展示效果,多余的空间被平均分配给了每一栏 1grid-template-columns: repeat(auto-fill,minmax(100px,1fr)); 下图是auto-fill的展示效果，自动产生了空白栏来填补多余的空间 设置间隔设置行与行的间隔 1grid-row-gap: 10px; 设置栏与栏的间隔 1grid-column-gap: 10px; 合并写法:第一个是行，第二个是栏 1grid-gap: 10px 20px; 网格线网格线分为水平网格线和垂直网格线。水平网格线划分出行，垂直网格线划分出列。正常情况下，栏线总是比栏数多一，同样的，行线也比行数多一。下图是一个 3*3 的网格，总共有 4 根栏线和 4 根行线。 网格线的命名123grid-template-columns:[c1] 100px [c2] 200px [c3] 300px [c4];//同一条线可以有多个名字，用空格隔开grid-template-rows:[r1 r1-front] 50px [r2 r1-back] 60px [r3] 这里需要注意的是：名称不能与 css 的保留字相同 定位以及合并单元格定位我们可以通过网格线将指定的单元格放到容器中指定的位置。比如，将 9 宫格的第一个单元放到最中间的单元格 123456/* 网格线中栏的起始位置从2到3*/grid-column-start: 2;grid-column-end: 3;/* 网格线中行的起始位置从2到3*/grid-row-start: 2;grid-row-end: 3; 这样就成功将第一个单元放到了最中间单元格的位置上。其他单元则会顺移一个位置。合并写法： 12grid-column: 2/3;grid-row: 2/3; 合并单元格及堆叠问题我们可以通过网格线进行单元格的合并 12grid-column:1/3;grid-row:1/3; 如果碰到两个单元格合并导致的堆叠问题，可以使用z-index解决。z-index默认为 0，数字越大，层级越高。 网格区域网格布局可以通过grid-template-areas去指定区域。比如我们可以在页面上指定一个页首、内容部分(左右布局)和页尾这样一个常用布局。 1234grid-template-areas: &apos;header header&apos; &apos;main aside&apos; &apos;footer footer&apos; 以上的代码先划分出了单元格，其中重复的部分，就是合并单元格。相当于划分出了header、main、aside、footer四个区域。这里需要注意的是：区域的命名会影响到网格线的名字。每个区域起始位置的栏线和行线都叫做区域名-start,终止区域的栏线和行线都叫做区域名-end我们可以通过grid-area给指定元素占据grid-template-areas中指定区域的位置。比如： 123#header&#123; grid-area: header;&#125; 相当于： 1234#header&#123; grid-column:header; grid-row:header;&#125; 如果没有指定区域，可以使用grid-auto-flow属性，容器的子元素会按照顺序默认放置在每个网格中，默认是先行后列。 1grid-auto-flow:row; column:先列后行row dense:先行后列，尽量不出现空格column dense:先列后行，尽量不出现空格 对齐设定通过justify-items和align-items分别对网格中的单元格进行水平方向和垂直方向的对齐。他们有以下几种常用值设定： 1234.container&#123; justify-items: start | end | center | stretch | space-around | space-between | space-evenly; align-items: start | end | center | stretch | space-around | space-between | space-evenly;&#125; 或者可以简写为： 123.container&#123; place-items: &lt;align-items&gt; &lt;justify-items&gt;;&#125; start:在水平方向靠左，在垂直方向靠上 end:在水平方向靠右，在垂直方向靠下 center:居中 stretch:拉伸，占满单元格的整个宽度 space-around:将多余的空间放在单元格左右/上下两边 space-between:将多余的空间放在单元格中间 space-between:将多余的空间平均分给全部单元格 隐性网格当一些不在我们预设范围内的网格，我们看看通过什么属性进行设置吧~ 预设行高、栏宽以及排列方式预设行高和栏宽 12grid-auto-rows: 200px;grid-auto-columns: 2fr; 预设单元格排列默认是： 1grid-auto-flow:row; 在预设的情况下，单元格会默认先排满第一行，再排满第二行以此类推。我们可以改成以栏为主： 1grid-auto-flow:column; 具体的兼容性可以查看这里,具体参考文章：文章 1、文章 2、文章 3、文章 4、文章 5、文章 6。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://gwjacqueline.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://gwjacqueline.github.io/tags/CSS/"},{"name":"Grid网格布局","slug":"Grid网格布局","permalink":"https://gwjacqueline.github.io/tags/Grid网格布局/"},{"name":"响应式网页布局","slug":"响应式网页布局","permalink":"https://gwjacqueline.github.io/tags/响应式网页布局/"}]},{"title":"移动端常见兼容性问题(二)","slug":"移动端常见兼容性问题(二)","date":"2019-04-27T07:46:46.000Z","updated":"2019-05-15T12:17:08.000Z","comments":true,"path":"移动端常见兼容性问题(二)/","link":"","permalink":"https://gwjacqueline.github.io/移动端常见兼容性问题(二)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;之前的文章写了一些移动端常见的兼容性问题，本文将继续总结一些兼容问题的解决套路。","text":"&nbsp;&nbsp;&nbsp;&nbsp;之前的文章写了一些移动端常见的兼容性问题，本文将继续总结一些兼容问题的解决套路。 fixed 定位问题 主要代码：1234567891011121314151617181920&lt;style&gt;//红框部分.city&#123; position:fixed; top:50px; height:300px; overflow:auto; -webkit-overflow-scrolling:touch; z-index:100;&#125;&lt;/style&gt;&lt;body&gt; //绝对定位 &lt;header&gt;&lt;/header&gt; //下半部分绝对定位 &lt;div&gt; //红框部分 &lt;div class=&quot;city&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; bug 描述：1.在安卓机上，红框部分，超过的文字，无法通过滑动查看 2.在 ios 上，红框部分会随下半部分一起滚动。 bug 解决：123456789101112131415161718192021&lt;style&gt;//红框部分.city&#123; position:fixed; top:50px; //把高度去掉，改为Bottom bottom:50px; overflow:auto; -webkit-overflow-scrolling:touch; z-index:100;&#125;&lt;/style&gt;&lt;body&gt; //绝对定位 &lt;header&gt;&lt;/header&gt; //下半部分绝对定位 &lt;div&gt; &lt;/div&gt; //将红框部分移出 &lt;div class=&quot;city&quot;&gt;&lt;/div&gt;&lt;/body&gt; ios 后台倒计时停止主要代码：12345678var count = 30;var inter = setInterval(clock, 1000);function clock() &#123; count-- if (count &lt; 1) &#123; clearInterval(inter); &#125;&#125; bug 描述：ios 切换到后台程序后，倒计时就停止了 bug 解决：12345678910111213var old = new Date().getTime();var count = 30;var inter = setInterval(clock, 1000);function clock() &#123; //计时器实时计算当前时间 var now = new Date().getTime(); var count = 30 - Math.floor((parseInt(now) - parseInt(old)) / 1000); $(&quot;.clock&quot;).html(count); if (count &lt; 1) &#123; clearInterval(inter); &#125;&#125; 采用实时计算时间差的方式解决，具体效果可看倒计时测试 ios input disabled 灰色 bug 描述：ios 下输入框为 disabled 时，默认字体为灰色 bug 解决：123input:disabled,textarea:disabled&#123; -webkit-opacity:1;&#125; 华为、小米键盘遮住输入框主要代码：12345678910111213141516171819&lt;style&gt;body&#123; height:100%;&#125;.main&#123; top:0; bottom:0; left:0; right:0; background-image:cover; overflow:auto; position:absolute;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;main&quot;&gt; //里面的所有输入框为自然布局 &lt;/div&gt;&lt;/body&gt; bug 描述：点击页面较下面的输入框，键盘会遮挡输入框，且无法上拉页面。 bug 解决：方法 1：可以上拉页面看到输入框 1234567&lt;style&gt;.main&#123; height:100%; background-image:cover; overflow:auto;&#125;&lt;/style&gt; 方法 2：可以自动顶起输入框 123456789101112131415161718(function()&#123; var screenH=$(document).height(); $(&apos;input&apos;).focus(function()&#123; var top = $(this).offset().top; var h=$(this).height(); if(top+h&gt;screenH/2)&#123; var scrollTop = $(&quot;滚动主体&quot;).scrollTop(); $(&quot;滚动主体&quot;).append(&quot;&lt;div class=&apos;addHeight&apos;&gt;&lt;/div&gt;&quot;); $(&quot;.addHeight&quot;).css(&apos;padding-bottom&apos;,screenH/2+&apos;px&apos;); $(&quot;滚动主体&quot;).scrollTop(screenH/2+screenTop-20); &#125; &#125;); $(&apos;input&apos;).blur(function()&#123; if($(&quot;.addHeight&quot;).length&gt;0)&#123; $(&quot;.addHeight&quot;).remove(); &#125; &#125;);&#125;)(); ios 键盘挡住输入框 主要代码：12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; header &#123; height: 50px; background-color: red; top: 0; bottom: 0; left: 0; right: 0; position: absolute; &#125; .content &#123; top: 50px; left: 0; right: 0; bottom: 0; padding-bottom: 50px; overflow: auto; position: absolute; background-color: green; &#125; .bottom &#123; position: fixed; bottom: 0; left: 0; right: 0; height: 50px; background-color: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;header&gt;头部&lt;/header&gt; &lt;div class=&quot;content&quot;&gt; &lt;input type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;我是固定在底部的按钮&lt;/div&gt;&lt;/body&gt; bug 描述：点击图中圈出的黄色输入框，键盘会遮住输入框，无法上弹 bug 解决：123456789101112&lt;style&gt; .content &#123; top: 50px; left: 0; right: 0; bottom: 50px; &lt;!-- padding-bottom: 50px; --&gt; overflow: auto; position: absolute; background-color: green; &#125;&lt;/style&gt; 部分 Ios 手机不支持 css:focus:validbug 描述：当给输入框加属性 required 的时候，用:focus:valid 加样式，部分手机不支持。但是单独支持:focus/:valid。 bug 解决：用 js 判断，加样式。 ios 光标上下飘 1234滚动部分&#123; -webkit-overflow-scrolling:touch; overflow:auto;&#125; bug 描述：当两个样式并存时，拖动正在输入的页面，光标就会上下飘动。 bug 解决：目前找到原因是因为这两个样式并存会导致。目前没有找到好的解决办法 IOS 点击闪屏问题bug 描述：点击页面，会出现闪屏现象 bug 解决：123html,body&#123; -webkit-tap-highlight-color: transparent;&#125;","categories":[{"name":"css","slug":"css","permalink":"https://gwjacqueline.github.io/categories/css/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://gwjacqueline.github.io/tags/移动端/"},{"name":"兼容性","slug":"兼容性","permalink":"https://gwjacqueline.github.io/tags/兼容性/"}]},{"title":"js/jq封装插件的套路","slug":"js-jq封装插件的套路","date":"2019-04-26T07:05:38.000Z","updated":"2019-05-13T01:24:55.000Z","comments":true,"path":"js-jq封装插件的套路/","link":"","permalink":"https://gwjacqueline.github.io/js-jq封装插件的套路/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们小组这周分享了有关于“js 插件封装的方法”。颇有心得，就整理出了一套封装插件的固定模板公式，简称套路，百试百灵。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们小组这周分享了有关于“js 插件封装的方法”。颇有心得，就整理出了一套封装插件的固定模板公式，简称套路，百试百灵。 好插件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们先来说说怎么样封装插件，才叫一个好插件。它需要满足以下几点： 1.代码能够很好的复用2.插件自身的作用域要与用户当前的作用域相互独立，避免各个相同功能组件的干扰3.插件有默认参数且支持使用者修改4.需提供针对事件的监听接口，便于使用者使用5.支持链式调用6.便于维护 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说完了一个好插件应该具备的条件，接下来我们通过 js 和 jquery 两种方式通过实现简单加减乘除的运算来总结一下插件封装的套路把。 JS插件最外层123;(function (global, undefined) &#123; &quot;use strict&quot;;&#125;)(this) 1.在最前面加了” ; “是为了防止跟其他 js 压缩时报错。 2.因为 JS 变量的调用，从全局作用域上查找速度会比私有作用域里慢的多，所以我们需要用闭包的方式。封装的时候把 js 代码放到一个自执行函数里，不仅可以延长插件内部变量的生命周期，让插件可以重复调用，还可以防止变量冲突。 3.使用严格模式，它是一种特殊的执行模式，可以修复部分语言上的不足，提供更强的错误检查，并增强安全性。4.undefined 是为了兼容较老的浏览器。最后传 this，而不是 window 或者 global，是因为不确定我们的兼容浏览器端和非浏览器端。直接取全局变量 this 作为局部变量使用，可缩短访问时间。 创建构造函数并初始化变量1234567891011121314151617;(function (global, undefined) &#123; &quot;use strict&quot;; //定义一个类，通常首字母大写 var Cal = function (options) &#123; //传参 this.options = $.extend(&#123;&#125;, Cal.DEFAULTS, options || &#123;&#125;); //在初始化执行一些操作 this.init(); &#125;; //默认参数列表 Cal.DEFAULTS = &#123; x: 1, y: 2 &#125;; //把这个函数暴露给外部，以便全局调用 global.Cal = Cal;&#125;)(this) 1.利用 \\$ .extend 用来合并默认参数和用户传进来的参数 \\$.extend( [deep ], target, object1 [, objectN ] )deep:可选，默认为 false.如果该值为 true，且多个对象的某个同名属性也都是对象，则该”属性对象”的属性也将进行合并target:Object 类型 目标对象，其他对象的成员属性将被附加到该对象上。object1:可选。Object 类型 第一个被合并的对象。objectN:可选。Object 类型 第 N 个被合并的对象。 12345678910111213141516var item1 = &#123; name: &quot;Lili&quot;, age: 14, sex: &quot;girl&quot;, address: &#123; pro: &quot;cc&quot; &#125;&#125;;var item2 = &#123; name: &quot;Lucy&quot;, age: 18, address: &#123; pro: &quot;zh&quot;, city: &quot;x&quot; &#125;&#125;;//默认为falsevar result = $.extend(false,item2, item1);var resultTrue = $.extend(true, &#123;&#125;, item2, item1);console.log(result); //&#123;name: &quot;Lili&quot;, age: 14, sex: &quot;girl&quot;,address: &#123;pro: &quot;cc&quot;&#125;&#125;console.log(resultTrue); //&#123;name: &quot;Lili&quot;, age: 14, sex: &quot;girl&quot;, address: &#123;pro: &quot;zh&quot;, city: &quot;x&quot;&#125;&#125; 2.插件的定义和执行都在闭包中，所以他们的作用域也就是这个闭包函数，只有绑定到全局对象上，我们才可以调用。 利用原型链12345678910111213141516171819//原型链上提供方法Cal.prototype = &#123; //定义方法 init() &#123; console.log(`你输入的两个参数分别为$&#123;this.options.x&#125;,$&#123;this.options.y&#125;`); &#125;, add() &#123; return `计算结果为$&#123;this.options.x + this.options.y&#125;` &#125;, sub() &#123; return `计算结果为$&#123;this.options.x - this.options.y&#125;` &#125;, rid() &#123; return `计算结果为$&#123;this.options.x * this.options.y&#125;` &#125;, div() &#123; return `计算结果为$&#123;this.options.x / this.options.y&#125;` &#125;&#125;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 js 中，所有对象都是继承自原型的，所以对象都有一个proto的内置属性用于指向创建它的函数对象的原型对象 prototype。有关与原型链和继承的问题，可以看看之前的文章。一般我们都将方法写在原型里，将属性写在构造函数里。因为方法写在原型中比写在构造函数中消耗的内存更小，因为在内存中一个类的原型只有一个，写在原型中的行为可以被所有实例共享，实例化的时候并不会在实例的内存中再复制一份。而写在类中的方法，实例化的时候会在每个实例中再复制一份，所以消耗的内存更高。 兼容多种模块规范12345678//兼容CommonJs规范if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123; module.exports = Cal;&#125;;//兼容AMD/CMD规范if (typeof define === &apos;function&apos;) define(function () &#123; return Cal;&#125;); 完整套路123456789101112131415161718192021222324252627282930;(function (global, undefined) &#123; //使用严格模式 &quot;use strict&quot;; //创建一个构造函数 var X = function (options) &#123; //合并参数 this.options = $.extend(&#123;&#125;, X.DEFAULTS, options || &#123;&#125;); &#125;; X.DEFAULTS = &#123; //默认参数 &#125;; //原型链上提供方法 X.prototype = &#123; //定义方法 &#125;; //兼容CommonJs规范 if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123; module.exports = X; &#125;; //兼容AMD/CMD规范 if (typeof define === &apos;function&apos;) define(function () &#123; return X; &#125;); //暴露给外部 global.X = X;&#125;)(this)//调用new X(&#123; //参数&#125;); 改写 ES6123456789101112131415161718192021222324252627282930313233343536373839404142434445(function (global, undefined) &#123; //检测传入的参数类型是否为对象，若不是则抛出错误 if (arguments.length &gt; 0 &amp;&amp; (typeof options).toLowerCase() !== &apos;object&apos;) &#123; throw new TypeError(options + &apos;is not a Object&apos;); &#125; //定义了一个名字为Cal的类 class Cal &#123; //constructor是一个构造方法，用来接收参数 constructor(options) &#123; //传入参数覆盖默认值 //this代表的是实例对象 this.options = Object.assign(&#123; x: 1, y: 2 &#125;, options); this.init(); &#125; //这是一个类的方法，注意千万不要加上function init() &#123; console.log(`你输入的两个参数分别为$&#123;this.options.x&#125;,$&#123;this.options.y&#125;`); &#125; //方法之间不要用逗号分隔，否则会报错 add() &#123; return `计算结果为$&#123;this.options.x + this.options.y&#125;` &#125; sub() &#123; return `计算结果为$&#123;this.options.x - this.options.y&#125;` &#125; rid() &#123; return `计算结果为$&#123;this.options.x * this.options.y&#125;` &#125; div() &#123; return `计算结果为$&#123;this.options.x / this.options.y&#125;` &#125; &#125; global.Cal = Cal;&#125;)(this);var t = new Cal(&#123; x: 5, y: 6&#125;);console.log(t.add()); //计算结果为11console.log(t.sub()); //计算结果为-1console.log(t.rid()); //计算结果为30console.log(t.div()); //计算结果为0.8333333333333334 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明显看出，ES6 中新引入了 class 关键字可以定义类。相比于 ES5，不仅代码量少了很多，写法上也更加清晰，更像是一种面向对象的语言。类自身指向的就是构造函数，所以我们可以当 class 其实是构造函数的另外一种写法。constructor 方法是类的构造函数的默认方法，当我们通过 new 生成对象实例时，会自动调用该方法。如果 construtor 方法没有显示定义，会隐式生成一个 constructor 方法且默认返回实例对象 this。constructor 中定义的属性为实例属性，也就是定义在 this 对象上的。constructor 外声明的属性是定义的原型上的。这里在书写的时候要注意两点：1.写一个类的方法，注意不要加上 function2.方法之间不要用逗号分隔 JQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接下来我们通过 jQ 的两种使用方法 jQuery.function() 和 jQuery(“selector”)来看看如何用 jq 封装插件。 jQuery.fn1234567891011121314151617181920212223242526//利用闭包创建一个自执行的函数(function ($) &#123; &quot;use strict&quot;; function Cal(element, options) &#123; this.$element = $(element); this.options = $.extend(&#123;&#125;, Cal.DEFAULTS, options || &#123;&#125;); &#125; function Plugin(option) &#123; var args = Array.prototype.slice.call(arguments, 1); //链式调用 return this.each(function () &#123; //单例模式 var $this = $(this), cal = $this.data(&apos;cal&apos;); if (!cal) &#123; $this.data(&apos;cal&apos;, (cal = new Cal(this, option))); &#125; if (typeof option == &apos;string&apos;) &#123; cal[option] &amp;&amp; cal[option].apply(cal, args); &#125; &#125;); &#125; $.fn.Cal = Plugin;&#125;)(jquery); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上我们将之前写的 JS 插件改写成了 jquery 的形式。通过运用面向对象的思维方式，在 jquery 的原型上扩展方法。1.链式调用：return.this:返回当前对象，来维护插件的链式调用.each: 循环实现每个元素的访问2.单例模式利用 data 来存放插件对象的实例，如果实例存在，则不再重新创建 完整套路12345678910111213141516171819202122232425262728293031323334353637//利用闭包创建一个自执行的函数(function () &#123; //使用严格模式 &quot;use strict&quot;; //定义一个类 function X(element, options) &#123; this.$element = $(element); this.options = $.extend(&#123;&#125;, Cal.DEFAULTS, options || &#123;&#125;); &#125; X.DEFAULTS = &#123; //默认参数 &#125;; //原型链上提供方法 X.prototype = &#123; //定义方法 &#125;; function Plugin(option) &#123; var args = Array.prototype.slice.call(arguments, 1); //链式调用 return this.each(function () &#123; //单例模式 var $this = $(this), x = $this.data(&apos;x&apos;); if (!x) &#123; $this.data(&apos;x&apos;, (x = new X(this, option))); &#125; if (typeof option == &apos;string&apos;) &#123; x[option] &amp;&amp; x[option].apply(x, args); &#125; &#125;); &#125; $.fn.X = Plugin;&#125;)();//调用插件$(&quot;selector&quot;).X(); jQuery.extend()1234567$.extend(&#123; x: function () &#123; &#125;&#125;);//调用方式$.x(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQuery.extend()在上面已经详细说了用法。这种一般是为扩展 jQuery 类本身，为类添加新的方法，所以不需要生成实例，可以直接通过\\$符号调用。一般很少用这种方式封装插件。","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"},{"name":"jq","slug":"js/jq","permalink":"https://gwjacqueline.github.io/categories/js/jq/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://gwjacqueline.github.io/tags/面向对象/"},{"name":"原型链","slug":"原型链","permalink":"https://gwjacqueline.github.io/tags/原型链/"},{"name":"继承","slug":"继承","permalink":"https://gwjacqueline.github.io/tags/继承/"}]},{"title":"JS异步编程的那些事(二)","slug":"JS异步编程的那些事(二)","date":"2019-04-20T07:30:26.000Z","updated":"2019-05-16T05:31:45.000Z","comments":true,"path":"JS异步编程的那些事(二)/","link":"","permalink":"https://gwjacqueline.github.io/JS异步编程的那些事(二)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上篇文章说完了 Promise 对象、fetch 方法。这篇我们接着说说 ES7 中丢出的语法糖，”异步终极解决方法 Async/await“。以及分别用 fetch 和 Async/await 去封装一个增删改查的库。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上篇文章说完了 Promise 对象、fetch 方法。这篇我们接着说说 ES7 中丢出的语法糖，”异步终极解决方法 Async/await“。以及分别用 fetch 和 Async/await 去封装一个增删改查的库。 Async/await&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async 和 await 是 js 中异步最终极的解决方案。可以很舒适地与 promise 协同工作。但兼容一般，我们可以用 polyfill(js 修补器)兼容一下，polyfill 是一个 js 库、专门用于处理 js 的兼容性问题。但是确实很难做到 100%覆盖。我们先来看看 async 的用法。 Async/await 用法显而易见这是一个普通到不行的函数 1234function myFunc() &#123; return &quot;Hello world&quot;;&#125;console.log(myFunc()); //Hello world 我们来看看加了 async 之后呢？ 1234async function myAsync() &#123; return &quot;Hello world&quot;&#125;console.log(myAsync()); //Promise &#123;&lt;resolved&gt;: &quot;Hello world&quot;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到了吗？在函数前面加了 async(异步) 关键字，就表示该函数是异步函数。这个函数就会返回一个 Promise，且代码中有 return 语句非 Promise 语句时，JS 就会自动的把 return 中的”Hello world“包装成 Promise 的 resolved 值。语法是不是敲极的简单呢？接下来我们看看 await 是如何搭配 Async 一起使用的呢。 123456789101112131415161718async function asyncWait() &#123; const pro = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;hello world&quot;) &#125;, 2000); &#125;); const error = false; if (error) &#123; await Promise.reject(new Error(&quot;报错了&quot;)); &#125; else &#123; //等待pro执行完毕后才会执行 const res = await pro; return res; &#125;&#125;asyncWait().then((data) =&gt; &#123; console.log(data); //Hello world&#125;).catch((err) =&gt; &#123; console.log(err);&#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在 async 声明的函数体内，使用了 await 关键字。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成之后，再去执行函数体内后面的语句。这里要注意的是:不能在常规函数里使用 await,否则会出现语法错误。await 和 async 就好比一对连体婴。await 只能在 async 函数中工作。我们来看看如果不使用 await 会有什么效果。 123456async function please() &#123; const response = fetch(&quot;http://jsonplaceholder.typicode.com/posts&quot;); const data = response.json(); //response.json is not a function return data;&#125;please().then(data =&gt; console.log(data)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上代码控制台中报错：response.json is not a function。我们看到没有在 await,下面的 response.json()就会报错，因为 response 还没有执行完。如果加了 await，就会在当前请求成功后再往下走。await 表示等一下，只有当 await 定义的行数执行完毕后代码才会继续往下执行。大多情况下 await 后面的应该跟一个 Promise 的对象或者 fetch。我们看看加了 await 关键词后的执行效果。 123456async function please() &#123; const response = await fetch(&quot;http://jsonplaceholder.typicode.com/posts&quot;); const data = await response.json(); return data;&#125;please().then(data =&gt; console.log(data)); (100) [&#123;…&#125;, &#123;…&#125;,...] 封装增删改查方法fetch 库&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完整的代码已经上传到我的github 仓库。以下将记录 fetch 封装增删改查的关键代码。 查看数据12345678910111213141516171819class EasyHttp &#123; get(url) &#123; return new Promise((resolve, reject) =&gt; &#123; fetch(url) .then((res) =&gt; res.json()) .then((data) =&gt; &#123; resolve(data) &#125;) .catch(err =&gt; &#123; reject(err) &#125;); &#125;); &#125;&#125;//调用方式const http = new EasyHttp;http.get(&quot;data/test.json&quot;) .then((data) =&gt; &#123; console.log(data); //(6) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;] &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;); 增加数据1234567891011121314151617post(url, data) &#123; return new Promise((resolve, reject) =&gt; &#123; fetch(url, &#123; //发送请求方法,一般用大写 method: &apos;POST&apos;, //http的头信息 headers: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, //请求体,将对象转成字符串 body: JSON.stringify(data) &#125;) .then(res =&gt; res.json()) .then(data =&gt; resolve(data)) .catch(err =&gt; reject(err)) &#125;);&#125; 修改数据12345678910111213put(url, data) &#123; return new Promise((resolve, reject) =&gt; &#123; fetch(url, &#123; method: &apos;PUT&apos;, headers: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, body: JSON.stringify(data) &#125;).then(res =&gt; res.json()) .then(data =&gt; resolve(data)) .catch(err =&gt; reject(err)) &#125;);&#125; 删除数据123456789101112delete(url) &#123; return new Promise((resolve, reject) =&gt; &#123; fetch(url, &#123; method: &apos;DELETE&apos;, headers: &#123; &apos;Content-type&apos;: &apos;application/json&apos; &#125; &#125;).then(res =&gt; res.json()) .then(data =&gt; resolve(&quot;删除成功&quot;)) .catch(err =&gt; reject(err)); &#125;);&#125;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看完了 fetch 的写法，接下来我们看看如何用 async/await 如何更优雅的实现。 async/await 封装查看数据123456async get(url) &#123; const response = await fetch(url); //将Promise对象转成json对象 const data = await response.json(); return data;&#125; 增加数据1234567891011async post(url, data) &#123; const response = await fetch(url, &#123; method: &apos;POST&apos;, headers: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, body: JSON.stringify(data) &#125;); const postData = await response.json(); return postData;&#125; 修改数据1234567891011async put(url, data) &#123; const response = await fetch(url, &#123; method: &apos;PUT&apos;, headers: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, body: JSON.stringify(data) &#125;); const putData = await response.json(); return putData;&#125; 删除数据12345678910async delete(url) &#123; const response = await fetch(url, &#123; method: &apos;DELETE&apos;, headers: &#123; &apos;Content-type&apos;: &apos;application/json&apos; &#125; &#125;); const deleteData = await &quot;成功删除数据&quot;; return deleteData;&#125;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从代码量上，我们可以显而易见的对比出 async/await 代码量明显少很多，我们不再需要书写 Promise 了。也不需要那么多的.then.then,代码看上去更加优雅，编写出的异步代码更易于读写。只要加一个 async，一个函数就可以作为 promise 对象返回回去 ,等待 resolve 执行完毕后，再去实行。让我们书写异步代码的时候像同步的方式一样舒畅。用 async/await 编写的异步代码更简单易懂，从视觉上就能感觉到复杂度降低了。","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://gwjacqueline.github.io/tags/ES6/"},{"name":"ES7","slug":"ES7","permalink":"https://gwjacqueline.github.io/tags/ES7/"},{"name":"异步","slug":"异步","permalink":"https://gwjacqueline.github.io/tags/异步/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"https://gwjacqueline.github.io/tags/XMLHttpRequest/"},{"name":"promise","slug":"promise","permalink":"https://gwjacqueline.github.io/tags/promise/"},{"name":"fetch","slug":"fetch","permalink":"https://gwjacqueline.github.io/tags/fetch/"}]},{"title":"JS异步编程的那些事(一)","slug":"JS异步编程的那些事(一)","date":"2019-04-18T13:31:33.000Z","updated":"2019-05-16T05:31:42.000Z","comments":true,"path":"JS异步编程的那些事(一)/","link":"","permalink":"https://gwjacqueline.github.io/JS异步编程的那些事(一)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从最早的回调函数，之后迎来了 promise,再次就是上篇文章说的 generator，js 解决异步的方案一次次的再优化，ES7 中出现的 Async/await 是目前 js 中异步最终极的解决方案，我的妈耶不谈兼容问题的话，实在是太好用啦。虽然兼容性真的很一般，但是我们可以用 polyfill(js 修补器)去兼容一下呀。接下来我将简单介绍下 Promise、fetch、 Async/await 以及分别用 fetch 和 Async/await 去封装一个增删改查的方法。来看看编写异步代码的过程是如何一步步变得优雅起来的。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从最早的回调函数，之后迎来了 promise,再次就是上篇文章说的 generator，js 解决异步的方案一次次的再优化，ES7 中出现的 Async/await 是目前 js 中异步最终极的解决方案，我的妈耶不谈兼容问题的话，实在是太好用啦。虽然兼容性真的很一般，但是我们可以用 polyfill(js 修补器)去兼容一下呀。接下来我将简单介绍下 Promise、fetch、 Async/await 以及分别用 fetch 和 Async/await 去封装一个增删改查的方法。来看看编写异步代码的过程是如何一步步变得优雅起来的。 Promise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们先来说说 Promise 吧~在 ES6 之前处理异步问题时，我们为了避免操作时的页面中断，通过都是使用回调函数，这时候如果回调函数当中又有回调函数，那么我们就会陷入无尽的回调地狱，代码也变得很难维护。而有了 Promise 对象后，我们就可以很好的解决这个问题，用它的链式调用就可以用同步函数的方式去写异步代码了。简直是造福程序员界一项很牛逼的东西。接下来我们创建一个 Promise 实例。 12let promise = new Promise();console.log(promise); //Uncaught TypeError: Promise resolver undefined is not a functionat new Promise &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：Promise 构造函数一定要传回调才可以，否则会报错。它接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。 123let promise = new Promise((resolve, reject) =&gt; &#123;&#125;);console.log(promise); //Promise &#123;&lt;pending&gt;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到打印出来的是Promise{ &lt; pending &gt; },表示任务在进行中。接下来我将用一张图来看看 Promise 的三种状态和对应的回调。 Promise 的三种状态和对应的回调 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然这张图我画的有点丑，但是应该也很简单明了的看懂Promise的三种状态，其中我们基本上运用的是resolved和resolved两种状态。123456789101112131415let promise = new Promise((resolve, reject) =&gt; &#123; if (/* 异步操作成功*/) &#123; resolve(); &#125; else &#123; /* 操作失败 */ //reject(); &#125; &#125;);promise.then(() =&gt; &#123; console.log(&quot;成功，没有任何问题&quot;); //成功，没有任何问题&#125;).then(() =&gt; &#123; console.log(&quot;成功，想调几次就调几次&quot;);&#125;).catch(() =&gt; &#123; console.log(&quot;执行失败方法&quot;);&#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到，只要前面的reject()成功，后续想调用几个then()方法都可以，这样就不仅仅有一个回调了，有n个回调在等着你。如果异步操作失败了，Promise的转态就会变为rejected，去调用catch方法指定的回调函数处理这个错误。另外，then方法指定的回调函数，如果在运行过程中抛出了错误，也会被catch方法捕获。这里要注意的是：catch返回码超过300就不会打印 Promise 对象特点1.对象的状态是不受外界影响的 只有异步操作的结果，才可以决定当前是哪一种状态，任何其他的操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 12345678910111213let fulfill = new Promise((resolve,reject) =&gt; &#123; resolve(&apos;success&apos;); console.log(&apos;resolve before&apos;); reject(&apos;error&apos;);&#125;);fulfill.then(data =&gt; &#123; console.log(data);&#125;);fulfill.catch(msg =&gt; &#123; console.log(msg);&#125;) 2.一旦转态改变，转态就会凝固，不再改变 最后的打印结果为：resolve beforesuccessresolve 下一句语句是可以执行的，为什么 reject 没有去调用 catch 指定的回调函数呢？这就是因为 Promise 对象的特点：状态的凝固。这个对象从起始的 Pending 状态在根据 resolve 或 reject 返回 Resolved 或 Rejected 状态。 fetch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch 是一个基于 promise 的请求方法，更简单便捷。相比与原先在不同浏览器中使用 XMLHttpRequest 对象或者是 ActiveXObject(“x.XMLHTTP”)，fetch 方法简化了这一操作。接下来我们用代码看看 fetch 是如何让代码优雅起来的。 fetch 如何优雅于 XMLHttpRequest123456789101112131415//XMLHttpRequestvar xml = new XMLHttpRequest;//调用请求xml.open(&apos;GET&apos;, &apos;http://jsonplaceholder.typicode.com/postst&apos;);//发送到服务器上xml.send();//监听响应情况xml.onreadystatechange = function () &#123; //响应成功事件 if (this.readyState === 4 &amp;&amp; xml.status === 200) &#123; console.log(xml.responseXML); &#125; else &#123; console.log(&quot;发生错误：&quot;, xmlJson.status); &#125;&#125;; 123456//fetchlet url = &quot;http://jsonplaceholder.typicode.com/posts&quot;;fetch(url) .then((res) =&gt; &#123; console.log(res); //Response &#123;type: &quot;cors&quot;, url: &quot;http://jsonplaceholder.typicode.com/ posts&quot;, redirected: false, status: 200, ok: true, …&#125; &#125;).catch();; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从代码上很直观的能看出代码量的减少。fetch 方法返回的是一个 Promise 对象,所以我们可以链式的发起异步请求。http://jsonplaceholder.typicode.com 这个是我做测试经常会用到的网址。从上面的例子可以看出使用 fetch 时第一步 then 返回的是 response 对象。我们需要使用json()方法将将请求回来的 response 对象解析成我们正常可读的对象。这里要注意的是：目前原生的 fetch 还不支持 jsonp 的请求方式，如果需要实现 jsonp，需要安装 npm 包 fetchJ-jsonp 123456789let url = &quot;http://jsonplaceholder.typicode.com/posts&quot;;fetch(url).then((res) =&gt;//将请求回来的 response 对象解析成我们正常可读的对象res.json()).then((data) =&gt; &#123;console.log(data);&#125;).catch();; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在 response 对象上调用 json()方法，返回的依然是一个 Promise 对象，我们需要在下一步的 then()中获得服务器返回的原始对象。接下来我们去请求一个根本没有的域名，模拟一下 catch。 12345let errurl = &quot;http://jsonplaceholder.typicode12345.com/posts&quot;;fetch(errurl).then(() =&gt; console.log(&quot;成功&quot;)).catch((error) =&gt; console.log(`错误信息：$&#123;error&#125;`));//错误信息：TypeError: Failed to fetch fetch 请求三种数据格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们来实践下如何用 fetch 请求 本地文本数据,本地 json 数据 还有网络接口吧。具体的代码实现效果可以看看实现效果。其中请求本地文本数据采用了 XMLHttpRequest 和 fetch 两种方式。这里展示一部分重要代码。样式没有特意去优化，用的是一个超简单的响应式模板 skeleton。 请求本地文本数据 12345678910function getText() &#123; fetch(&quot;data/test.txt&quot;) //将 response 对象解析 .then((res) =&gt; res.text()) .then((data) =&gt; &#123; console.log(data); //变瘦瘦变美美 document.getElementById(&quot;output&quot;).innerHTML = data; &#125;) .catch(() =&gt; &#123; console.log(&quot;获取失败&quot;) &#125;);&#125; 请求本地 json 数据 123456789101112131415161718function getJson() &#123; fetch(&quot;data/test.json&quot;) .then(res =&gt; res.json()) .then((data) =&gt; &#123; console.log(data);//(6) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;] let outPut = &apos;&apos;; //使用forEach方法遍历数据 data.forEach((x) =&gt; &#123; outPut += ` id:$&#123;x.id&#125;&lt;br&gt; title:$&#123;x.title&#125;&lt;br&gt; body:$&#123;x.body&#125;&lt;br&gt; ` &#125;); document.getElementById(&quot;output&quot;).innerHTML = outPut; &#125;) .catch(() =&gt; &#123; console.log(&quot;获取失败&quot;) &#125;); &#125; 请求网络接口 12345678910111213141516function getWeb() &#123; let weburl = &quot;https://api.github.com/users&quot;; fetch(weburl) .then((res) =&gt; res.json()) .then((data) =&gt; &#123; console.log(data); let webData = &apos;&apos;; data.forEach((x) =&gt; &#123; webData += `loginName:$&#123;x.login&#125;&lt;br&gt;` &#125;); document.getElementById(&quot;output&quot;).innerHTML = webData; &#125;) .catch(() =&gt; &#123; console.log(&quot;获取失败&quot;); &#125;);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇主要介绍记录了 Promise 对象，fetch 如何优雅于 XMLHttpRequest，以及如何用 fetch 请求三种数据数据格式。下一篇中，我们将用 fetch 去封装一个增删改查的方法，以及记录下 JS 最终极的异步解决方案 Async/awai。","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://gwjacqueline.github.io/tags/ES6/"},{"name":"ES7","slug":"ES7","permalink":"https://gwjacqueline.github.io/tags/ES7/"},{"name":"异步","slug":"异步","permalink":"https://gwjacqueline.github.io/tags/异步/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"https://gwjacqueline.github.io/tags/XMLHttpRequest/"},{"name":"promise","slug":"promise","permalink":"https://gwjacqueline.github.io/tags/promise/"},{"name":"fetch","slug":"fetch","permalink":"https://gwjacqueline.github.io/tags/fetch/"}]},{"title":"generator生成器","slug":"generator生成器","date":"2019-04-13T11:31:01.000Z","updated":"2019-04-13T14:44:14.000Z","comments":true,"path":"generator生成器/","link":"","permalink":"https://gwjacqueline.github.io/generator生成器/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generator 生成器是 ES6 提供主要用来解决异步编程深度嵌套的问题。generator 和其他函数不同的是：一般的函数只有一次返回值，generator 可以返回多次值。我们可以把它理解为一个函数内部状态的遍历器，我们每执行一次，函数的内部的状态就会发生一次改变。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generator 生成器是 ES6 提供主要用来解决异步编程深度嵌套的问题。generator 和其他函数不同的是：一般的函数只有一次返回值，generator 可以返回多次值。我们可以把它理解为一个函数内部状态的遍历器，我们每执行一次，函数的内部的状态就会发生一次改变。 定义及调用定义：12345function* gen() &#123; yield &quot;Lucy&quot;; yield &quot;DaMing&quot;; return &quot;OK&quot;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generator 在形态上与普通函数有两点区别：一是，function 和函数名之间有一个”*“号；二是，函数体内部使用 yield(产出)语句，定义函数内部不同的状态。yield 关键字用来暂停和继续一个生成器函数,我们可以在需要的时候控制函数的运行。yield 语句的特点是必须等上一条 yield 语句执行完毕才会执行下一条 yield 语句。这样的好处是可以帮助我们用同步的方式写异步代码。避免陷入回调地狱。 调用：12345console.log(gen()); //gen &#123;&lt;suspended&gt;&#125;console.log(g1.next()); //&#123;value: &quot;Lucy&quot;, done: false&#125;console.log(g1.next()); //&#123;value: &quot;DaMing&quot;, done: false&#125;console.log(g1.next()); //&#123;value: &quot;OK&quot;, done: true&#125;console.log(g1.next()); //&#123;value: undefined, done: true&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们看到控制台将 gen()直接打印出来，是一个 Iterator 实例，然后我们再去执行 Iterator 实例的 next()方法，那么这个函数才开始真正运行，并把 yield 后面的值包装成固定对象的并返回，遇到 return 或者函数结束没有更多的值返回时,再返回 undefined。也就是函数在执行过程中的时候，如果没有遇到 return 语句或者没有 return 时，控制权无法交回被调用的代码。 返回多个值的函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回多个值有什么用？斐波那契数列就是一个很好的例子。接下来，我们分别用普通函数和 generator 生成器看下是怎么实现一个产生斐波那契数列的函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;斐波那契数列：前两个值相加等于第三个值，再前面两个值相加等于后面的值（比如：0，1，1，2，3，5） 普通函数: 123456789function fb(max) &#123; let a = 0, b = 1, arr = [0, 1]; while (arr.length &lt; max) &#123; [a, b] = [b, a + b]; arr.push(b); &#125; return arr;&#125;console.log(fb(6)); //[0, 1, 1, 2, 3, 5] generator: 12345678910111213141516function* fb(max) &#123; let a = 0, b = 1, n = 0; while (n &lt; max) &#123; yield a; [a, b] = [b, a + b]; n++; &#125; return;&#125;var f = fb(5);console.log(f.next()); //&#123;value: 0, done: false&#125;console.log(f.next()); //&#123;value: 1, done: false&#125;console.log(f.next()); //&#123;value: 1, done: false&#125;console.log(f.next()); //&#123;value: 2, done: false&#125;console.log(f.next()); //&#123;value: 3, done: false&#125;console.log(f.next()); //&#123;value: undefined, done: false&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到以上都是采用手动调用的方式，非常的麻烦，接下来我们看下怎么能够实现自动遍历。 自动遍历 generatorfor..of&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterate 是一个迭代器，只要是迭代器就可以循环输出，for…of 循环可以自动遍历 Generator 函数生成的 Iterator 对象。但是，return 的东西不会遍历，主要遍历 yield 的东西。 12345678910function* gen() &#123; yield &quot;Lucy&quot;; yield &quot;DaMing&quot;; return &quot;OK&quot;&#125;let g1 = gen();//for..of遍历for (var item of gen(3)) &#123; console.log(item); //Lucy,DaMing&#125; 解构赋值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解构解的是 yield 的值 1234567891011function* gen() &#123; yield &quot;Lucy&quot;; yield &quot;DaMing&quot;; return &quot;OK&quot;&#125;let g1 = gen();//解构赋值const [a, b, c] = gen();console.log(a, b, c); //Lucy DaMing undefinedconst [x, ...y] = gen();console.log(x, y); //Lucy [&quot;DaMing&quot;] 扩展运算符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还可以配合扩展运算符去使用 12345678function* gen() &#123; yield &quot;Lucy&quot;; yield &quot;DaMing&quot;; return &quot;OK&quot;&#125;let g1 = gen();//扩展运算符console.log(...gen()); //Lucy DaMing 结合 axios 数据请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generator 在实际应用中往往需要配合 promise 去使用，接下来我们写个实例，看看它是怎么用的。这里会用到 axios，用法这边就不详细说了 123456789101112131415//引入axios&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;function* gener() &#123; let username = yield &quot;GWJacqueline&quot;; //获取个人信息 yield axios.get(`https://api.github.com/users/$&#123;username&#125;`);&#125;let genera = gener();//先将username包装成固定对象的并返回console.log(genera.next().value); //GWJacqueline//获取信息var backname = genera.next().value.then((res) =&gt; &#123; console.log(res.data);&#125;);console.log(backname); //&#123;login: &quot;undefined&quot;, id: 11791361, node_id: &quot;MDQ6VXNlcjExNzkxMzYx&quot;, avatar_url: &quot;https://avatars3.githubusercontent.com/u/11791361?v=4&quot;, gravatar_id: &quot;&quot;, …&#125; 以上的例子主要的通过 generator 去获取 github 上面有关于我的一些信息。 实例：同学录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我分别使用 generator 和迭代器实现了一个”同学录浏览功能“，可以点击同学录查看具体效果。迭代器主要代码： 12345678910function showMessage(msg) &#123; let nextIndex = 0; return &#123; next() &#123; return nextIndex &lt; msg.length ? &#123; value: msg[nextIndex++], done: false &#125; : &#123; value: undefined, done: true &#125; &#125; &#125;&#125; generator 主要代码： 12345678function* showMessage() &#123; yield data[0]; yield data[1]; yield data[2]; yield data[3]; yield data[4];&#125; &#125;&#125; 对比完两种方式，明显 generator 比迭代器实现的更加优雅，完整代码可以上我的github查看;","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://gwjacqueline.github.io/tags/ES6/"},{"name":"异步","slug":"异步","permalink":"https://gwjacqueline.github.io/tags/异步/"}]},{"title":"js如何禁用物理返回键","slug":"js如何禁用物理返回键","date":"2019-04-13T01:36:36.000Z","updated":"2019-04-13T07:17:16.000Z","comments":true,"path":"js如何禁用物理返回键/","link":"","permalink":"https://gwjacqueline.github.io/js如何禁用物理返回键/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;最近做的几个项目都有涉及如何禁用 android 和 ios 的物理返回键，今天有空就把怎么禁用以及禁用原理记录一下吧~","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近做的几个项目都有涉及如何禁用 android 和 ios 的物理返回键，今天有空就把怎么禁用以及禁用原理记录一下吧~ 效果展示我的 demo,是不是已经成功禁用了呢？ 核心方法history.pushState(state, title[, url])&nbsp;&nbsp;&nbsp;&nbsp;pushState()是 H5 的 API 中新添加的方法，是实现物理键禁用的核心方法，所以先简单记录下该方法. &nbsp;&nbsp;&nbsp;&nbsp;pushState()是在 history 栈中添加一个新的条目。通过 window.history 方法创建新的历史项。但是它只改变地址栏 url，不刷新页面。pushState()带有三个参数：一个状态对象 state，一个标题（目前没有用，可以传 null），以及一个可选的 URL 地址。和 pushState()用法以及参数一致的方法是 replaceState()。它和 pushState()的区别是：pushState()是在 history 栈中添加一个新的条目，而 replaceState()是替换当前的记录值。因为本篇文章没有用到 replaceState(），所以这里就不进行详细说明了。 popstate &nbsp;&nbsp;&nbsp;&nbsp;当活动历史记录条目更改时，就会触发该事件。这样就可以帮助我们后面去监听用户点击返回的事件了。需要注意的是调用 history.pushState()或 history.replaceState() 不会触发 popstate 事件。当调用以上两个方法去替换新的历史项，popstate 事件的 state 属性会包含历史项状态对象的拷贝。只有在做出浏览器动作时，才会触发 popstate 事件，比如用户点击浏览器的前进回退按钮。这边经过测试，不同的浏览器在加载页面时处理 popstate 事件的形式存在差异，Chrome 和 Safari 通常会触发 popstate 事件，但 Firefox 则不会。 实现原理&nbsp;&nbsp;&nbsp;&nbsp;明白了以上两个核心方法后，就能很好的看懂禁用物理键返回的原理了。实际上就是：在监听到用户点击返回键时，在 history 栈中添加一个当前的地址。这样用户就怎么也返回不了啦~ 主要代码1234567891011121314const back = &#123;&#125;;back.onPopState = function () &#123; back.record(&quot;back&quot;);&#125;;back.record = function (state) &#123; history.pushState(state, null, location.href);&#125;back.init = function () &#123; //每次监听到返回键，都使用pushState插入一条历史记录,popstate 事件的 state 属性会包含历史项状态对象的拷贝 window.addEventListener(&quot;popstate&quot;, back.onPopState); // 在初始化的时候，先插入一条历史记录，避免用户按返回键 back.record(&quot;back&quot;);&#125;back.init();","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"物理返回键","slug":"物理返回键","permalink":"https://gwjacqueline.github.io/tags/物理返回键/"}]},{"title":"手机端调用搜索键盘","slug":"手机端调用搜索键盘","date":"2019-04-12T08:12:27.000Z","updated":"2019-04-12T14:16:05.000Z","comments":true,"path":"手机端调用搜索键盘/","link":"","permalink":"https://gwjacqueline.github.io/手机端调用搜索键盘/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;本文主要记录下如何调用系统的搜索键盘，经过实际测试以下代码可以兼容 ios 和 Android 系统","text":"&nbsp;&nbsp;&nbsp;&nbsp;本文主要记录下如何调用系统的搜索键盘，经过实际测试以下代码可以兼容 ios 和 Android 系统 大家可以用手机测试下我的 demo是否能正常调用系统的搜索键盘呢？ Html注意点： 必须在 input 输入框外用 form 表单包起来，并且要加”action”，否则在 ios 上键盘上无法弹出”搜索二字“ 123&lt;form id=&quot;formid&quot; action=&quot;#&quot;&gt; &lt;input name=&quot;name&quot; id=&quot;search&quot; type=&quot;search&quot; placeholder=&quot;我是一个输入框&quot;/&gt;&lt;/form&gt; js监听搜索按钮： 通过键盘键值匹配监听用户点击搜索按钮 12345document.getElementById(&quot;search&quot;).addEventListener(&quot;keydown&quot;, function(e) &#123; if (e.keyCode == &quot;13&quot;) &#123; alert(&quot;成功调用搜索框啦~&quot;); &#125;&#125;); 优化点部分手机在搜索框聚焦时，会出现下图所示的打叉样式： 可通过以下代码去除自带叉号样式：123input::-webkit-search-cancel-button &#123; display: none;&#125;","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://gwjacqueline.github.io/tags/移动端/"},{"name":"搜索","slug":"搜索","permalink":"https://gwjacqueline.github.io/tags/搜索/"},{"name":"返回","slug":"返回","permalink":"https://gwjacqueline.github.io/tags/返回/"}]},{"title":"天花乱坠的数组方法(二)","slug":"天花乱坠的数组方法(二)","date":"2019-04-07T11:35:39.000Z","updated":"2019-04-12T12:18:46.000Z","comments":true,"path":"天花乱坠的数组方法(二)/","link":"","permalink":"https://gwjacqueline.github.io/天花乱坠的数组方法(二)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上篇文章中很详细的说了 ES6 当中常用的数组方法，本篇文章快刀斩乱马的根据”原数组是否会被修改”的分类说下 ES5 中常见的数组方法吧","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上篇文章中很详细的说了 ES6 当中常用的数组方法，本篇文章快刀斩乱马的根据”原数组是否会被修改”的分类说下 ES5 中常见的数组方法吧 原数组不会被修改数组转换为字符串：join()二话不说，上代码： 12345var arrJoin= [1,2,3,4,5];console.log(arrJoin.join(&quot;&quot;)); //12345console.log(arrJoin.join(&quot;❤️&quot;)); //1❤️2❤️3❤️4❤️5// 事实证明：原数组不会被修改console.log(arrJoin); //[1, 2, 3, 4, 5] 来个实用的场景吧：将某个字符重复 n 次 12345function repeat(str,n)&#123; return new Array(n+1).join(str);&#125;console.log(repeat(&quot;哈&quot;,3)); //哈哈哈console.log(repeat(&quot;hi&quot;,5));//hihihihihi 数组的合并：concat()看看怎么用？ 12345678var arrConcat = [1,2,3];console.log(arrConcat.concat(4,5)); //[1, 2, 3, 4, 5]// 会被拉平为一维数组console.log(arrConcat.concat(4,5,[6,7])); //[1, 2, 3, 4, 5, 6, 7]//数组中还有数组时，不会被拉平console.log(arrConcat.concat(4,[5,[6,7]])); //[1, 2, 3, 4, 5,[6,7]]//concat()不会改变原数组console.log(arrConcat); //[1, 2, 3] 返回部分数组：slice()任性上代码： 1234567var arrSlice = [1,2,3,4,5];console.log(arrSlice.slice(1)); //[2,3,4,5]console.log(arrSlice.slice(0,2)); //[1,2]console.log(arrSlice.slice(1,4)); //[2,3,4]console.log(arrSlice.slice(1,-1)); //[2,3,4]console.log(arrSlice.slice(2,-1)); //[3,4]console.log(arrSlice); //[1,2,3,4,5] 看完代码后，我们可以总结下 slice()的用法:slice(start,end)start:必须参数，指从何处开始截取，包含该处end:可选参数，指从何处结束截取，不包含该处，该参数为负数时，指从数组尾部开始算起的位置 原数组会被修改数组逆序：reverse()1234var arrReverse = [1,2,3,4,5];console.log(arrReverse.reverse()); //[5, 4, 3, 2, 1]// 注意：原数组被修改了哦console.log(arrReverse); //[5, 4, 3, 2, 1] 数组排序：sort()1234567var arrSort = [&apos;a&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;,&apos;d&apos;]; console.log(arrSort.sort()); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;] // 注意：原数组被修改了哦 console.log(arrSort); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;] //让我们再来看看数字 var arrSortNumber = [1,19,2,25,8]; console.log(arrSortNumber.sort()); //[1, 19, 2, 25, 8] 可以看到 arrSortNumber 没有按照我们期望的输出，因为如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。让我们看看如何对数字进行正确的排序。 123456789var arrSortNumber = [1,19,2,25,8];// 升序排列console.log(arrSortNumber.sort(function(a,b)&#123; return a-b; //[1, 2, 8, 19, 25]&#125;));// 降序排列console.log(arrSortNumber.sort(function(a,b)&#123; return b-a; //[[25, 19, 8, 2, 1]&#125;)); 数组拼接：splice()12345678910var arrSplice = [&apos;a&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;,&apos;d&apos;];console.log(arrSplice.splice(2)); //[&apos;e&apos;,&apos;b&apos;,&apos;d&apos;]// 注意：原数组被修改了console.log(arrSplice); //[&quot;a&quot;, &quot;c&quot;]var arrSplice2 = [&apos;b&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;,&apos;d&apos;];console.log(arrSplice2.splice(2,2)); //[&apos;e&apos;,&apos;b&apos;]console.log(arrSplice2); //[[&quot;b&quot;, &quot;c&quot;, &quot;d&quot;]var arrSplice3 = [&apos;c&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;,&apos;d&apos;];console.log(arrSplice3.splice(2,2,&apos;h&apos;,&apos;j&apos;)); //[&quot;e&quot;, &quot;b&quot;]console.log(arrSplice3); //[&quot;c&quot;, &quot;c&quot;, &quot;h&quot;, &quot;j&quot;, &quot;d&quot;] 从以上代码可以总结下 splice()的使用方法splice(start,number,item);start：必选参数，代表要删除的起始位置，包括该位置number：可选参数，删除的个数item: 可选参数，插入的片段 数组增删：123456789101112131415161718192021var arrOperate = [];//push()数组尾部增加元素arrOperate.push(1,2);console.log(arrOperate); //[1,2]//通过length的方式在尾部增加元素arrOperate[arrOperate.length] = 3;console.log(arrOperate);//[1,2,3]//在数组头部增加元素arrOperate.unshift(-1,0);console.log(arrOperate); //[-1,0,1,2,3]//delete方法只是将对应元素改成Undefineddelete arrOperate[0];console.log(arrOperate); //[undefined,0,1,2,3]如果0位置设置为&quot;undefined&quot;，则为trueconsole.log(0 in arrOperate); //false//pop()删除元素的最后一位arrOperate.pop();console.log(arrOperate); //[undefined,0,1,2]//pop()删除元素的第一位arrOperate.shift();console.log(arrOperate); //[0,1,2]","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://gwjacqueline.github.io/tags/ES6/"},{"name":"数组","slug":"数组","permalink":"https://gwjacqueline.github.io/tags/数组/"}]},{"title":"天花乱坠的数组方法(一)","slug":"天花乱坠的数组方法(一)","date":"2019-04-06T09:52:39.000Z","updated":"2019-04-12T01:43:38.000Z","comments":true,"path":"天花乱坠的数组方法(一)/","link":"","permalink":"https://gwjacqueline.github.io/天花乱坠的数组方法(一)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组是 JS 当中很重要的一个部分，它有很多很多很多的方法，对于我这样记性不好的人来说，一些不常用的方法经常会被遗忘，经常需要再次查找才能想起来。今天为了能给自己加深对数组方法的记忆，将通过两个章节去整理下常用的数组方法。第一个章节将记录下 ES6 中常见的数组方法，其中将详细记录下部分数组，第二个章节将简单整理下 ES5 之前的数组方法。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组是 JS 当中很重要的一个部分，它有很多很多很多的方法，对于我这样记性不好的人来说，一些不常用的方法经常会被遗忘，经常需要再次查找才能想起来。今天为了能给自己加深对数组方法的记忆，将通过两个章节去整理下常用的数组方法。第一个章节将记录下 ES6 中常见的数组方法，其中将详细记录下部分数组，第二个章节将简单整理下 ES5 之前的数组方法。 ES6 中新增的数组方法数组元素遍历：for 循环/forEach()在 ES6 之前还没有 forEach()方法时，我们通常是使用 for 循环对数组进行遍历的。 ES5 之前：for 循环遍历数组实例：12345//通过for循环将数组中的元素遍历出来var color = [&apos;blue&apos;,&apos;yellow&apos;,&apos;red&apos;];for(var i=0;i&lt;color.length;i++)&#123; console.log(color[i]); //blue,yellow,red&#125; 有了 forEach()方法后，数组的遍历整体变得更加可观，直接用数组调用对应的内容 forEach()遍历数组实例：12345var colorES6 = [&apos;blue&apos;,&apos;yellow&apos;,&apos;red&apos;,&apos;white&apos;];//forEach()中放一个迭代函数，colorES6作为形参去接受数组里的每一个内容colorES6.forEach(function(colorES6)&#123; console.log(colorES6); //blue,yellow,red,white&#125;); forEach()遍历数组的优点：123456789//求数组元素的总和var numbers = [1,2,3,4,5];var sum = 0; //用于接收数组的总和//forEach可以将函数抽离出来function num(number)&#123; sum+=number;&#125;numbers.forEach(num);console.log(sum); //15 以上代码我们可以看出 forEach()的好处不止让代码变得更加可观，可以直接调用数组里的内容，还可以将函数抽离出来 forEach()遍历数组的过程：为了能加深对 forEach()的理解，可以用一个流程图来简单画出 forEach()遍历数组的过程： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图中画的是”forEach()遍历数组实例”中的过程：第一次先将blue放在迭代器里，将它打印出来，第二次再将yellow放在迭代器里，将它打印出来，以此类推。 直达找到最后一个没有的时候，那么当前的循环就结束了。 forEach()使用的场景：比如：一个表单有一个多选框，再提交表单时，需要遍历选中的元素并进行相应操作。 数组的映射：map()映射这两个字大家可能会觉得有点抽象，通俗点来说就是对数组进行一些转化。常用的场景有两种：1.在拷贝数组的过程中改变一些东西2.在数组中拿到一些固定的属性接下来我将用for循环和ES6新方法map()编写上面两种场景 场景一：将数组A以两倍的形式放到数组B中去ES5之前：for循环+push()实现场景一123456var oldA = [1,2];var oldB = [];for(var i=0;i&lt;oldA.length;i++)&#123; oldB.push(oldA[i]*2); //将数组A中的元素乘以2后放置到数组A中&#125;console.log(oldB); //[2,4] map()实现场景一123456var arrA = [1,2,3];//map返回的就是数组，所以不需要 var arrB =[];var arrB = arrA.map(function(x)&#123; //map里面依旧放迭代器函数 return 2 * x; &#125;);console.log(arrB); //[2,4,6] 场景二：有一个对象数组A，把数组A中对象的name属性存储到对象B上ES5之前：for循环+push()实现场景二123456789var oldarrObjectA = [ &#123;name: &quot;Lucy&quot;,age: 13&#125;, &#123;name: &quot;Tom&quot;,age: 14&#125;];var oldarrObjectB = [];for(i=0;i&lt;oldarrObjectA.length;i++)&#123; oldarrObjectB.push(oldarrObjectA[i].name);&#125;console.log(oldarrObjectB); //[&quot;Lucy&quot;, &quot;Tom&quot;] map()实现场景二123456789var arrObjectA = [ &#123;name: &quot;Lucy&quot;,age: 13&#125;, &#123;name: &quot;Tom&quot;,age: 14&#125;, &#123;name: &quot;Lili&quot;,age: 15&#125;];var arrObjectB = arrObjectA.map(function(x)&#123; return x.name;&#125;);console.log(arrObjectB); //[&quot;Lucy&quot;, &quot;Tom&quot;, &quot;Lili&quot;] map()和forEach()一样，里面放的都是迭代器函数。map()返回的是一个新的数组。这里我们需要注意一下map()是需要返回值的，如果不给返回值，则默认返回undefined。123456// 不给map返回值var arrA = [1,2,3];var arrB = arrA.map(function(x)&#123; 2 * x;&#125;);console.log(arrB); //[undefined, undefined, undefined] map()映射数组的过程：接下来，我们用一个流程图来简单画出场景一中map()映射数组的过程： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;场景一中A数组想要做的事情就是让B数组中装的是它的两倍，map里面的方法会拥有一个迭代器函数。比如a.map()，它会将a中的每个值放到迭代器函数中的形参里面，然后将值乘以2后返回到新数组中。例如拿到”1”后，乘以2再返回到新数组中去。 使用场景：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：基金产品中会有很多种基金，我们假设每个基金都是一个对象，每个基金都会有很多属性：比如基金名字、关注度、收益率等。后台人员需要获取每个基金的关注度时，就可以采取map()方法。 数组的过滤：filter()过滤数组是我们开发中经常会遇到的问题，接下来我会使用三个常见的场景加深对filter()方法的理解 场景一：把不想要的值过滤掉，拿出我们想要的值(假定有一个对象数组A，获取数组中指定类型的对象放到数组B中)12345678910111213141516171819//将typeA中为男性的对象抽取出来var typeA = [ &#123;name: &apos;Lily&apos;,gender: &apos;female&apos;&#125;, &#123;name: &apos;Lucy&apos;,gender: &apos;female&apos;&#125;, &#123;name: &apos;Peter&apos;,gender: &apos;male&apos;&#125;,];// ES5之前：for循环+push()的实现var typeB = [];for(var i=0;i&lt;typeA.length;i++)&#123; if(typeA[i].gender===&apos;male&apos;)&#123; typeB.push(typeA[i]); &#125;&#125;console.log(typeB); //[&#123;name: &quot;Peter&quot;, gender: &quot;male&quot;&#125;]// ES6 filter()的实现var typeC = typeA.filter(function(x)&#123; return x.gender===&apos;male&apos;; //[&#123;name: &quot;Peter&quot;, gender: &quot;male&quot;&#125;]&#125;);console.log(typeC); //&#123;name: &quot;Peter&quot;, gender: &quot;male&quot;&#125; 场景二：假定有一个对象数组A，过滤掉不满足以下条件的对象：条件：性别女，年龄大于13岁，班级不为3班的123456789var personA = [ &#123;name: &apos;Lily&apos;,gender: &apos;female&apos;,age:16,class:1&#125;, &#123;name: &apos;Lucy&apos;,gender: &apos;female&apos;,age:14,class:2&#125;, &#123;name: &apos;Peter&apos;,gender: &apos;male&apos;,age:17,class:3&#125;,];var choosePerson = personA.filter(function(x)&#123; return x.gender === &apos;female&apos; &amp;&amp; x.age&gt;13 &amp;&amp;x.class !==3&#125;);console.log(choosePerson); //[&#123;name: &quot;Lily&quot;, gender: &quot;female&quot;, age: 16, class: 1&#125;,&#123;name: &quot;Lucy&quot;, gender: &quot;female&quot;, age: 14, class: 2&#125;] 场景三：根据对象A的id值，过滤掉B数组中与对象A中id值不符的元素12345678910var objA = &#123;id:1,title:&apos;haha&apos;&#125;;var filterId = [ &#123;id:1,content:&apos;filter&apos;&#125;, &#123;id:2,content:&apos;filter&apos;&#125;, &#123;id:1,content:&apos;filter2&apos;&#125;];filterId = filterId.filter(function(x)&#123; return x.id === objA.id;&#125;);console.log(filterId); //[&#123;id: 1, content: &quot;filter&quot;&#125;,&#123;id: 1, content: &quot;filter2&quot;&#125;] filter()过滤数组的过程：看了以上三个场景后，对filter的使用方法应该有所了解了，接下来，我们结合场景一看看filter是怎样实现过滤的 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们在遍历数组typeA时，会将当前类型的值放到迭代器函数里面，去对它进行匹配，因为我们拿到的是每个对象，当每个对象下的gender值为male时，则为匹配成功，会以return true的形式返回，并放到typeC数组中。如果匹配不成功，则返回false,且不会放到typeC数组中。 数组的查找：find()通过find()方法可以帮我们找到对应的东西。还是根据两个常用的场景来看看find()怎么用吧。 场景一：假定有一个对象数组，找到符合条件的对象并存储起来1234567891011121314151617181920//快速找到findA中姓名为&apos;Billy&apos;的对象var findA = [ &#123;name: &apos;Lucy&apos;&#125;, &#123;name: &apos;Peter&apos;&#125;, &#123;name: &apos;Billy&apos;&#125;];var thisA;//ES5之前：for循环for(var i=0;i&lt;findA.length;i++)&#123; if(findA[i].name === &apos;Billy&apos;)&#123; thisA = findA[i]; break; //找到之后结束循环，避免浪费时间 &#125;&#125;console.log(thisA); //&#123;name: &quot;Billy&quot;&#125;//ES6 find()：找到第一个符合条件的对象，就不会再次循环var thisB = findA.find(function(x)&#123; return x.name === &apos;Billy&apos;&#125;);console.log(thisB); //&#123;name: &quot;Billy&quot;&#125; 场景二：假定有一个对象数组，根据指定对象的条件找到数组中符合条件的对象123456789101112var findArr = [ &#123;name: &apos;Lucy&apos;,age: 13&#125;, &#123;name: &apos;Billy&apos;,age: 17&#125;, &#123;name: &apos;Peter&apos;,age: 13&#125; ]; var choosefindArr =&#123;name: &apos;Bob&apos;,age: 13&#125;; function choose(findArr,choosefindArr)&#123; return findArr.find(function(x)&#123; return x.age === choosefindArr.age; &#125;); &#125; console.log(choose(findArr,choosefindArr)); //&#123;name: &quot;Lucy&quot;, age: 13&#125; find()的工作流程：find()的特点在于：找到对应的条件，就不会继续往下执行。能帮助我们快速查找到对应的内容。接下来，我们根据场景1来看看它的工作模式是什么样的吧 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们遍历findA这个数组通过find()时，会将每个name放到迭代器函数中，去判断目前的name和我们想要的name是否相等。如果不相等，则会返回一个false,就没有任何东西；如果相等，则返回true，并将对应的内容返回到thisA中。 一真即真，一假即假的：every()、some()every()所有条件都满足，才返回true；some(),只要一个条件满足，就返回true()。 场景一：查询班级成员成绩达标情况，成绩大于60表示达标，小于60为不达标1234567891011121314151617181920212223242526var classMark = [ &#123;name: &apos;Lucy&apos;,mark: 90&#125;, &#123;name: &apos;Peter&apos;,mark: 80&#125;, &#123;name: &apos;Billy&apos;,mark: 20&#125;];//ES5之前：for循环 方法var markeveryOK = true; //成绩全部达标var marksomeOK = false; //成绩部分达标 for(var i=0;i&lt;classMark.length;i++)&#123; if(classMark[i].mark &lt; 60)&#123; markeveryOK = false; &#125;else&#123; marksomeOK = true; &#125; &#125; console.log(markeveryOK,marksomeOK); //false true//every()/some()方法; //成绩全部达标,一旦返回的是假，后续的东西就不会再去遍历了var markeveryOKES6 = classMark.every(function(x)&#123; return x.mark &gt; 60;&#125;);//成绩部分达标，一旦返回的是真，后续的东西就不会再去遍历了var marksomeOKES6 = classMark.some(function(x)&#123; return x.mark &gt;60;&#125;);console.log(markeveryOKES6,marksomeOKES6); //false true 场景二：一个表单页面，判断所有输入框内容的长度是否大于01234567891011121314151617// 获取输入框的内容function Field(value)&#123; this.value = value;&#125;// 判断当前输入框内容的长度是否大于0Field.prototype.validate = function()&#123; return this.value.length &gt; 0;&#125;var filedName = new Field(&apos;Lucy&apos;);var filedage = new Field(&apos;&apos;);var filedpassword = new Field(&apos;123456&apos;);var fieldArr = [filedName,filedage,filedpassword];// 用every方法判断是否所有输入框内容的长度都大于0var result = fieldArr.every(function(x)&#123; return x.validate();&#125;);console.log(result); //false every()的工作流程：every()的特点：一旦返回的是假，就不会再去遍历了。接下来我们结合场景一简单说下every()的工作流程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学生的成绩分别是：90，80，20。我们首先把”90”放到迭代器函数中，然后和我们的60进行匹配。90不小于60，所以markeveryOKES6为true。20小于60，所以markeveryOKES6为false。最终会将返回值用&amp;&amp;运算符输出，即一假即假。some() some()的工作流程：every()的特点：一旦返回的是真，就不会再去遍历了 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次把90放到迭代器函数中，marksomeOKES6为true。当some()返回为true时，则不再进行遍历。即一真即真 把数组聚合成结果 reduce()reduce()可以替代大多数数组的方法，比如forEach、map()等，接下来我们看看它是怎么替代和应用的 场景一：代替forEach()计算数组中所有值的总和12345var reduce =[10,20,30];var sum = reduce.reduce(function(x,y)&#123; return x+y;&#125;,10); //这里放初始值console.log(sum); //70 场景二：代替map()将数组中对象的某个属性抽离到另外一个数组中12345678910var reduceArr =[ &#123;name:&apos;Lucy&apos;,age:11&#125;, &#123;name:&apos;David&apos;,age:19&#125;, &#123;name:&apos;Billy&apos;,age:13&#125;];var choosereduceArr = reduceArr.reduce(function(x,y)&#123; x.push(y.name); return x;&#125;,[]);console.log(choosereduceArr); // [&quot;Lucy&quot;, &quot;David&quot;, &quot;Billy&quot;] 场景三：判断字符串中括号是否对称例如：（（（））） 对称（）（）（） 对称(（（） 不对称12345678910function bracket(string)&#123; // 先将字符串变为数组 return !string.split(&apos;&apos;).reduce(function(x,y)&#123; if(y === &quot;(&quot;)&#123;++x;&#125;; if(y === &quot;)&quot;)&#123;--x;&#125;; return x; &#125;,0);&#125;console.log(bracket(&apos;(())&apos;)); //trueconsole.log(bracket(&apos;(())))))&apos;)); //false reduce()的工作流程：接下来我们结合场景一看看reduce()是如何把数组聚合成结果的吧 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;场景一中reduce arr是10、20、30，当我们在遍历的时候，这个参数的初始化值为10，然后我们拿到的就是10+20，然后第二个值就为20，然后再次与迭代器函数里的值相加，以此类推得到最后一个结果。 reduceRight()从字面很好理解，reduce()遍历的顺序是从左往右，相反它的从右往左。和redece()的区别就是遍历顺序。这里就不多做解释了。 数组的检索indexOf()该方法将根据我们查找的对象，从头到尾的去检索数组，返回我们查找对象的位置1234567var arr = [1,2,3,-1,2,3];console.log(arr.indexOf(2)); //1console.log(arr.indexOf(99)); //-1console.log(arr.indexOf(1,0)); //0console.log(arr.indexOf(2,2)); //4console.log(arr.indexOf(2,-1)); //-1console.log(arr.indexOf(2,-3)); //-4 从以上的例子可以总结下indexOf()的使用方法indexOf(i,p)会返回从p位置开始检索的对象i，检索完成后返回对象i在数组中的位置i：必传参数，查找的对象p: 可传参数，从数组的哪个位置开始找 数组的检索lastndexOf()indexOf的区别就是，lastIndexOf是从右往左找的。1234var arr = [1,2,3,-1,2,3];console.log(arr.lastIndexOf(2)); //4console.log(arr.lastIndexOf(1,0)); //0console.log(arr.lastIndexOf(2,-1)); //4 数组的检索indexOf()该方法将根据我们查找的对象，从头到尾的去检索数组，返回我们查找对象的位置1234567var arr = [1,2,3,-1,2,3];console.log(arr.indexOf(2)); //1console.log(arr.indexOf(99)); //-1console.log(arr.indexOf(1,0)); //0console.log(arr.indexOf(2,2)); //4console.log(arr.indexOf(2,-1)); //-1console.log(arr.indexOf(2,-3)); //-4 从以上的例子可以总结下indexOf()的使用方法indexOf(i,p)会返回从p位置开始检索的对象i，检索完成后返回对象i在数组中的位置i：必传参数，查找的对象p: 可传参数，从数组的哪个位置开始找 判断是否为数组 isArray()我们来回顾下原先没有isArray()的时候，我们通常是怎么判断是否为数组的1234var obj = [1,2,3,-1,2,3];console.log(Object.prototype.toString.call(obj)); //[object Array]console.log(obj instanceof Array); //trueconsole.log(obj.constructor === Array); //true 有了isArray()后，我们可以直接使用这个方法来判断数组啦~1234var obj = [1,2,3,-1,2,3];var obj2 = &#123;name:&apos;Lucy&apos;&#125;;console.log(Array.isArray(obj)); //trueconsole.log(Array.isArray(obj2)); //false 以上篇幅有些长，主要介绍了ES6新增的一些常用数组，接下来第二篇，将简单回顾下ES5一些数组的常用方法吧~","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://gwjacqueline.github.io/tags/ES6/"},{"name":"数组","slug":"数组","permalink":"https://gwjacqueline.github.io/tags/数组/"}]},{"title":"移动端常见兼容性问题","slug":"移动端常见兼容性问题","date":"2019-04-01T08:12:27.000Z","updated":"2019-05-16T05:36:03.000Z","comments":true,"path":"移动端常见兼容性问题/","link":"","permalink":"https://gwjacqueline.github.io/移动端常见兼容性问题/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;本文主要想记录下最近工作中遇到的一些移动端兼容问题，便于日后能够快速解决一些 Bug。","text":"&nbsp;&nbsp;&nbsp;&nbsp;本文主要想记录下最近工作中遇到的一些移动端兼容问题，便于日后能够快速解决一些 Bug。 ios fixed 定位+长表单 主要代码：12345678&lt;body&gt; &lt;header&gt; &lt;!-- fixed定位的头部 --&gt; &lt;header&gt; &lt;section&gt; &lt;!-- 自然布局 --&gt; &lt;/section&gt;&lt;/body&gt; bug描述：只有在ios上出现：当section过长(有滚动条时)，表单获取焦点时。上图红色框的头部会掉落至绿色部分。 bug解决：造成问题的原因：当表单获取焦点，键盘弹出时，可视高度变小。解决方式：1.表单获取焦点时，把fixed定位改成absolute;失去焦点时，改回来。2.将 section 由自然布局改为绝对定位个人建议：在实际开发中，尽量少使用fixed定位。 Android footer fixed定位 主要代码：1234567891011&lt;body&gt; &lt;header&gt; &lt;!-- absolute定位的头部 --&gt; &lt;header&gt; &lt;section&gt; &lt;!-- 自然布局 --&gt; &lt;/section&gt; &lt;section&gt; &lt;!-- fixed定位的footer --&gt; &lt;/section&gt;&lt;/body&gt; bug描述：只有在Android手机上出现：表单获取焦点时,系统键盘会将fixed定位的footer顶起来。 bug解决：造成问题的原因：系统键盘会顶走fixed布局元素。解决方式：1.表单获取焦点时，把fixed定位的元素改成static；失焦后，再改回来。2.表单获取焦点时，把fixed定位的元素设置为display:none；失焦后，再设置成为display:block。 ios 微信浏览器 长表单留白 bug描述：只有在ios微信浏览器上出现。当输入框聚焦，系统键盘把页面顶起后，键盘收起。会发现页面底部留白 bug解决：造成问题的原因：系统键盘弹出触发resize导致页面高度缩小。解决方式：12345$(&quot;input,textarea&quot;).blur(function () &#123; setTimeout(function () &#123; //若不加定时器，部分手机会失效 $(&quot;body&quot;).scrollTop($(body).scrollTop()+1); //让页面偷偷滚动一下，消除空白 &#125;,100);&#125;); transform弹窗不居中 主要代码：123456789101112/*弹窗*/.dialog-content &#123; position: absolute; top: 50%; left: 50%; z-index: 10003; width: 73%; padding-top: .66667rem; transform: translate(-50%,-50%); background-color: rgba(255,255,255,.95); border-radius: .21333rem;&#125; bug描述：在ios 8及以下的系统，弹窗不居中 bug解决：造成问题的原因：Safari支持代替的-webkit-transform属性，读取不到transform属性解决方式：加上-webkie-transform属性，注意兼容性写法顺序1234567891011121314/*弹窗*/.dialog-content &#123; position: absolute; top: 50%; left: 50%; z-index: 10003; width: 73%; padding-top: .66667rem; background-color: rgba(255,255,255,.95); border-radius: .21333rem; -webkit-transform: translate(-50%,-50%); //一定要加上兼容性的写法 -ms-transform: translate(-50%,-50%); //IE9以下不兼容，IE9支持代替的-ms-transform属性不过只支持2D transform: translate(-50%,-50%);&#125; ios 输入框背景色变黄 主要代码：1234567input&#123; border: none; background: 0 0; display: block; -webkit-tap-highlight-color: transparent; //只用于iOS。点击链接或者通过Javascript定义的可点击元素的时候，会出现一个半透明的灰色背景 -webkit-appearance: none; //消除输入框和按钮的原生外观，在iOS上加上这个属性才能给按钮和输入框自定义样式&#125; bug描述：自动填充表单时，输入框背景色变黄。 bug解决：造成问题的原因：如果不设置，autocomplete默认是on的解决方式：1.利用H5新增属性 autocomplete=”off”，直接关闭自动填充1&lt;input type=&quot;text&quot; autocomplete=&quot;off&quot;&gt; 2.给form表单增加autocomplete=”off”，一次性取消表单内所有输入框的自动填充功能123&lt;form autocomplete=&quot;off&quot;&gt; &lt;input type=&quot;text&quot; &gt;&lt;/form&gt; 3.利用css12345//给input设置内置阴影！阴影大小一定要比你的input本身大input:-webkit-autofill &#123; -webkit-box-shadow: 0 0 0px 1000px white inset !important;//输入框背景颜色 -webkit-text-fill-color: #000!important;//输入框文字颜色&#125; ios 弹出框被遮罩层盖住 主要代码：123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;header&gt; &lt;!-- 头部代码 --&gt; &lt;/header&gt; &lt;section class=&quot;content&quot;&gt; &lt;!-- 打开弹窗按钮 --&gt; &lt;section class=&quot;btn-wrap&quot;&gt; &lt;input value=&quot;打开&quot;&gt; &lt;/section&gt; &lt;!-- 弹出框 fixed定位--&gt; &lt;div class=&quot;keyboard&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;!-- 遮罩层 fixed定位--&gt; &lt;div class=&quot;mask-black&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;style&gt;.mask-black &#123; background-color: rgba(51,51,51,.75); position: fixed; z-index: 500; bottom: 0; right: 0; left: 0; top: 0;&#125;.keyboard &#123; position: fixed; bottom: 0; left: 0; width: 100%; z-index: 1000;&#125;&lt;/style&gt; bug描述：在PC端及安卓上显示正常，唯独在ios上弹窗被遮档 bug解决：造成问题的原因：虽然z-index的层级问题没错，但是代码结构不规范。个人感觉很多时候一些奇怪的bug来源于我们代码的不规范。解决方式：将弹出框移至外层123456789101112131415&lt;body&gt; &lt;header&gt; &lt;!-- 头部代码 --&gt; &lt;/header&gt; &lt;section class=&quot;content&quot;&gt; &lt;!-- 打开弹窗按钮 --&gt; &lt;section class=&quot;btn-wrap&quot;&gt; &lt;input value=&quot;打开&quot;&gt; &lt;/section&gt; &lt;/section&gt; &lt;!-- 弹出框 fixed定位--&gt; &lt;div class=&quot;keyboard&quot;&gt;&lt;/div&gt; //将弹出框移至外层 &lt;!-- 遮罩层 fixed定位--&gt; &lt;div class=&quot;mask-black&quot;&gt;&lt;/div&gt;&lt;/body&gt; ios 时间格式主要代码：1234var a=new Date(&apos;2017/01/01&apos;); //Sun Jan 01 2017 00:00:00 GMT+0800 (CST)var b=new Date(&apos;01/02&apos;); //Invalid Datevar date =new Date(&quot;2016/05/31 08:00&quot;); //Tue May 31 2016 08:00:00 GMT+0800 (CST)var date =new Date(&quot;2016-05-31 08:00&quot;); //Invalid Date bug 描述：ios 对 date()的支持不一样，ios 只传月日或则“/”为不合理日期,ios 必须传年月日,且分隔符为“-” bug 解决：ios 必须传年月日，且必须用“/”分隔 ios fixed 按钮上下飘动 主要代码：1234567891011121314&lt;body&gt; &lt;header&gt; &lt;!-- 头部代码 绝对定位--&gt; &lt;/header&gt; &lt;!-- 内容代码 绝对定位--&gt; &lt;section class=&quot;content&quot;&gt; &lt;!-- 列表 --&gt; &lt;ul&gt;&lt;/ul&gt; &lt;!-- fixed置底定位按钮 --&gt; &lt;section class=&quot;btn-wrap&quot;&gt; &lt;input value=&quot;打开&quot;&gt; &lt;/section&gt; &lt;/section&gt;&lt;/body&gt; bug描述：只出现在ios上，当列表ul过长时，快速滚动页面，fixed置底按钮会上下飘动 bug解决：解决方式：将fixed置底定位的按钮移到最外层123456789101112131415&lt;body&gt; &lt;header&gt; &lt;!-- 头部代码 绝对定位--&gt; &lt;/header&gt; &lt;!-- 内容代码 绝对定位--&gt; &lt;section class=&quot;content&quot;&gt; &lt;!-- 列表 --&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/section&gt; &lt;!-- fixed置底定位按钮 移到最外层--&gt; &lt;section class=&quot;btn-wrap&quot;&gt; &lt;input value=&quot;打开&quot;&gt; &lt;/section&gt;&lt;/body&gt; h5虚拟键盘，密码框假光标移动问题 描述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用h5虚拟键盘时，需要让输入框disabled,以至于没有系统光标。需要编写一个假光标，提升用户体验。因为输入框采用”type=”password”,所以会采用系统自带的密码遮掩点。每个系统密码遮掩点都不大一样。经过多台真机的多次调试，发现大致可分为四类：大部分安卓、vivo X9S、Vivo X20、ios。为了便于以后遇到类似问题，又需要大量时间进行调试，现在先记录下调试结果。 光标移动距离的计算： 光标移动距离=(密码个数*dotWidth)em;Ios: dotWidth=1vivo X9S: dotWidth=0.5Vivo X20: dotWidth=0.49其余机型：dotWidth=0.34获取机型的方法：123if(navigator.userAgent.indexOf(“vivo X9s”)!==-1)&#123; alert(&quot;是vivo X9s&quot;);&#125; 弹性盒子兼容问题描述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前做过基于Android的智能电视项目，最早的需求是说最低兼容到Android5.0以上，于是就疯狂舒畅自由的使用新版盒子模型的写法。可是需求总是多变的，在开发接近尾声的时候，改成了兼容到Android3还是4。于是在低版本电视上盒子布局的前端页面变得面目全非。导致后来在使用盒子模型的时候总是小心翼翼，毕竟低版本的电视和手机还是有人用的。现在就记录下常见盒子模型的兼容写法把，能够让我们在面对测试提出页面bug的时候，快速定位问题所在并且解决它~ 兼容写法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//flex 布局.flex&#123;display: -webkit-box; /_ 老版本语法 _/display: -moz-box; /_ 老版本语法: Firefox/display: -webkit-flex; /_ 新版本语法\\*/display: flex;&#125;//两端对齐.flex-between&#123;-webkit-box-pack: justify;-moz-justify-content: space-between;-webkit-justify-content: space-between;justify-content: space-between;&#125;//左右、上下居中.flex-center&#123;-webkit-box-pack: center; /_ 左右 _/-moz-justify-content: center;-webkit-justify-content: center;justify-content: center;-webkit-box-align: center; /_ 上下 _/-moz-align-items: center;-webkit-align-items: center;align-items: center;&#125;//垂直对齐.flex-column&#123;-webkit-box-direction: normal;-webkit-box-orient: vertical;-moz-flex-direction: column;-webkit-flex-direction: column;flex-direction: column;&#125;//盒子相应比例(scss 写法)@mixin flex-block($con:1)&#123; -webkit-box-flex: 1; -moz-box-flex: 1; -ms-flex: $con;-webkit-flex: $con; flex: $con;&#125;//引用方法：@include flex-block(\\$con),能够快速实现想要的比例 `","categories":[{"name":"css","slug":"css","permalink":"https://gwjacqueline.github.io/categories/css/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://gwjacqueline.github.io/tags/移动端/"},{"name":"兼容性","slug":"兼容性","permalink":"https://gwjacqueline.github.io/tags/兼容性/"}]},{"title":"重温OOP之原型与继承","slug":"重温OOP之原型链与继承","date":"2019-03-31T11:31:34.000Z","updated":"2019-04-21T11:54:39.000Z","comments":true,"path":"重温OOP之原型链与继承/","link":"","permalink":"https://gwjacqueline.github.io/重温OOP之原型链与继承/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JS 原型链与继承是 JS 中的重点，这篇文章将针对原型链和继承通过代码的方式略作总结。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JS 原型链与继承是 JS 中的重点，这篇文章将针对原型链和继承通过代码的方式略作总结。 原型链&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们通过 new 操作符创建对象的过程来说说原型链。 123456function Person(name) &#123; this.name = name; return name;&#125;let classes = new Person(&quot;Lucy&quot;);console.log(classes); // person &#123;name: &quot;Lucy&quot;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们用代码的形式来解析下以上用 new 操作符创建实例的过程。 1.var classes = {};&nbsp;&nbsp;&nbsp;&nbsp;//创建一个空对象2.classes.prop = Person.prototype&nbsp;&nbsp;&nbsp;&nbsp;//将空对象的proto成员指向 Person 函数对象的 prototype 成员对象3.Person.call(classes); &nbsp;&nbsp;&nbsp;&nbsp;//将 Person 函数的指针指向 classes注意我们需要牢记的是只有对象才有proto属性，只有函数才有 prototype 属性。由于在 js 中函数也是对象，所以函数也有prop属性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这张图我们可以看到proto属性都是从一个对象指向他们的原型对象。当我们在访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会它的proto属性指向的那个父对象当中去找，如果父对象也不存在该属性，则会去再上一层父对象的proto属性指向的对象中找。如果还是没有找到，则会一层一层向上查找，一直到找到 null 为止，如果还没有找到，则返回 Undefined。像这种通过proto属性来连接对象直到 null 为止的一条链就是原型链。 注意：使用 new 来创建对象，调用构造函数的时候，如果 return 的是对象，则会返回该对象；如果 return 的是非对象，则会忽略返回值 12345function person() &#123; return 1;&#125;let classes = new person();console.log(classes); //person &#123;&#125; Object.prototype.toString.call(obj)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说完了原型链，我们来实际应用下把。Object.prototype.toString.call(obj)这个方法是检测对象类型最通用的办法。通过原型链的知识，我们看看为什么这个方法能检测数据类型,而obj.toString()只能将对应类型转成字符类型。 123456789console.log(Object.prototype.toString.call(&quot;Lucy&quot;)); //[object String]console.log(Object.prototype.toString.call([1, 2])); //[object Array]console.log(Object.prototype.toString.call(true)); //[object Boolean]console.log(Object.prototype.toString.call(new Date().getTime())); //[object Number]console.log(&quot;Lucy&quot;.toString()); //Lucyconsole.log([1, 2].toString()); //1,2console.log(true.toString()); //trueconsole.log(new Date().getTime().toString()); //1555840282073 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从代码可以推测出 toString 是 Object 的原型方法，而 Array,Boolean,Date 等是 Object 的实例，各自上都有 toString 方法。根据以上说的原型链，因为各自上已经有 toString 方法，所以调用的是各自的 toString 方法，而不会去调用 Object 原型上的 toString 方法，所以 obj.toString 只能将 obj 转成字符串类型。要想检验对象的类型，应该去调用 Object 原型上的 toSting 方法。接下来，我们将 String 上的 toString 方法删掉，来验证我们的猜测。 123456var string = &quot;Lucy&quot;;console.log(String.prototype.hasOwnProperty(&quot;toString&quot;)); //trueconsole.log(string.toString()); //Lucydelete String.prototype.toString;console.log(String.prototype.hasOwnProperty(&quot;toString&quot;)); //falseconsole.log(string.toString()); //&quot;[object String]&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在删掉了 String 上的 toString()后，再用 string.toString()方法调用时，因为 string 上没有 toSting()方法了，它就会沿着原型链，调用 Object 上的 toString 方法，所以才能返回与 Object.prototype.toString.call(obj)相同的结果。就验证了我们的猜测是对的。 继承&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来我们利用原型实现下继承。 123456789101112131415161718192021222324function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.hello = function() &#123; return `你好，我叫$&#123;this.name&#125;,我$&#123;this.age&#125;岁，很高兴认识你`;&#125;;Person.prototype.school = &quot;UV&quot;;function Student(name, age, className) &#123; Person.call(this, name, age); this.className = className;&#125;//Object.create():创建一个空对象，并且让这个对象的原型指向create()中的参数Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;Student.prototype.classRoom = function() &#123; return `我是$&#123;this.className&#125;班的`;&#125;;var demo = new Student(&quot;Lucy&quot;, 20, 11);console.log(demo.hello()); //你好，我叫Lucy,我20岁，很高兴认识你console.log(demo.school); // UVconsole.log(demo.classRoom()); // 我是11班的 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上代码中，我先定义了一个 Person 构造函数，并且在其原型上添加了一个 hello 方法和 school 属性。然后我又定义了一个 Student 函数并在原型上定义了一个 classRoom 方法。将 Student.prototype 的proto指向了 Person.prototype。完成了一个基础的继承例子。注意：1.不能用 Student.prototype = Person.prototype这样在增加 student.prototype 的同时也会增加 Person，维护性很差要指定 Student.prototype.constructor,如果没有指定的话，Student.prototype.constructor 会指向 Person标准的继承写法 12Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student; 接下来，我们看看上面这个代码的原型链吧","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://gwjacqueline.github.io/tags/面向对象/"},{"name":"原型链","slug":"原型链","permalink":"https://gwjacqueline.github.io/tags/原型链/"},{"name":"继承","slug":"继承","permalink":"https://gwjacqueline.github.io/tags/继承/"}]},{"title":"http请求","slug":"http请求","date":"2019-03-30T09:24:53.000Z","updated":"2019-04-21T11:50:15.000Z","comments":true,"path":"http请求/","link":"","permalink":"https://gwjacqueline.github.io/http请求/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇文章将从记录下 http 请求相关的一些内容。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇文章将从记录下 http 请求相关的一些内容。 HTTP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http 是计算机通过网络进行通信的规则。http 是一种无状态的连接，也就是说 http 不建立持久的连接，服务器端不保留连接的相关信息。比如：web 像服务器发送请求，服务器响应请求后，连接就被关闭了，处理的过程是没有记忆的，如果后续的处理要之前的一些传递信息，就要重新发送请求。 HTTP 的完整请求过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个完整的 HTTP 请求，通常有 7 个步骤。 1.建立 TCP 连接&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是上计算机网络的时候，老师经常挂在嘴上的三次握手，三次握手。第一次 🤝：主机向服务器发送建议连接的请求，第二次 🤝：服务器收到请求之后发送同意连接的信号，第三次 🤝：主机收到同意连接的信号后，向服务器发送确认信号。这个过程就采用了 TCP 连接。若其中一方没有收到确认的信号，TCP 协议就会要求再次发送信号。 2.WEB 浏览器向 WEB 服务器发送请求命令&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一旦建立了 TCP 连接，Web 浏览器就会向 Web 服务器发送请求命令 3.WEB 浏览器发送请求头信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Web 浏览器向 Web 服务器发送请求命令之后，需要将一些请求头、请求行和请求正文等头信息发送给服务器。接着浏览器再发送空白行来通知服务器，它结束了头信息的发送。 4.WEB 服务器应答&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Web 浏览器向服务器发出请求后，服务器会发出类似：”我收到了“的信号。 5.WEB 服务器发送应答头信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以 ”Content-Type“ 应答头信息的格式发送用户所请求的实际数据 6.WEB 服务器关闭 TCP 连接&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果浏览器或者服务器没有在头信息中加入”Connection:keep-alive“(TCP 连接在发送后将仍然保持打开状态,浏览器可以继续通过相同的连接发送请求。目的是为了节省每个请求建立新连接所需的时间，从而节约带宽)。一旦 Web 服务器向浏览器发送了请求数据，就会关闭 TCP 连接。 HTTP 请求组成 1.HTTP 请求的方法或动作：比如是 GET 请求还是 POST 请求2.正在请求的 URL，我们总是要知道请求的地址是啥把3.请求头，包含了一些客户端环境信息，身份验证信息等等4.请求体，也就是请求正文，请求正文中可以包含客户提交的查询字符串信息，表单信息等等 注意：请求头和请求体中有个空行表示：请求头已经结束了，接下来是请求体接下来我们来看看一个标准的 http 请求 GET 和 POST 的区别GET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get 是默认的 http 请求方法，get 请求一般是安全的，用于获取信息，而不是修改信息。换句话说，get 请求一般是用来查询，我们的查询不会影响数据本身。一般不用 get 请求来新建和修改操作。get 请求发送的信息对任何人都是可见的。因为所有的变量名和值都显示在 url 当中。也就是说 get 请求是用 url 来传递参数的。就因为如此，get 请求对发送的信息是有数量限制的。虽然变量是明文的，对任何人都可见，但是也有好处，就是把页面添加在书签里就可以使用。说了这么多，我们来总结下 get 把。 1.一般用于信息的获取 2.使用 url 来传递参数 3.对发送的信息有数量限制，一般在 2000 个字符 POST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对于 get 请求，post 请求就安全很多。从字面理解，posy 是向服务器发送一些信息，一般用于修改服务器上的资源。posy 一般用于从表单发送一些数据，这些数据并不在 url 里显示，对其他人是不可见的。所有的名称和值都会被嵌入 http 的请求体中。它对发送信息的数量没有限制。用简短的语句归纳下 post 吧。 1.一般用于修改服务器上的资源2.对所发送的信息无数量限制 HTTP 响应组成 1.一个数字和文字组成的状态码，用来显示请求成功还是请求失败2.响应头，响应头和请求头一样，包含很多有用的信息。例如服务器的类型、日期时间、内容类型和长度等等。3.响应体，也就是响应正文。例如从服务器传过来的字符串、代码等等。 接下来我们来看看一个标准的 http 响应 HTTP 状态码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态码的好处就是：有助于外部程序调试的效率和准确性。HTTP 状态码由 3 位数字构成，其中首位数字定义了状态码的类型。 1XX：信息类，表示收到 WEB 浏览器的请求，正在进一步的处理中2XX：成功，表示用户请求被正确接收，理解和处理。例如：200 OK3XX：重定向，表示请求没有成功，用户必须采取进一步的动作4XX：客户端错误，表示客户端提交的请求有错误。最常见的就是：404 NOT FOUND，代表客户端请求地址不存在。5XX：服务器错误，表示服务器不能完成对 HTTP 请求的处理。最经常出现的就是 500 错误，出现这个错误，大家都很头疼。","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"http","slug":"http","permalink":"https://gwjacqueline.github.io/tags/http/"}]}]}