{"meta":{"title":"guowj","subtitle":"The fear of Jehovah is the beginning of wisdom, And the knowledge of the Holy One is understanding.","description":"个人技术博客","author":"guowj","url":"https://gwjacqueline.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-04-04T12:54:25.000Z","updated":"2019-04-04T12:54:25.000Z","comments":true,"path":"categories/index.html","permalink":"https://gwjacqueline.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-04T12:52:08.000Z","updated":"2019-04-04T12:52:08.000Z","comments":true,"path":"tags/index.html","permalink":"https://gwjacqueline.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git常用命令","slug":"Git常用命令","date":"2019-05-11T01:25:32.000Z","updated":"2019-05-13T05:39:40.000Z","comments":true,"path":"Git常用命令/","link":"","permalink":"https://gwjacqueline.github.io/Git常用命令/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Git 是一个版本管理工具，和 SVN 不同的是，SVN 是集中式的版本控制系统，Git 是分布式版本控制系统。这篇文章主要是简单总结下 Git 和一些常用的 git 命令。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Git 是一个版本管理工具，和 SVN 不同的是，SVN 是集中式的版本控制系统，Git 是分布式版本控制系统。这篇文章主要是简单总结下 Git 和一些常用的 git 命令。 GitGit 的区域1.工作区（working tree） 2.暂存区（stage） 3.版本库（repository） Git 文件的四种转态1.Untracked(未被跟踪)此文件在文件夹中,还没有加入到 git 库,不参与版本控制。通过 git add 状态变为 暂存状态2.Modified表示工作区修改了某个文件，但是还没有添加到暂存区3.Staged表示工作区修改的文件添加到了暂存区但是还没有添加到版本库4.committed表示数据被安全的存在本地库中 常用命令基础命令初始化本地仓库 1git init 查看工作区、暂存区的状态 1git status 将工作区新建/修改的内容添加到暂存区 1git add &lt;file&gt; 将暂存区的内容提交到本地库 1git commit -m &quot;备注&quot; 查看历史记录 1git log 新增、更改 Git 的各种设置 1234git config//例如配置系统级别签名git config --global user.name &quot;&lt;username&gt;&quot;git config --global user.email &quot;&lt;eamil&gt;&quot; 删除某个文件 1git rm --cached &lt;file&gt;; 上传到远程仓库 1234//增加一个名称为origin远程仓库git remote add origin &lt;address&gt;//推送远程仓库git push -f origin master 克隆到本地 1git clone &lt;address&gt; 撤销操作撤销上一次的提交，并将暂存区的文件重新提交，如果没有修改信息的话，就只是提交描述信息 1git commit —amend 拉取暂存区文件 并将其替换成工作区文件 1git checkout -- &lt;file&gt; 拉取最近一次提交到版本库的文件到暂存区，该操作不影响工作区 12//HEAD也可以直接换成版本号git rest HEAD &lt;file&gt; 以上两条操作会导致：暂存区和本地文件不一样，暂存区和版本库不一样。需要使git checkout –[file]命令来把 暂存区文件拉到工作区再将暂存区的文件拉回到工作区中。 分支操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建分支的好处是不会影响当前主线的文件。 比如再已上线的代码中新增需求时，在我们自己的分支中操作不会影响主线的项目。 查看当前分支 1git branch 创建分支 12//注意新分支创建后不会自动切换为当前分支git branch &lt;name&gt; 创建新分支并立即切换到新分支 1$ git checkout -b &lt;name&gt; 删除分支 12//d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项git branch -d [name] 切换分支 1git checkout &lt;name&gt; 切换主线 1git checkout master Git 指针 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面这张图能够更快的帮我们理解git指针。版本号1，2，5为master主线，版本号3，4为dev分支。首先，当我们提交了一个版本的时候，就会有一个版本号，就有两个指针指向我们的版本。一个是master分支，一个是HEAD指针，指向当前分支的最后一个版本。当我们修改文件，再次提交后，会有一个新的版本号，同时，我们的分支和HEAD指针也会指向我们最后一次提交。最新版本中也有一个指针指向前一个版本。指针是我们文件中有一块地方保存其他模块的地址。当我们调用其他模块的时候，可以通过这个模块找到其他模块的地址。从而调用其他模块，达到方便访问其他模块的目的。master分支保存了M2版本的地址。同样的再提交一个版本，master指针和HEAD指针都会向前移。当我们再这里新建了一个分支时，比如dev分支。master分支仍会指向版本号二。新建的这个分支会指向版本号三，而HEAD指针从版本号2移到了版本号3.只有当从master分支的版本号2切换到dev 分支的版本号3的时候，HEAD指针会从版本号2移到版本号3。HEAD指针永远指向当前分支的最新版本。当提交到版本号4后，dev分支会和HEAD同时指向最新版本。当这个时候想合并我们的dev分支和master分支时。形成了版本号5分支，版本号5即指向我们的版本号2,又指向版本号4，也就是说他能很快速的访问版本号2,也可以很快速的访问版本号4。分支的指针仅仅保存的是地址。当我们切换版本时，当我们从一个版本回退到另一个版本的时候，分支的指针是直接将他们的地址进行更改。从我们的版本号5的地址换成了版本号2的地址。所以git版本的回退特别快。切换分支时，git是通过判断HEAD是不是指向当前版本。 合并分支及冲突解决合并分支 1git merge &lt;name&gt; 冲突解决在使用 Git 进行多人合作的时候 我们时常会出现冲突。比如我们在分支 A 修改了 index.html 文件并提交到了分支 A 的版本库，同时 master 分支也修改了该文件。即主分支和我们要合并的分支都发生了修改 这时系统就不知道我们要保留哪一个文件 就会发生冲突 1CONFLICT（content）：Merge conflict in index.html 修改冲突文件:我们发现系统把 Master 和 A 分支的内容都列出来了。这时我们想保留那个就把另一个删除即可。然后再添加并提交，就可以合并成功啦。 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD&lt;p&gt;Hello world!&lt;/p&gt;=======&lt;p&gt;Hello world2!&lt;/p&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A 版本差异比较比较工作区和暂存区文件的差异 1git diff 比较暂存区和版本库之间的差异 1git diff — staged 比较两个版本之间的差异 12//版本号最少选4个，git默认是7个，最好选8-10个，这样能保证唯一性git diff &lt;version&gt; &lt;version&gt; 两个分支之间的差异 1git diff &lt;branch&gt; &lt;branch&gt; 存储变更&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上切换分支前，需要把当前分支的修改提交，或者放到暂存区中，否则会报错。解决：将工作区修改的内容暂存起来,并自动切换到修改前的工作区状态 1git stash &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;暂存后，再切换分支就不会报错了。git 在进行分支切换时，它主要改变我们的版本库。当工作区有改变时，会将我们工作区的文件直接覆盖到另外一个分支上去，从而影响另外一个分支。所以使用 git stash 时，将工作区和暂存区的东西封存。git 也会自动将工作区的改变变回改变前的转态查看保存内容列表 1git stash list git stash list 后看到暂存区的东西 12stash@&#123;0&#125;: WIP on master: 452b08d rename hello as hello.cstash@&#123;1&#125;: WIP on master: 452b08d rename hello as hello.c 将暂存区的东西拉回工作区 1git stash apply stash@&#123;x&#125; 将暂存区的东西删除 1git stash drop stash@&#123;x&#125; 将暂存区的东西拉回工作区并删除 1git stash apply stash@&#123;x&#125;","categories":[{"name":"工具","slug":"工具","permalink":"https://gwjacqueline.github.io/categories/工具/"}],"tags":[{"name":"版本管理工具","slug":"版本管理工具","permalink":"https://gwjacqueline.github.io/tags/版本管理工具/"}]},{"title":"走进Webpack的大门","slug":"走进Webpack的大门","date":"2019-05-05T08:32:20.000Z","updated":"2019-05-13T05:42:56.000Z","comments":true,"path":"走进Webpack的大门/","link":"","permalink":"https://gwjacqueline.github.io/走进Webpack的大门/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Webpack 是一个 js 应用程序的静态模块打包器。本身只能打包 js 模块，我们可以通过 loader 让 webpack 去处理那些非 JS 文件。它会将所有类型的文件，转化为应用程序的依赖图。总而言之，webpack 是一个能实现模块化打包的工具。之前的项目一直采用 gulp 进行打包，gulp 和 webpack 相比，gulp 是一种能够优化前端的开发流程的工具，而 WebPack 是一种模块化的解决方案。接下来，我将从 webpack 的工作方式、安装、使用、构建本地服务器以及 entry(入口)、output(出口)、loader、plugins(插件)四个核心概念总结下 webpack。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Webpack 是一个 js 应用程序的静态模块打包器。本身只能打包 js 模块，我们可以通过 loader 让 webpack 去处理那些非 JS 文件。它会将所有类型的文件，转化为应用程序的依赖图。总而言之，webpack 是一个能实现模块化打包的工具。之前的项目一直采用 gulp 进行打包，gulp 和 webpack 相比，gulp 是一种能够优化前端的开发流程的工具，而 WebPack 是一种模块化的解决方案。接下来，我将从 webpack 的工作方式、安装、使用、构建本地服务器以及 entry(入口)、output(出口)、loader、plugins(插件)四个核心概念总结下 webpack。 工作方式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Webpack 会把你的项目当做一个整体，通过给定的主文件（例如：index.js）开始找到你项目所有的依赖文件，并使用 loaders 去处理它们，最后打包为一个或多个浏览器可识别的 JS 文件。把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack 将从这个文件开始找到你的项目的所有依赖文件，使用 loaders 处理它们，最后打包为一个（或多个）浏览器可识别的 JavaScript 文件。 安装1234//全局安装webpack以及脚手架npm install webpack webpack-cli -g//局部安装npm install webpack webpack-cli -S 使用1.新建空文件夹2.cd 到需要打包的项目 3.创建一个标准的 npm 说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等 1npm init 4.安装 webpack 到项目目录 1npm install webpack webpack-cli -S 5.配置webpack.config.js 6.启动 webpack 进行打包 1234//生产环境webpack --mode production//开发环境，可通过package.json快捷配置，下面说webpack --mode development 构建本地服务器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;webpack-dev-server基于 node.js 构建。能够帮助浏览器监听你的代码的修改，并自动刷新显示修改后的结果。我们需要先安装下。 1npm install webpack-dev-server -S webpack.config.js 中配置 1234567891011121314module.exports = &#123; devServer: &#123; //本地服务器加载的页面所在的目录 contentBase: &quot;./build&quot;, //实时刷新 inline: true, //如果设置为true，所有的跳转将指向index.html。针对单页面应用 historyApiFallback: false, //监听端口,默认为8080 port:4040, //默认为index.html index: &apos;main.html&apos; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体配置可以查看这里。接下来我们把运行命令配置到 npm 的 script 中。因为真正开发的时候 webpack 命令会敲很长，我们在 package.json 中设置 scripts 值就可以去调用对应的指令，是非常方便快捷的。 package.json 1234&quot;scripts&quot;: &#123; &quot;deploy&quot;: &quot;webpack --mode development&quot;, &quot;dev&quot;: &quot;webpack-dev-server --open --inline&quot; &#125;, 在根目录下执行命令 生成未压缩的代码 1npm run deploy 启动服务器 1npm run dev &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行后，webpack 会自动帮我们启动一个 web 服务器，并监听文件修改，然后自动重新合并代码。 entry(入口)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry 告诉 webpack 应该使用哪个模块作为内部依赖图的起始点。进入起始点后，webpack 会找出哪些模块和库是起始点所依赖的。每个依赖被处理后，最后会被输出到 bundles 文件中。 webpack.config.js 123456//里面采取commonJs的书写规范，比如module.exports语法module.exports = &#123; //唯一入口文件 //默认值为‘./src’ entry: &apos;./src/index.js&apos;&#125;; output(出口)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output 告诉 webpack 在哪里输出它所创建的 bundles，以及该如何命名这些文件。 webpack.config.js 123456789101112//path模块是从node.js导入的，主要用来控制生成文件的目录const path = require(&apos;path&apos;);module.exports = &#123;//默认值为‘./dist’ output: &#123; //将参数中的路径、路径片段解析成一个绝对地址。_dirname表示当前文件所在的绝对路径 path: path.resolve(__dirname, &apos;build&apos;), //打包后输出文件的文件名 filename: &apos;js/index-[hash].js&apos; &#125;,&#125;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 webpack.config.js 中配置了出入口后，我们只需在终端里运行 webpack，就会自动引用 webpack.config.js 文件中的配置选项。 loader&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;webpack 本身只支持 js,不支持 image、css、html…,如果要让 webpack 支持这些，就需要使用 loader。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后我们就可以利用 webpack 的打包能力，对它们进行处理。记录下我常用的 loader 吧。 scss,css 打包压缩安装编译打包 scss、css 1npm install style-loader css-loader node-sass sass-loader -S 使用 Extract Text Plugin 插件。将 css 各文件分离，生成的文件 不嵌入 bundle.js，而是放在单独的文件里。 1npm install extract-text-webpack-plugin@next -S 使用1.代码将打包到入口文件里 1import &quot;../scss/style.scss&quot;; 2.修改 webpack.config.js 123456789101112131415161718192021222324252627282930313233343536//css各文件分离const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; hashDigestLength: 8 // 默认长度是20 &#125; //loader module: &#123; rules: [ &#123; test: /\\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, //将 JS 字符串生成为 style 节点 use: [&#123; loader: &apos;css-loader&apos;, // \b将 CSS 转化成 CommonJS 模块 options: &#123; modules: true, // 指定启用css modules localIdentName: &apos;[name]__[local]--[hash:base64:5]&apos; // 指定css的类名格式 &#125; &#125;, &#123; loader: &apos;sass-loader&apos; // 将 Sass 编译成 CSS &#125;,] &#125;) &#125; ] &#125;, //插件 plugins: [ new ExtractTextPlugin(&apos;./css/[name]-[hash].css&apos;), //生成文件的文件名 ]&#125; css 模块化&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SS modules 的技术意在把 JS 的模块化思想带入 CSS 中来，通过 CSS 模块,所有的类名只作用于当前模块。通过在 CSS loader 进行配置，就可以直接把 CSS 的类名传递到组件的代码中，这样做有效避免了全局污染。 1.使用： webpack.config.js 1234options: &#123; modules: true, // 指定启用css modules localIdentName: &apos;[name]__[local]--[hash:base64:5]&apos; // 指定css的类名格式&#125; index.js 123import styles from &quot;../scss/style.scss&quot;;document.write(&apos;&lt;div class=&quot;&apos; + styles.green + &apos;&quot;&gt;绿色&lt;/div&gt;&apos;);let a = 10; style.scss 123.green &#123; color: green;&#125; 最后结果： 1&lt;div class=&quot;style__green--XLkki&quot;&gt;绿色&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，即使相同的类名也不会造成不同组件之间的污染 图片css 自动添加前缀1.安装 1npm install postcss-loader autoprefixer -S 2.使用 12345678910111213141516171819202122232425262728293031323334module.exports = &#123; //loader module: &#123; rules: [ &#123; test: /\\.(scss|css)$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&#123; loader: &apos;css-loader&apos;, options: &#123; modules: true, localIdentName: &apos;[name]__[local]--[hash:base64:5]&apos; &#125; &#125;, &#123; loader: &apos;sass-loader&apos; &#125;, &#123; //添加前缀 loader: &quot;postcss-loader&quot;, options: &#123; plugins: [ require(&apos;autoprefixer&apos;)(&#123; browsers: [&apos;last 100 versions&apos;] //必须设置支持的浏览器才会自动添加添加浏览器兼容 &#125;) ] &#125; &#125;,], publicPath: &quot;../&quot;, &#125; ), &#125;, ] &#125;&#125; css 中的图片处理安装1npm install file-loader -S 使用1.修改 webpack.config.js 1234567891011121314151617181920212223module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; hashDigestLength: 8 // 默认长度是20 &#125; //loader module: &#123; rules: [ &#123; test: /\\.(png|jepg|jpg)$/, use: [ //loader 后面 limit 字段代表图片打包限制，这个限制并不是说超过了就不能打包，而是指当图片大小小于限制时会自动转成 base64 码引用 //name 字段来指定图片打包的目录与文件名 &#123; loader: &apos;url-loader?limit=1024&amp;name=./image/[name]-[hash:8].[ext]&apos; &#125; ] &#125; ] &#125;&#125; html 中的图片&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用’url-loader‘只能将 css 中的图片进行打包，如果想将 html 中图片进行打包，需要用到html-withimg-loader插件 安装1npm install html-withimg-loader -S 使用123456789101112131415161718192021module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; hashDigestLength: 8 // 默认长度是20 &#125; //loader module: &#123; rules: [ &#123; test: /\\.html$/, use: [ &#123; loader: &apos;html-withimg-loader&apos; &#125; ] &#125; ] &#125;&#125; js 中的图片&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 js 中引用的图片应该通过模块化的方式引用图片路径，才可以成功打包。 使用12var imgUrl = require(&apos;../image/js.png&apos;);document.write(&apos;&lt;img src=&quot;&apos; + imgUrl + &apos;&quot; /&gt;&apos;); 字体图标12345678910111213141516171819module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; hashDigestLength: 8 // 默认长度是20 &#125; //loader module: &#123; rules: [ &#123; test:/\\.(woff|ttf|svg|eot|xttf|woff2)$/, use: &apos;url-loader?limit=1024&amp;name=./fonts/[name].[ext]&apos; &#125; ] &#125;&#125; Babel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Babel 能让帮助我们将 ES6、ES7 等新标准被当前使用的浏览器支持。能让我们使用基于 JS 进行的扩展语言，比如 React 的 JSX。 安装1npm install babel-core babel-loader@7 babel-preset-env babel-preset-react -S 使用12345678910111213141516171819202122module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; hashDigestLength: 8 // 默认长度是20 &#125; //loader module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: &quot;babel-loader&quot; &#125;, exclude: /node_modules/ //不要进行 babel-loader &#125;, ] &#125;&#125; plugins 插件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插件接口使 webpack 变得更加灵活。记录下我常用的插件把。 html-webpack-plugin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户可以使用模版，通过 webpack 生成 html 文件。 1.安装 1npm install html-webpack-plugin -S 2.使用 12345678910111213141516171819202122232425const path = require(&apos;path&apos;);//添加插件const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &apos;学习 webpack&apos;, template: &quot;./src/html/main.html&quot;, //模版的路径 filename: &apos;html/main.html&apos;, //生成html的文件 minify: &#123; removeAttributeQuotes: true,//去除引号 removeComments: true,//去除注释 removeEmptyAttributes: true,//去除空属性 collapseWhitespace: true//去除空格 &#125; &#125;) ]&#125; 3.注意： 当和“html-withimg-loader”一起使用时，会导致 html 文件中的类似&lt;%= htmlWebpackPlugin.options.title%&gt;无法解析。但是我们可以通过 requier 引入图片解决办法： 12//index.html&lt;img src=&quot;&lt;%= require(&apos;../image/html.png&apos;)%&gt;&quot; alt=&quot;picture&quot; /&gt; clean-webpack-plugin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加了 hash 之后，会导致改变文件内容后重新打包时，文件名不同而内容越来越多，clean-webpack-plugin可以帮助我们删除残余文件。 1.安装 1npm install clean-webpack-plugin -S 2.使用 1234567891011121314const path = require(&apos;path&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; &#125;, plugins: [ new CleanWebpackPlugin() ]&#125; BannerPlugin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加版权声明的插件 1.使用 1234567891011121314const path = require(&apos;path&apos;);const webpack = require(&apos;webpack&apos;);module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; &#125;, plugins: [ new webpack.BannerPlugin(&apos;版权所有&apos;), ]&#125; 2.效果 123//index.js/*! 版权所有 */!function(e)(); webpack.optimize.OccurenceOrderPlugin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该插件的作用是为组件分配 id，通过这个插件 webpack 会分析使用频率最多的模块，并未他们分配最小的 id，id 越小表示模块被找到的速度会更快。此为内置插件，所以不需要安装。使用 12345678910111213const webpack = require(&apos;webpack&apos;);module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; &#125;, plugins: [ new webpack.optimize.OccurrenceOrderPlugin(), ]&#125; webpack.ProvidePlugin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是一个全局挂载插件。可以自动加载模块，无需每处 import 或 require。如果项目中需要使用 jQuery 类似的工具，使用它，可以使 jquery 变成全局变量，这样在项目的任何地方都可以直接使用。它也是内置插件，不需要安装。使用 安装 jquery 依赖 1npm install jquery webpack.config.js 1234567891011121314151617const webpack = require(&apos;webpack&apos;);module.exports = &#123; // 入口 entry: &apos;./src/js/index.js&apos;, // 出口 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;js/index-[hash].js&apos; &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot;, &quot;window.jQuery&quot;: &quot;jquery&quot; &#125;), ]&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;webpack 的 loader 和 plugin 非常多，这里只列出了一些常用的。具体的请看官网。以上完整的 demo 在这里查看。","categories":[{"name":"工具","slug":"工具","permalink":"https://gwjacqueline.github.io/categories/工具/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"https://gwjacqueline.github.io/tags/模块化/"},{"name":"模块打包机","slug":"模块打包机","permalink":"https://gwjacqueline.github.io/tags/模块打包机/"}]},{"title":"移动端常见兼容性问题(二)","slug":"移动端常见兼容性问题(二)","date":"2019-04-27T07:46:46.000Z","updated":"2019-05-08T11:43:43.000Z","comments":true,"path":"移动端常见兼容性问题(二)/","link":"","permalink":"https://gwjacqueline.github.io/移动端常见兼容性问题(二)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;之前的文章写了一些移动端常见的兼容性问题，本文将继续总结一些兼容问题的解决套路。","text":"&nbsp;&nbsp;&nbsp;&nbsp;之前的文章写了一些移动端常见的兼容性问题，本文将继续总结一些兼容问题的解决套路。 fixed 定位问题 主要代码：1234567891011121314151617181920&lt;style&gt;//红框部分.city&#123; position:fixed; top:50px; height:300px; overflow:auto; -webkit-overflow-scrolling:touch; z-index:100;&#125;&lt;/style&gt;&lt;body&gt; //绝对定位 &lt;header&gt;&lt;/header&gt; //下半部分绝对定位 &lt;div&gt; //红框部分 &lt;div class=&quot;city&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; bug 描述：1.在安卓机上，红框部分，超过的文字，无法通过滑动查看 2.在 ios 上，红框部分会随下半部分一起滚动。 bug 解决：123456789101112131415161718192021&lt;style&gt;//红框部分.city&#123; position:fixed; top:50px; //把高度去掉，改为Bottom bottom:50px; overflow:auto; -webkit-overflow-scrolling:touch; z-index:100;&#125;&lt;/style&gt;&lt;body&gt; //绝对定位 &lt;header&gt;&lt;/header&gt; //下半部分绝对定位 &lt;div&gt; &lt;/div&gt; //将红框部分移出 &lt;div class=&quot;city&quot;&gt;&lt;/div&gt;&lt;/body&gt; ios 后台倒计时停止主要代码：12345678var count = 30;var inter = setInterval(clock, 1000);function clock() &#123; count-- if (count &lt; 1) &#123; clearInterval(inter); &#125;&#125; bug 描述：ios 切换到后台程序后，倒计时就停止了 bug 解决：12345678910111213var old = new Date().getTime();var count = 30;var inter = setInterval(clock, 1000);function clock() &#123; //计时器实时计算当前时间 var now = new Date().getTime(); var count = 30 - Math.floor((parseInt(now) - parseInt(old)) / 1000); $(&quot;.clock&quot;).html(count); if (count &lt; 1) &#123; clearInterval(inter); &#125;&#125; 采用实时计算时间差的方式解决，具体效果可看倒计时测试 ios input disabled 灰色 bug 描述：ios 下输入框为 disabled 时，默认字体为灰色 bug 解决：123input:disabled,textarea:disabled&#123; -webkit-opacity:1;&#125; 华为、小米键盘遮住输入框主要代码：123456789101112131415161718&lt;style&gt;body&#123; height:100%;&#125;.main&#123; top:0; bottom:0; left:0; right:0; background-image:cover; overflow:auto;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;main&quot;&gt; //里面的所有输入框为自然布局 &lt;/div&gt;&lt;/body&gt; bug 描述：点击页面较下面的输入框，键盘会遮挡输入框，且无法上拉页面。 bug 解决：方法 1：可以上拉页面看到输入框 1234567&lt;style&gt;.main&#123; height:100%; background-image:cover; overflow:auto;&#125;&lt;/style&gt; 方法 2：可以自动顶起输入框 123456789101112131415161718(function()&#123; var screenH=$(document).height(); $(&apos;input&apos;).focus(function()&#123; var top = $(this).offset().top; var h=$(this).height(); if(top+h&gt;screenH/2)&#123; var scrollTop = $(&quot;滚动主体&quot;).scrollTop(); $(&quot;滚动主体&quot;).append(&quot;&lt;div class=&apos;addHeight&apos;&gt;&lt;/div&gt;&quot;); $(&quot;.addHeight&quot;).css(&apos;padding-bottom&apos;,screenH/2+&apos;px&apos;); $(&quot;滚动主体&quot;).scrollTop(screenH/2+screenTop-20); &#125; &#125;); $(&apos;input&apos;).blur(function()&#123; if($(&quot;.addHeight&quot;).length&gt;0)&#123; $(&quot;.addHeight&quot;).remove(); &#125; &#125;);&#125;)(); ios 键盘挡住输入框 主要代码：12345678910111213141516171819202122232425262728293031323334353637&lt;style&gt; header &#123; height: 50px; background-color: red; top: 0; bottom: 0; left: 0; right: 0; position: absolute; &#125; .content &#123; top: 50px; left: 0; right: 0; bottom: 0; padding-bottom: 50px; overflow: auto; position: absolute; background-color: green; &#125; .bottom &#123; position: fixed; bottom: 0; left: 0; right: 0; height: 50px; background-color: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;header&gt;头部&lt;/header&gt; &lt;div class=&quot;content&quot;&gt; &lt;input type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;我是固定在底部的按钮&lt;/div&gt;&lt;/body&gt; bug 描述：点击图中圈出的黄色输入框，键盘会遮住输入框，无法上弹 bug 解决：123456789101112&lt;style&gt; .content &#123; top: 50px; left: 0; right: 0; bottom: 50px; &lt;!-- padding-bottom: 50px; --&gt; overflow: auto; position: absolute; background-color: green; &#125;&lt;/style&gt; 部分 Ios 手机不支持 css:focus:validbug 描述：当给输入框加属性 required 的时候，用:focus:valid 加样式，部分手机不支持。但是单独支持:focus/:valid。 bug 解决：用 js 判断，加样式。 ios 光标上下飘 1234滚动部分&#123; -webkit-overflow-scrolling:touch; overflow:auto;&#125; bug 描述：当两个样式并存时，拖动正在输入的页面，光标就会上下飘动。 bug 解决：目前找到原因是因为这两个样式并存会导致。目前没有找到好的解决办法 IOS 点击闪屏问题bug 描述：点击页面，会出现闪屏现象 bug 解决：123html,body&#123; -webkit-tap-highlight-color: transparent;&#125;","categories":[{"name":"css","slug":"css","permalink":"https://gwjacqueline.github.io/categories/css/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://gwjacqueline.github.io/tags/移动端/"},{"name":"兼容性","slug":"兼容性","permalink":"https://gwjacqueline.github.io/tags/兼容性/"}]},{"title":"js/jq封装插件的套路","slug":"js-jq封装插件的套路","date":"2019-04-26T07:05:38.000Z","updated":"2019-05-13T01:24:55.000Z","comments":true,"path":"js-jq封装插件的套路/","link":"","permalink":"https://gwjacqueline.github.io/js-jq封装插件的套路/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们小组这周分享了有关于“js 插件封装的方法”。颇有心得，就整理出了一套封装插件的固定模板公式，简称套路，百试百灵。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们小组这周分享了有关于“js 插件封装的方法”。颇有心得，就整理出了一套封装插件的固定模板公式，简称套路，百试百灵。 好插件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们先来说说怎么样封装插件，才叫一个好插件。它需要满足以下几点： 1.代码能够很好的复用2.插件自身的作用域要与用户当前的作用域相互独立，避免各个相同功能组件的干扰3.插件有默认参数且支持使用者修改4.需提供针对事件的监听接口，便于使用者使用5.支持链式调用6.便于维护 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说完了一个好插件应该具备的条件，接下来我们通过 js 和 jquery 两种方式通过实现简单加减乘除的运算来总结一下插件封装的套路把。 JS插件最外层123;(function (global, undefined) &#123; &quot;use strict&quot;;&#125;)(this) 1.在最前面加了” ; “是为了防止跟其他 js 压缩时报错。 2.因为 JS 变量的调用，从全局作用域上查找速度会比私有作用域里慢的多，所以我们需要用闭包的方式。封装的时候把 js 代码放到一个自执行函数里，不仅可以延长插件内部变量的生命周期，让插件可以重复调用，还可以防止变量冲突。 3.使用严格模式，它是一种特殊的执行模式，可以修复部分语言上的不足，提供更强的错误检查，并增强安全性。4.undefined 是为了兼容较老的浏览器。最后传 this，而不是 window 或者 global，是因为不确定我们的兼容浏览器端和非浏览器端。直接取全局变量 this 作为局部变量使用，可缩短访问时间。 创建构造函数并初始化变量1234567891011121314151617;(function (global, undefined) &#123; &quot;use strict&quot;; //定义一个类，通常首字母大写 var Cal = function (options) &#123; //传参 this.options = $.extend(&#123;&#125;, Cal.DEFAULTS, options || &#123;&#125;); //在初始化执行一些操作 this.init(); &#125;; //默认参数列表 Cal.DEFAULTS = &#123; x: 1, y: 2 &#125;; //把这个函数暴露给外部，以便全局调用 global.Cal = Cal;&#125;)(this) 1.利用 \\$ .extend 用来合并默认参数和用户传进来的参数 \\$.extend( [deep ], target, object1 [, objectN ] )deep:可选，默认为 false.如果该值为 true，且多个对象的某个同名属性也都是对象，则该”属性对象”的属性也将进行合并target:Object 类型 目标对象，其他对象的成员属性将被附加到该对象上。object1:可选。Object 类型 第一个被合并的对象。objectN:可选。Object 类型 第 N 个被合并的对象。 12345678910111213141516var item1 = &#123; name: &quot;Lili&quot;, age: 14, sex: &quot;girl&quot;, address: &#123; pro: &quot;cc&quot; &#125;&#125;;var item2 = &#123; name: &quot;Lucy&quot;, age: 18, address: &#123; pro: &quot;zh&quot;, city: &quot;x&quot; &#125;&#125;;//默认为falsevar result = $.extend(false,item2, item1);var resultTrue = $.extend(true, &#123;&#125;, item2, item1);console.log(result); //&#123;name: &quot;Lili&quot;, age: 14, sex: &quot;girl&quot;,address: &#123;pro: &quot;cc&quot;&#125;&#125;console.log(resultTrue); //&#123;name: &quot;Lili&quot;, age: 14, sex: &quot;girl&quot;, address: &#123;pro: &quot;zh&quot;, city: &quot;x&quot;&#125;&#125; 2.插件的定义和执行都在闭包中，所以他们的作用域也就是这个闭包函数，只有绑定到全局对象上，我们才可以调用。 利用原型链12345678910111213141516171819//原型链上提供方法Cal.prototype = &#123; //定义方法 init() &#123; console.log(`你输入的两个参数分别为$&#123;this.options.x&#125;,$&#123;this.options.y&#125;`); &#125;, add() &#123; return `计算结果为$&#123;this.options.x + this.options.y&#125;` &#125;, sub() &#123; return `计算结果为$&#123;this.options.x - this.options.y&#125;` &#125;, rid() &#123; return `计算结果为$&#123;this.options.x * this.options.y&#125;` &#125;, div() &#123; return `计算结果为$&#123;this.options.x / this.options.y&#125;` &#125;&#125;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 js 中，所有对象都是继承自原型的，所以对象都有一个proto的内置属性用于指向创建它的函数对象的原型对象 prototype。有关与原型链和继承的问题，可以看看之前的文章。一般我们都将方法写在原型里，将属性写在构造函数里。因为方法写在原型中比写在构造函数中消耗的内存更小，因为在内存中一个类的原型只有一个，写在原型中的行为可以被所有实例共享，实例化的时候并不会在实例的内存中再复制一份。而写在类中的方法，实例化的时候会在每个实例中再复制一份，所以消耗的内存更高。 兼容多种模块规范12345678//兼容CommonJs规范if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123; module.exports = Cal;&#125;;//兼容AMD/CMD规范if (typeof define === &apos;function&apos;) define(function () &#123; return Cal;&#125;); 完整套路123456789101112131415161718192021222324252627282930;(function (global, undefined) &#123; //使用严格模式 &quot;use strict&quot;; //创建一个构造函数 var X = function (options) &#123; //合并参数 this.options = $.extend(&#123;&#125;, X.DEFAULTS, options || &#123;&#125;); &#125;; X.DEFAULTS = &#123; //默认参数 &#125;; //原型链上提供方法 X.prototype = &#123; //定义方法 &#125;; //兼容CommonJs规范 if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123; module.exports = X; &#125;; //兼容AMD/CMD规范 if (typeof define === &apos;function&apos;) define(function () &#123; return X; &#125;); //暴露给外部 global.X = X;&#125;)(this)//调用new X(&#123; //参数&#125;); 改写 ES6123456789101112131415161718192021222324252627282930313233343536373839404142434445(function (global, undefined) &#123; //检测传入的参数类型是否为对象，若不是则抛出错误 if (arguments.length &gt; 0 &amp;&amp; (typeof options).toLowerCase() !== &apos;object&apos;) &#123; throw new TypeError(options + &apos;is not a Object&apos;); &#125; //定义了一个名字为Cal的类 class Cal &#123; //constructor是一个构造方法，用来接收参数 constructor(options) &#123; //传入参数覆盖默认值 //this代表的是实例对象 this.options = Object.assign(&#123; x: 1, y: 2 &#125;, options); this.init(); &#125; //这是一个类的方法，注意千万不要加上function init() &#123; console.log(`你输入的两个参数分别为$&#123;this.options.x&#125;,$&#123;this.options.y&#125;`); &#125; //方法之间不要用逗号分隔，否则会报错 add() &#123; return `计算结果为$&#123;this.options.x + this.options.y&#125;` &#125; sub() &#123; return `计算结果为$&#123;this.options.x - this.options.y&#125;` &#125; rid() &#123; return `计算结果为$&#123;this.options.x * this.options.y&#125;` &#125; div() &#123; return `计算结果为$&#123;this.options.x / this.options.y&#125;` &#125; &#125; global.Cal = Cal;&#125;)(this);var t = new Cal(&#123; x: 5, y: 6&#125;);console.log(t.add()); //计算结果为11console.log(t.sub()); //计算结果为-1console.log(t.rid()); //计算结果为30console.log(t.div()); //计算结果为0.8333333333333334 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明显看出，ES6 中新引入了 class 关键字可以定义类。相比于 ES5，不仅代码量少了很多，写法上也更加清晰，更像是一种面向对象的语言。类自身指向的就是构造函数，所以我们可以当 class 其实是构造函数的另外一种写法。constructor 方法是类的构造函数的默认方法，当我们通过 new 生成对象实例时，会自动调用该方法。如果 construtor 方法没有显示定义，会隐式生成一个 constructor 方法且默认返回实例对象 this。constructor 中定义的属性为实例属性，也就是定义在 this 对象上的。constructor 外声明的属性是定义的原型上的。这里在书写的时候要注意两点：1.写一个类的方法，注意不要加上 function2.方法之间不要用逗号分隔 JQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接下来我们通过 jQ 的两种使用方法 jQuery.function() 和 jQuery(“selector”)来看看如何用 jq 封装插件。 jQuery.fn1234567891011121314151617181920212223242526//利用闭包创建一个自执行的函数(function ($) &#123; &quot;use strict&quot;; function Cal(element, options) &#123; this.$element = $(element); this.options = $.extend(&#123;&#125;, Cal.DEFAULTS, options || &#123;&#125;); &#125; function Plugin(option) &#123; var args = Array.prototype.slice.call(arguments, 1); //链式调用 return this.each(function () &#123; //单例模式 var $this = $(this), cal = $this.data(&apos;cal&apos;); if (!cal) &#123; $this.data(&apos;cal&apos;, (cal = new Cal(this, option))); &#125; if (typeof option == &apos;string&apos;) &#123; cal[option] &amp;&amp; cal[option].apply(cal, args); &#125; &#125;); &#125; $.fn.Cal = Plugin;&#125;)(jquery); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上我们将之前写的 JS 插件改写成了 jquery 的形式。通过运用面向对象的思维方式，在 jquery 的原型上扩展方法。1.链式调用：return.this:返回当前对象，来维护插件的链式调用.each: 循环实现每个元素的访问2.单例模式利用 data 来存放插件对象的实例，如果实例存在，则不再重新创建 完整套路12345678910111213141516171819202122232425262728293031323334353637//利用闭包创建一个自执行的函数(function () &#123; //使用严格模式 &quot;use strict&quot;; //定义一个类 function X(element, options) &#123; this.$element = $(element); this.options = $.extend(&#123;&#125;, Cal.DEFAULTS, options || &#123;&#125;); &#125; X.DEFAULTS = &#123; //默认参数 &#125;; //原型链上提供方法 X.prototype = &#123; //定义方法 &#125;; function Plugin(option) &#123; var args = Array.prototype.slice.call(arguments, 1); //链式调用 return this.each(function () &#123; //单例模式 var $this = $(this), x = $this.data(&apos;x&apos;); if (!x) &#123; $this.data(&apos;x&apos;, (x = new X(this, option))); &#125; if (typeof option == &apos;string&apos;) &#123; x[option] &amp;&amp; x[option].apply(x, args); &#125; &#125;); &#125; $.fn.X = Plugin;&#125;)();//调用插件$(&quot;selector&quot;).X(); jQuery.extend()1234567$.extend(&#123; x: function () &#123; &#125;&#125;);//调用方式$.x(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQuery.extend()在上面已经详细说了用法。这种一般是为扩展 jQuery 类本身，为类添加新的方法，所以不需要生成实例，可以直接通过\\$符号调用。一般很少用这种方式封装插件。","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"},{"name":"jq","slug":"js/jq","permalink":"https://gwjacqueline.github.io/categories/js/jq/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://gwjacqueline.github.io/tags/面向对象/"},{"name":"原型链","slug":"原型链","permalink":"https://gwjacqueline.github.io/tags/原型链/"},{"name":"继承","slug":"继承","permalink":"https://gwjacqueline.github.io/tags/继承/"}]},{"title":"JS异步编程的那些事(二)","slug":"JS异步编程的那些事(二)","date":"2019-04-20T07:30:26.000Z","updated":"2019-04-20T09:12:01.000Z","comments":true,"path":"JS异步编程的那些事(二)/","link":"","permalink":"https://gwjacqueline.github.io/JS异步编程的那些事(二)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上篇文章说完了 Promise 对象、fetch 方法。这篇我们接着说说 ES7 中丢出的语法糖，”异步终极解决方法 Async/await“。以及分别用 fetch 和 Async/await 去封装一个增删改查的库。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上篇文章说完了 Promise 对象、fetch 方法。这篇我们接着说说 ES7 中丢出的语法糖，”异步终极解决方法 Async/await“。以及分别用 fetch 和 Async/await 去封装一个增删改查的库。 Async/await&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async 和 await 是 js 中异步最终极的解决方案。可以很舒适地与 promise 协同工作。但兼容一般，我们可以用 polyfill(js 修补器)兼容一下，polyfill 是一个 js 库、专门用于处理 js 的兼容性问题。但是确实很难做到 100%覆盖。我们先来看看 async 的用法。 Async/await 用法显而易见这是一个普通到不行的函数 1234function myFunc() &#123; return &quot;Hello world&quot;;&#125;console.log(myFunc()); //Hello world 我们来看看加了 async 之后呢？ 1234async function myAsync() &#123; return &quot;Hello world&quot;&#125;console.log(myAsync()); //Promise &#123;&lt;resolved&gt;: &quot;Hello world&quot;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到了吗？在函数前面加了 async(异步) 关键字，就表示该函数是异步函数。这个函数就会返回一个 Promise，且代码中有 return 语句非 Promise 语句时，JS 就会自动的把 return 中的”Hello world“包装成 Promise 的 resolved 值。语法是不是敲极的简单呢？接下来我们看看 await 是如何搭配 Async 一起使用的呢。 123456789101112131415161718async function asyncWait() &#123; const pro = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;hello world&quot;) &#125;, 2000); &#125;); const error = false; if (error) &#123; await Promise.reject(new Error(&quot;报错了&quot;)); &#125; else &#123; //等待pro执行完毕后才会执行 const res = await pro; return res; &#125;&#125;asyncWait().then((data) =&gt; &#123; console.log(data); //Hello world&#125;).catch((err) =&gt; &#123; console.log(err);&#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在 async 声明的函数体内，使用了 await 关键字。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成之后，再去执行函数体内后面的语句。这里要注意的是:不能在常规函数里使用 await,否则会出现语法错误。await 和 async 就好比一对连体婴。await 只能在 async 函数中工作。我们来看看如果不使用 await 会有什么效果。 123456async function please() &#123; const response = fetch(&quot;http://jsonplaceholder.typicode.com/posts&quot;); const data = response.json(); //response.json is not a function return data;&#125;please().then(data =&gt; console.log(data)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上代码控制台中报错：response.json is not a function。我们看到没有在 await,下面的 response.json()就会报错，因为 response 还没有执行完。如果加了 await，就会在当前请求成功后再往下走。await 表示等一下，只有当 await 定义的行数执行完毕后代码才会继续往下执行。大多情况下 await 后面的应该跟一个 Promise 的对象或者 fetch。我们看看加了 await 关键词后的执行效果。 123456async function please() &#123; const response = await fetch(&quot;http://jsonplaceholder.typicode.com/posts&quot;); const data = await response.json(); return data;&#125;please().then(data =&gt; console.log(data)); (100) [&#123;…&#125;, &#123;…&#125;,...] 封装增删改查方法fetch 库&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完整的代码已经上传到我的github 仓库。以下将记录 fetch 封装增删改查的关键代码。 查看数据12345678910111213141516171819class EasyHttp &#123; get(url) &#123; return new Promise((resolve, reject) =&gt; &#123; fetch(url) .then((res) =&gt; res.json()) .then((data) =&gt; &#123; resolve(data) &#125;) .catch(err =&gt; &#123; reject(err) &#125;); &#125;); &#125;&#125;//调用方式const http = new EasyHttp;http.get(&quot;data/test.json&quot;) .then((data) =&gt; &#123; console.log(data); //(6) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;] &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;); 增加数据1234567891011121314151617post(url, data) &#123; return new Promise((resolve, reject) =&gt; &#123; fetch(url, &#123; //发送请求方法,一般用大写 method: &apos;POST&apos;, //http的头信息 headers: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, //请求体,将对象转成字符串 body: JSON.stringify(data) &#125;) .then(res =&gt; res.json()) .then(data =&gt; resolve(data)) .catch(err =&gt; reject(err)) &#125;);&#125; 修改数据12345678910111213put(url, data) &#123; return new Promise((resolve, reject) =&gt; &#123; fetch(url, &#123; method: &apos;PUT&apos;, headers: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, body: JSON.stringify(data) &#125;).then(res =&gt; res.json()) .then(data =&gt; resolve(data)) .catch(err =&gt; reject(err)) &#125;);&#125; 删除数据123456789101112delete(url) &#123; return new Promise((resolve, reject) =&gt; &#123; fetch(url, &#123; method: &apos;DELETE&apos;, headers: &#123; &apos;Content-type&apos;: &apos;application/json&apos; &#125; &#125;).then(res =&gt; res.json()) .then(data =&gt; resolve(&quot;删除成功&quot;)) .catch(err =&gt; reject(err)); &#125;);&#125;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看完了 fetch 的写法，接下来我们看看如何用 async/await 如何更优雅的实现。 async/await 封装查看数据123456async get(url) &#123; const response = await fetch(url); //将Promise对象转成json对象 const data = await response.json(); return data;&#125; 增加数据1234567891011async post(url, data) &#123; const response = await fetch(url, &#123; method: &apos;POST&apos;, headers: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, body: JSON.stringify(data) &#125;); const postData = await response.json(); return postData;&#125; 修改数据1234567891011async put(url, data) &#123; const response = await fetch(url, &#123; method: &apos;PUT&apos;, headers: &#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, body: JSON.stringify(data) &#125;); const putData = await response.json(); return putData;&#125; 删除数据12345678910async delete(url) &#123; const response = await fetch(url, &#123; method: &apos;DELETE&apos;, headers: &#123; &apos;Content-type&apos;: &apos;application/json&apos; &#125; &#125;); const deleteData = await &quot;成功删除数据&quot;; return deleteData;&#125;; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从代码量上，我们可以显而易见的对比出 async/await 代码量明显少很多，我们不再需要书写 Promise 了。也不需要那么多的.then.then,代码看上去更加优雅，编写出的异步代码更易于读写。只要加一个 async，一个函数就可以作为 promise 对象返回回去 ,等待 resolve 执行完毕后，再去实行。让我们书写异步代码的时候像同步的方式一样舒畅。用 async/await 编写的异步代码更简单易懂，从视觉上就能感觉到复杂度降低了。","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://gwjacqueline.github.io/tags/ES6/"},{"name":"ES7","slug":"ES7","permalink":"https://gwjacqueline.github.io/tags/ES7/"},{"name":"异步","slug":"异步","permalink":"https://gwjacqueline.github.io/tags/异步/"},{"name":"MLHttpRequest","slug":"MLHttpRequest","permalink":"https://gwjacqueline.github.io/tags/MLHttpRequest/"},{"name":"promise","slug":"promise","permalink":"https://gwjacqueline.github.io/tags/promise/"},{"name":"fetch","slug":"fetch","permalink":"https://gwjacqueline.github.io/tags/fetch/"}]},{"title":"JS异步编程的那些事(一)","slug":"JS异步编程的那些事(一)","date":"2019-04-18T13:31:33.000Z","updated":"2019-04-20T09:15:21.000Z","comments":true,"path":"JS异步编程的那些事(一)/","link":"","permalink":"https://gwjacqueline.github.io/JS异步编程的那些事(一)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从最早的回调函数，之后迎来了 promise,再次就是上篇文章说的 generator，js 解决异步的方案一次次的再优化，ES7 中出现的 Async/await 是目前 js 中异步最终极的解决方案，我的妈耶不谈兼容问题的话，实在是太好用啦。虽然兼容性真的很一般，但是我们可以用 polyfill(js 修补器)去兼容一下呀。接下来我将简单介绍下 Promise、fetch、 Async/await 以及分别用 fetch 和 Async/await 去封装一个增删改查的方法。来看看编写异步代码的过程是如何一步步变得优雅起来的。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从最早的回调函数，之后迎来了 promise,再次就是上篇文章说的 generator，js 解决异步的方案一次次的再优化，ES7 中出现的 Async/await 是目前 js 中异步最终极的解决方案，我的妈耶不谈兼容问题的话，实在是太好用啦。虽然兼容性真的很一般，但是我们可以用 polyfill(js 修补器)去兼容一下呀。接下来我将简单介绍下 Promise、fetch、 Async/await 以及分别用 fetch 和 Async/await 去封装一个增删改查的方法。来看看编写异步代码的过程是如何一步步变得优雅起来的。 Promise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们先来说说 Promise 吧~在 ES6 之前处理异步问题时，我们为了避免操作时的页面中断，通过都是使用回调函数，这时候如果回调函数当中又有回调函数，那么我们就会陷入无尽的回调地狱，代码也变得很难维护。而有了 Promise 对象后，我们就可以很好的解决这个问题，用它的链式调用就可以用同步函数的方式去写异步代码了。简直是造福程序员界一项很牛逼的东西。接下来我们创建一个 Promise 实例。 12let promise = new Promise();console.log(promise); //Uncaught TypeError: Promise resolver undefined is not a functionat new Promise &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：Promise 构造函数一定要传回调才可以，否则会报错。它接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。 123let promise = new Promise((resolve, reject) =&gt; &#123;&#125;);console.log(promise); //Promise &#123;&lt;pending&gt;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到打印出来的是Promise{ &lt; pending &gt; },表示任务在进行中。接下来我将用一张图来看看 Promise 的三种状态和对应的回调。 Promise 的三种状态和对应的回调 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然这张图我画的有点丑，但是应该也很简单明了的看懂Promise的三种状态，其中我们基本上运用的是resolved和resolved两种状态。123456789101112131415let promise = new Promise((resolve, reject) =&gt; &#123; if (/* 异步操作成功*/) &#123; resolve(); &#125; else &#123; /* 操作失败 */ //reject(); &#125; &#125;);promise.then(() =&gt; &#123; console.log(&quot;成功，没有任何问题&quot;); //成功，没有任何问题&#125;).then(() =&gt; &#123; console.log(&quot;成功，想调几次就调几次&quot;);&#125;).catch(() =&gt; &#123; console.log(&quot;执行失败方法&quot;);&#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到，只要前面的reject()成功，后续想调用几个then()方法都可以，这样就不仅仅有一个回调了，有n个回调在等着你。如果异步操作失败了，Promise的转态就会变为rejected，去调用catch方法指定的回调函数处理这个错误。另外，then方法指定的回调函数，如果在运行过程中抛出了错误，也会被catch方法捕获。这里要注意的是：catch返回码超过300就不会打印 Promise 对象特点1.对象的状态是不受外界影响的 只有异步操作的结果，才可以决定当前是哪一种状态，任何其他的操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 12345678910111213let fulfill = new Promise((resolve,reject) =&gt; &#123; resolve(&apos;success&apos;); console.log(&apos;resolve before&apos;); reject(&apos;error&apos;);&#125;);fulfill.then(data =&gt; &#123; console.log(data);&#125;);fulfill.catch(msg =&gt; &#123; console.log(msg);&#125;) 2.一旦转态改变，转态就会凝固，不再改变 最后的打印结果为：resolve beforesuccessresolve 下一句语句是可以执行的，为什么 reject 没有去调用 catch 指定的回调函数呢？这就是因为 Promise 对象的特点：状态的凝固。这个对象从起始的 Pending 状态在根据 resolve 或 reject 返回 Resolved 或 Rejected 状态。 fetch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch 是一个基于 promise 的请求方法，更简单便捷。相比与原先在不同浏览器中使用 XMLHttpRequest 对象或者是 ActiveXObject(“x.XMLHTTP”)，fetch 方法简化了这一操作。接下来我们用代码看看 fetch 是如何让代码优雅起来的。 fetch 如何优雅于 XMLHttpRequest123456789101112131415//XMLHttpRequestvar xml = new XMLHttpRequest;//调用请求xml.open(&apos;GET&apos;, &apos;http://jsonplaceholder.typicode.com/postst&apos;);//发送到服务器上xml.send();//监听响应情况xml.onreadystatechange = function () &#123; //响应成功事件 if (this.readyState === 4 &amp;&amp; xml.status === 200) &#123; console.log(xml.responseXML); &#125; else &#123; console.log(&quot;发生错误：&quot;, xmlJson.status); &#125;&#125;; 123456//fetchlet url = &quot;http://jsonplaceholder.typicode.com/posts&quot;;fetch(url) .then((res) =&gt; &#123; console.log(res); //Response &#123;type: &quot;cors&quot;, url: &quot;http://jsonplaceholder.typicode.com/ posts&quot;, redirected: false, status: 200, ok: true, …&#125; &#125;).catch();; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从代码上很直观的能看出代码量的减少。fetch 方法返回的是一个 Promise 对象,所以我们可以链式的发起异步请求。http://jsonplaceholder.typicode.com 这个是我做测试经常会用到的网址。从上面的例子可以看出使用 fetch 时第一步 then 返回的是 response 对象。我们需要使用json()方法将将请求回来的 response 对象解析成我们正常可读的对象。这里要注意的是：目前原生的 fetch 还不支持 jsonp 的请求方式，如果需要实现 jsonp，需要安装 npm 包 fetchJ-jsonp 123456789let url = &quot;http://jsonplaceholder.typicode.com/posts&quot;;fetch(url).then((res) =&gt;//将请求回来的 response 对象解析成我们正常可读的对象res.json()).then((data) =&gt; &#123;console.log(data);&#125;).catch();; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在 response 对象上调用 json()方法，返回的依然是一个 Promise 对象，我们需要在下一步的 then()中获得服务器返回的原始对象。接下来我们去请求一个根本没有的域名，模拟一下 catch。 12345let errurl = &quot;http://jsonplaceholder.typicode12345.com/posts&quot;;fetch(errurl).then(() =&gt; console.log(&quot;成功&quot;)).catch((error) =&gt; console.log(`错误信息：$&#123;error&#125;`));//错误信息：TypeError: Failed to fetch fetch 请求三种数据格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们来实践下如何用 fetch 请求 本地文本数据,本地 json 数据 还有网络接口吧。具体的代码实现效果可以看看实现效果。其中请求本地文本数据采用了 XMLHttpRequest 和 fetch 两种方式。这里展示一部分重要代码。样式没有特意去优化，用的是一个超简单的响应式模板 skeleton。 请求本地文本数据 12345678910function getText() &#123; fetch(&quot;data/test.txt&quot;) //将 response 对象解析 .then((res) =&gt; res.text()) .then((data) =&gt; &#123; console.log(data); //变瘦瘦变美美 document.getElementById(&quot;output&quot;).innerHTML = data; &#125;) .catch(() =&gt; &#123; console.log(&quot;获取失败&quot;) &#125;);&#125; 请求本地 json 数据 123456789101112131415161718function getJson() &#123; fetch(&quot;data/test.json&quot;) .then(res =&gt; res.json()) .then((data) =&gt; &#123; console.log(data);//(6) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;] let outPut = &apos;&apos;; //使用forEach方法遍历数据 data.forEach((x) =&gt; &#123; outPut += ` id:$&#123;x.id&#125;&lt;br&gt; title:$&#123;x.title&#125;&lt;br&gt; body:$&#123;x.body&#125;&lt;br&gt; ` &#125;); document.getElementById(&quot;output&quot;).innerHTML = outPut; &#125;) .catch(() =&gt; &#123; console.log(&quot;获取失败&quot;) &#125;); &#125; 请求网络接口 12345678910111213141516function getWeb() &#123; let weburl = &quot;https://api.github.com/users&quot;; fetch(weburl) .then((res) =&gt; res.json()) .then((data) =&gt; &#123; console.log(data); let webData = &apos;&apos;; data.forEach((x) =&gt; &#123; webData += `loginName:$&#123;x.login&#125;&lt;br&gt;` &#125;); document.getElementById(&quot;output&quot;).innerHTML = webData; &#125;) .catch(() =&gt; &#123; console.log(&quot;获取失败&quot;); &#125;);&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇主要介绍记录了 Promise 对象，fetch 如何优雅于 XMLHttpRequest，以及如何用 fetch 请求三种数据数据格式。下一篇中，我们将用 fetch 去封装一个增删改查的方法，以及记录下 JS 最终极的异步解决方案 Async/awai。","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://gwjacqueline.github.io/tags/ES6/"},{"name":"ES7","slug":"ES7","permalink":"https://gwjacqueline.github.io/tags/ES7/"},{"name":"异步","slug":"异步","permalink":"https://gwjacqueline.github.io/tags/异步/"},{"name":"MLHttpRequest","slug":"MLHttpRequest","permalink":"https://gwjacqueline.github.io/tags/MLHttpRequest/"},{"name":"promise","slug":"promise","permalink":"https://gwjacqueline.github.io/tags/promise/"},{"name":"fetch","slug":"fetch","permalink":"https://gwjacqueline.github.io/tags/fetch/"}]},{"title":"generator生成器","slug":"generator生成器","date":"2019-04-13T11:31:01.000Z","updated":"2019-04-13T14:44:14.000Z","comments":true,"path":"generator生成器/","link":"","permalink":"https://gwjacqueline.github.io/generator生成器/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generator 生成器是 ES6 提供主要用来解决异步编程深度嵌套的问题。generator 和其他函数不同的是：一般的函数只有一次返回值，generator 可以返回多次值。我们可以把它理解为一个函数内部状态的遍历器，我们每执行一次，函数的内部的状态就会发生一次改变。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generator 生成器是 ES6 提供主要用来解决异步编程深度嵌套的问题。generator 和其他函数不同的是：一般的函数只有一次返回值，generator 可以返回多次值。我们可以把它理解为一个函数内部状态的遍历器，我们每执行一次，函数的内部的状态就会发生一次改变。 定义及调用定义：12345function* gen() &#123; yield &quot;Lucy&quot;; yield &quot;DaMing&quot;; return &quot;OK&quot;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generator 在形态上与普通函数有两点区别：一是，function 和函数名之间有一个”*“号；二是，函数体内部使用 yield(产出)语句，定义函数内部不同的状态。yield 关键字用来暂停和继续一个生成器函数,我们可以在需要的时候控制函数的运行。yield 语句的特点是必须等上一条 yield 语句执行完毕才会执行下一条 yield 语句。这样的好处是可以帮助我们用同步的方式写异步代码。避免陷入回调地狱。 调用：12345console.log(gen()); //gen &#123;&lt;suspended&gt;&#125;console.log(g1.next()); //&#123;value: &quot;Lucy&quot;, done: false&#125;console.log(g1.next()); //&#123;value: &quot;DaMing&quot;, done: false&#125;console.log(g1.next()); //&#123;value: &quot;OK&quot;, done: true&#125;console.log(g1.next()); //&#123;value: undefined, done: true&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们看到控制台将 gen()直接打印出来，是一个 Iterator 实例，然后我们再去执行 Iterator 实例的 next()方法，那么这个函数才开始真正运行，并把 yield 后面的值包装成固定对象的并返回，遇到 return 或者函数结束没有更多的值返回时,再返回 undefined。也就是函数在执行过程中的时候，如果没有遇到 return 语句或者没有 return 时，控制权无法交回被调用的代码。 返回多个值的函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回多个值有什么用？斐波那契数列就是一个很好的例子。接下来，我们分别用普通函数和 generator 生成器看下是怎么实现一个产生斐波那契数列的函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;斐波那契数列：前两个值相加等于第三个值，再前面两个值相加等于后面的值（比如：0，1，1，2，3，5） 普通函数: 123456789function fb(max) &#123; let a = 0, b = 1, arr = [0, 1]; while (arr.length &lt; max) &#123; [a, b] = [b, a + b]; arr.push(b); &#125; return arr;&#125;console.log(fb(6)); //[0, 1, 1, 2, 3, 5] generator: 12345678910111213141516function* fb(max) &#123; let a = 0, b = 1, n = 0; while (n &lt; max) &#123; yield a; [a, b] = [b, a + b]; n++; &#125; return;&#125;var f = fb(5);console.log(f.next()); //&#123;value: 0, done: false&#125;console.log(f.next()); //&#123;value: 1, done: false&#125;console.log(f.next()); //&#123;value: 1, done: false&#125;console.log(f.next()); //&#123;value: 2, done: false&#125;console.log(f.next()); //&#123;value: 3, done: false&#125;console.log(f.next()); //&#123;value: undefined, done: false&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到以上都是采用手动调用的方式，非常的麻烦，接下来我们看下怎么能够实现自动遍历。 自动遍历 generatorfor..of&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterate 是一个迭代器，只要是迭代器就可以循环输出，for…of 循环可以自动遍历 Generator 函数生成的 Iterator 对象。但是，return 的东西不会遍历，主要遍历 yield 的东西。 12345678910function* gen() &#123; yield &quot;Lucy&quot;; yield &quot;DaMing&quot;; return &quot;OK&quot;&#125;let g1 = gen();//for..of遍历for (var item of gen(3)) &#123; console.log(item); //Lucy,DaMing&#125; 解构赋值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解构解的是 yield 的值 1234567891011function* gen() &#123; yield &quot;Lucy&quot;; yield &quot;DaMing&quot;; return &quot;OK&quot;&#125;let g1 = gen();//解构赋值const [a, b, c] = gen();console.log(a, b, c); //Lucy DaMing undefinedconst [x, ...y] = gen();console.log(x, y); //Lucy [&quot;DaMing&quot;] 扩展运算符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还可以配合扩展运算符去使用 12345678function* gen() &#123; yield &quot;Lucy&quot;; yield &quot;DaMing&quot;; return &quot;OK&quot;&#125;let g1 = gen();//扩展运算符console.log(...gen()); //Lucy DaMing 结合 axios 数据请求&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generator 在实际应用中往往需要配合 promise 去使用，接下来我们写个实例，看看它是怎么用的。这里会用到 axios，用法这边就不详细说了 123456789101112131415//引入axios&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;function* gener() &#123; let username = yield &quot;GWJacqueline&quot;; //获取个人信息 yield axios.get(`https://api.github.com/users/$&#123;username&#125;`);&#125;let genera = gener();//先将username包装成固定对象的并返回console.log(genera.next().value); //GWJacqueline//获取信息var backname = genera.next().value.then((res) =&gt; &#123; console.log(res.data);&#125;);console.log(backname); //&#123;login: &quot;undefined&quot;, id: 11791361, node_id: &quot;MDQ6VXNlcjExNzkxMzYx&quot;, avatar_url: &quot;https://avatars3.githubusercontent.com/u/11791361?v=4&quot;, gravatar_id: &quot;&quot;, …&#125; 以上的例子主要的通过 generator 去获取 github 上面有关于我的一些信息。 实例：同学录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我分别使用 generator 和迭代器实现了一个”同学录浏览功能“，可以点击同学录查看具体效果。迭代器主要代码： 12345678910function showMessage(msg) &#123; let nextIndex = 0; return &#123; next() &#123; return nextIndex &lt; msg.length ? &#123; value: msg[nextIndex++], done: false &#125; : &#123; value: undefined, done: true &#125; &#125; &#125;&#125; generator 主要代码： 12345678function* showMessage() &#123; yield data[0]; yield data[1]; yield data[2]; yield data[3]; yield data[4];&#125; &#125;&#125; 对比完两种方式，明显 generator 比迭代器实现的更加优雅，完整代码可以上我的github查看;","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://gwjacqueline.github.io/tags/ES6/"},{"name":"异步","slug":"异步","permalink":"https://gwjacqueline.github.io/tags/异步/"}]},{"title":"js如何禁用物理返回键","slug":"js如何禁用物理返回键","date":"2019-04-13T01:36:36.000Z","updated":"2019-04-13T07:17:16.000Z","comments":true,"path":"js如何禁用物理返回键/","link":"","permalink":"https://gwjacqueline.github.io/js如何禁用物理返回键/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;最近做的几个项目都有涉及如何禁用 android 和 ios 的物理返回键，今天有空就把怎么禁用以及禁用原理记录一下吧~","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近做的几个项目都有涉及如何禁用 android 和 ios 的物理返回键，今天有空就把怎么禁用以及禁用原理记录一下吧~ 效果展示我的 demo,是不是已经成功禁用了呢？ 核心方法history.pushState(state, title[, url])&nbsp;&nbsp;&nbsp;&nbsp;pushState()是 H5 的 API 中新添加的方法，是实现物理键禁用的核心方法，所以先简单记录下该方法. &nbsp;&nbsp;&nbsp;&nbsp;pushState()是在 history 栈中添加一个新的条目。通过 window.history 方法创建新的历史项。但是它只改变地址栏 url，不刷新页面。pushState()带有三个参数：一个状态对象 state，一个标题（目前没有用，可以传 null），以及一个可选的 URL 地址。和 pushState()用法以及参数一致的方法是 replaceState()。它和 pushState()的区别是：pushState()是在 history 栈中添加一个新的条目，而 replaceState()是替换当前的记录值。因为本篇文章没有用到 replaceState(），所以这里就不进行详细说明了。 popstate &nbsp;&nbsp;&nbsp;&nbsp;当活动历史记录条目更改时，就会触发该事件。这样就可以帮助我们后面去监听用户点击返回的事件了。需要注意的是调用 history.pushState()或 history.replaceState() 不会触发 popstate 事件。当调用以上两个方法去替换新的历史项，popstate 事件的 state 属性会包含历史项状态对象的拷贝。只有在做出浏览器动作时，才会触发 popstate 事件，比如用户点击浏览器的前进回退按钮。这边经过测试，不同的浏览器在加载页面时处理 popstate 事件的形式存在差异，Chrome 和 Safari 通常会触发 popstate 事件，但 Firefox 则不会。 实现原理&nbsp;&nbsp;&nbsp;&nbsp;明白了以上两个核心方法后，就能很好的看懂禁用物理键返回的原理了。实际上就是：在监听到用户点击返回键时，在 history 栈中添加一个当前的地址。这样用户就怎么也返回不了啦~ 主要代码1234567891011121314const back = &#123;&#125;;back.onPopState = function () &#123; back.record(&quot;back&quot;);&#125;;back.record = function (state) &#123; history.pushState(state, null, location.href);&#125;back.init = function () &#123; //每次监听到返回键，都使用pushState插入一条历史记录,popstate 事件的 state 属性会包含历史项状态对象的拷贝 window.addEventListener(&quot;popstate&quot;, back.onPopState); // 在初始化的时候，先插入一条历史记录，避免用户按返回键 back.record(&quot;back&quot;);&#125;back.init();","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"物理返回键","slug":"物理返回键","permalink":"https://gwjacqueline.github.io/tags/物理返回键/"}]},{"title":"手机端调用搜索键盘","slug":"手机端调用搜索键盘","date":"2019-04-12T08:12:27.000Z","updated":"2019-04-12T14:16:05.000Z","comments":true,"path":"手机端调用搜索键盘/","link":"","permalink":"https://gwjacqueline.github.io/手机端调用搜索键盘/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;本文主要记录下如何调用系统的搜索键盘，经过实际测试以下代码可以兼容 ios 和 Android 系统","text":"&nbsp;&nbsp;&nbsp;&nbsp;本文主要记录下如何调用系统的搜索键盘，经过实际测试以下代码可以兼容 ios 和 Android 系统 大家可以用手机测试下我的 demo是否能正常调用系统的搜索键盘呢？ Html注意点： 必须在 input 输入框外用 form 表单包起来，并且要加”action”，否则在 ios 上键盘上无法弹出”搜索二字“ 123&lt;form id=&quot;formid&quot; action=&quot;#&quot;&gt; &lt;input name=&quot;name&quot; id=&quot;search&quot; type=&quot;search&quot; placeholder=&quot;我是一个输入框&quot;/&gt;&lt;/form&gt; js监听搜索按钮： 通过键盘键值匹配监听用户点击搜索按钮 12345document.getElementById(&quot;search&quot;).addEventListener(&quot;keydown&quot;, function(e) &#123; if (e.keyCode == &quot;13&quot;) &#123; alert(&quot;成功调用搜索框啦~&quot;); &#125;&#125;); 优化点部分手机在搜索框聚焦时，会出现下图所示的打叉样式： 可通过以下代码去除自带叉号样式：123input::-webkit-search-cancel-button &#123; display: none;&#125;","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://gwjacqueline.github.io/tags/移动端/"},{"name":"搜索","slug":"搜索","permalink":"https://gwjacqueline.github.io/tags/搜索/"},{"name":"返回","slug":"返回","permalink":"https://gwjacqueline.github.io/tags/返回/"}]},{"title":"天花乱坠的数组方法(二)","slug":"天花乱坠的数组方法(二)","date":"2019-04-07T11:35:39.000Z","updated":"2019-04-12T12:18:46.000Z","comments":true,"path":"天花乱坠的数组方法(二)/","link":"","permalink":"https://gwjacqueline.github.io/天花乱坠的数组方法(二)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上篇文章中很详细的说了 ES6 当中常用的数组方法，本篇文章快刀斩乱马的根据”原数组是否会被修改”的分类说下 ES5 中常见的数组方法吧","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上篇文章中很详细的说了 ES6 当中常用的数组方法，本篇文章快刀斩乱马的根据”原数组是否会被修改”的分类说下 ES5 中常见的数组方法吧 原数组不会被修改数组转换为字符串：join()二话不说，上代码： 12345var arrJoin= [1,2,3,4,5];console.log(arrJoin.join(&quot;&quot;)); //12345console.log(arrJoin.join(&quot;❤️&quot;)); //1❤️2❤️3❤️4❤️5// 事实证明：原数组不会被修改console.log(arrJoin); //[1, 2, 3, 4, 5] 来个实用的场景吧：将某个字符重复 n 次 12345function repeat(str,n)&#123; return new Array(n+1).join(str);&#125;console.log(repeat(&quot;哈&quot;,3)); //哈哈哈console.log(repeat(&quot;hi&quot;,5));//hihihihihi 数组的合并：concat()看看怎么用？ 12345678var arrConcat = [1,2,3];console.log(arrConcat.concat(4,5)); //[1, 2, 3, 4, 5]// 会被拉平为一维数组console.log(arrConcat.concat(4,5,[6,7])); //[1, 2, 3, 4, 5, 6, 7]//数组中还有数组时，不会被拉平console.log(arrConcat.concat(4,[5,[6,7]])); //[1, 2, 3, 4, 5,[6,7]]//concat()不会改变原数组console.log(arrConcat); //[1, 2, 3] 返回部分数组：slice()任性上代码： 1234567var arrSlice = [1,2,3,4,5];console.log(arrSlice.slice(1)); //[2,3,4,5]console.log(arrSlice.slice(0,2)); //[1,2]console.log(arrSlice.slice(1,4)); //[2,3,4]console.log(arrSlice.slice(1,-1)); //[2,3,4]console.log(arrSlice.slice(2,-1)); //[3,4]console.log(arrSlice); //[1,2,3,4,5] 看完代码后，我们可以总结下 slice()的用法:slice(start,end)start:必须参数，指从何处开始截取，包含该处end:可选参数，指从何处结束截取，不包含该处，该参数为负数时，指从数组尾部开始算起的位置 原数组会被修改数组逆序：reverse()1234var arrReverse = [1,2,3,4,5];console.log(arrReverse.reverse()); //[5, 4, 3, 2, 1]// 注意：原数组被修改了哦console.log(arrReverse); //[5, 4, 3, 2, 1] 数组排序：sort()1234567var arrSort = [&apos;a&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;,&apos;d&apos;]; console.log(arrSort.sort()); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;] // 注意：原数组被修改了哦 console.log(arrSort); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;] //让我们再来看看数字 var arrSortNumber = [1,19,2,25,8]; console.log(arrSortNumber.sort()); //[1, 19, 2, 25, 8] 可以看到 arrSortNumber 没有按照我们期望的输出，因为如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。让我们看看如何对数字进行正确的排序。 123456789var arrSortNumber = [1,19,2,25,8];// 升序排列console.log(arrSortNumber.sort(function(a,b)&#123; return a-b; //[1, 2, 8, 19, 25]&#125;));// 降序排列console.log(arrSortNumber.sort(function(a,b)&#123; return b-a; //[[25, 19, 8, 2, 1]&#125;)); 数组拼接：splice()12345678910var arrSplice = [&apos;a&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;,&apos;d&apos;];console.log(arrSplice.splice(2)); //[&apos;e&apos;,&apos;b&apos;,&apos;d&apos;]// 注意：原数组被修改了console.log(arrSplice); //[&quot;a&quot;, &quot;c&quot;]var arrSplice2 = [&apos;b&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;,&apos;d&apos;];console.log(arrSplice2.splice(2,2)); //[&apos;e&apos;,&apos;b&apos;]console.log(arrSplice2); //[[&quot;b&quot;, &quot;c&quot;, &quot;d&quot;]var arrSplice3 = [&apos;c&apos;,&apos;c&apos;,&apos;e&apos;,&apos;b&apos;,&apos;d&apos;];console.log(arrSplice3.splice(2,2,&apos;h&apos;,&apos;j&apos;)); //[&quot;e&quot;, &quot;b&quot;]console.log(arrSplice3); //[&quot;c&quot;, &quot;c&quot;, &quot;h&quot;, &quot;j&quot;, &quot;d&quot;] 从以上代码可以总结下 splice()的使用方法splice(start,number,item);start：必选参数，代表要删除的起始位置，包括该位置number：可选参数，删除的个数item: 可选参数，插入的片段 数组增删：123456789101112131415161718192021var arrOperate = [];//push()数组尾部增加元素arrOperate.push(1,2);console.log(arrOperate); //[1,2]//通过length的方式在尾部增加元素arrOperate[arrOperate.length] = 3;console.log(arrOperate);//[1,2,3]//在数组头部增加元素arrOperate.unshift(-1,0);console.log(arrOperate); //[-1,0,1,2,3]//delete方法只是将对应元素改成Undefineddelete arrOperate[0];console.log(arrOperate); //[undefined,0,1,2,3]如果0位置设置为&quot;undefined&quot;，则为trueconsole.log(0 in arrOperate); //false//pop()删除元素的最后一位arrOperate.pop();console.log(arrOperate); //[undefined,0,1,2]//pop()删除元素的第一位arrOperate.shift();console.log(arrOperate); //[0,1,2]","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://gwjacqueline.github.io/tags/ES6/"},{"name":"数组","slug":"数组","permalink":"https://gwjacqueline.github.io/tags/数组/"}]},{"title":"天花乱坠的数组方法(一)","slug":"天花乱坠的数组方法(一)","date":"2019-04-06T09:52:39.000Z","updated":"2019-04-12T01:43:38.000Z","comments":true,"path":"天花乱坠的数组方法(一)/","link":"","permalink":"https://gwjacqueline.github.io/天花乱坠的数组方法(一)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组是 JS 当中很重要的一个部分，它有很多很多很多的方法，对于我这样记性不好的人来说，一些不常用的方法经常会被遗忘，经常需要再次查找才能想起来。今天为了能给自己加深对数组方法的记忆，将通过两个章节去整理下常用的数组方法。第一个章节将记录下 ES6 中常见的数组方法，其中将详细记录下部分数组，第二个章节将简单整理下 ES5 之前的数组方法。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组是 JS 当中很重要的一个部分，它有很多很多很多的方法，对于我这样记性不好的人来说，一些不常用的方法经常会被遗忘，经常需要再次查找才能想起来。今天为了能给自己加深对数组方法的记忆，将通过两个章节去整理下常用的数组方法。第一个章节将记录下 ES6 中常见的数组方法，其中将详细记录下部分数组，第二个章节将简单整理下 ES5 之前的数组方法。 ES6 中新增的数组方法数组元素遍历：for 循环/forEach()在 ES6 之前还没有 forEach()方法时，我们通常是使用 for 循环对数组进行遍历的。 ES5 之前：for 循环遍历数组实例：12345//通过for循环将数组中的元素遍历出来var color = [&apos;blue&apos;,&apos;yellow&apos;,&apos;red&apos;];for(var i=0;i&lt;color.length;i++)&#123; console.log(color[i]); //blue,yellow,red&#125; 有了 forEach()方法后，数组的遍历整体变得更加可观，直接用数组调用对应的内容 forEach()遍历数组实例：12345var colorES6 = [&apos;blue&apos;,&apos;yellow&apos;,&apos;red&apos;,&apos;white&apos;];//forEach()中放一个迭代函数，colorES6作为形参去接受数组里的每一个内容colorES6.forEach(function(colorES6)&#123; console.log(colorES6); //blue,yellow,red,white&#125;); forEach()遍历数组的优点：123456789//求数组元素的总和var numbers = [1,2,3,4,5];var sum = 0; //用于接收数组的总和//forEach可以将函数抽离出来function num(number)&#123; sum+=number;&#125;numbers.forEach(num);console.log(sum); //15 以上代码我们可以看出 forEach()的好处不止让代码变得更加可观，可以直接调用数组里的内容，还可以将函数抽离出来 forEach()遍历数组的过程：为了能加深对 forEach()的理解，可以用一个流程图来简单画出 forEach()遍历数组的过程： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图中画的是”forEach()遍历数组实例”中的过程：第一次先将blue放在迭代器里，将它打印出来，第二次再将yellow放在迭代器里，将它打印出来，以此类推。 直达找到最后一个没有的时候，那么当前的循环就结束了。 forEach()使用的场景：比如：一个表单有一个多选框，再提交表单时，需要遍历选中的元素并进行相应操作。 数组的映射：map()映射这两个字大家可能会觉得有点抽象，通俗点来说就是对数组进行一些转化。常用的场景有两种：1.在拷贝数组的过程中改变一些东西2.在数组中拿到一些固定的属性接下来我将用for循环和ES6新方法map()编写上面两种场景 场景一：将数组A以两倍的形式放到数组B中去ES5之前：for循环+push()实现场景一123456var oldA = [1,2];var oldB = [];for(var i=0;i&lt;oldA.length;i++)&#123; oldB.push(oldA[i]*2); //将数组A中的元素乘以2后放置到数组A中&#125;console.log(oldB); //[2,4] map()实现场景一123456var arrA = [1,2,3];//map返回的就是数组，所以不需要 var arrB =[];var arrB = arrA.map(function(x)&#123; //map里面依旧放迭代器函数 return 2 * x; &#125;);console.log(arrB); //[2,4,6] 场景二：有一个对象数组A，把数组A中对象的name属性存储到对象B上ES5之前：for循环+push()实现场景二123456789var oldarrObjectA = [ &#123;name: &quot;Lucy&quot;,age: 13&#125;, &#123;name: &quot;Tom&quot;,age: 14&#125;];var oldarrObjectB = [];for(i=0;i&lt;oldarrObjectA.length;i++)&#123; oldarrObjectB.push(oldarrObjectA[i].name);&#125;console.log(oldarrObjectB); //[&quot;Lucy&quot;, &quot;Tom&quot;] map()实现场景二123456789var arrObjectA = [ &#123;name: &quot;Lucy&quot;,age: 13&#125;, &#123;name: &quot;Tom&quot;,age: 14&#125;, &#123;name: &quot;Lili&quot;,age: 15&#125;];var arrObjectB = arrObjectA.map(function(x)&#123; return x.name;&#125;);console.log(arrObjectB); //[&quot;Lucy&quot;, &quot;Tom&quot;, &quot;Lili&quot;] map()和forEach()一样，里面放的都是迭代器函数。map()返回的是一个新的数组。这里我们需要注意一下map()是需要返回值的，如果不给返回值，则默认返回undefined。123456// 不给map返回值var arrA = [1,2,3];var arrB = arrA.map(function(x)&#123; 2 * x;&#125;);console.log(arrB); //[undefined, undefined, undefined] map()映射数组的过程：接下来，我们用一个流程图来简单画出场景一中map()映射数组的过程： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;场景一中A数组想要做的事情就是让B数组中装的是它的两倍，map里面的方法会拥有一个迭代器函数。比如a.map()，它会将a中的每个值放到迭代器函数中的形参里面，然后将值乘以2后返回到新数组中。例如拿到”1”后，乘以2再返回到新数组中去。 使用场景：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：基金产品中会有很多种基金，我们假设每个基金都是一个对象，每个基金都会有很多属性：比如基金名字、关注度、收益率等。后台人员需要获取每个基金的关注度时，就可以采取map()方法。 数组的过滤：filter()过滤数组是我们开发中经常会遇到的问题，接下来我会使用三个常见的场景加深对filter()方法的理解 场景一：把不想要的值过滤掉，拿出我们想要的值(假定有一个对象数组A，获取数组中指定类型的对象放到数组B中)12345678910111213141516171819//将typeA中为男性的对象抽取出来var typeA = [ &#123;name: &apos;Lily&apos;,gender: &apos;female&apos;&#125;, &#123;name: &apos;Lucy&apos;,gender: &apos;female&apos;&#125;, &#123;name: &apos;Peter&apos;,gender: &apos;male&apos;&#125;,];// ES5之前：for循环+push()的实现var typeB = [];for(var i=0;i&lt;typeA.length;i++)&#123; if(typeA[i].gender===&apos;male&apos;)&#123; typeB.push(typeA[i]); &#125;&#125;console.log(typeB); //[&#123;name: &quot;Peter&quot;, gender: &quot;male&quot;&#125;]// ES6 filter()的实现var typeC = typeA.filter(function(x)&#123; return x.gender===&apos;male&apos;; //[&#123;name: &quot;Peter&quot;, gender: &quot;male&quot;&#125;]&#125;);console.log(typeC); //&#123;name: &quot;Peter&quot;, gender: &quot;male&quot;&#125; 场景二：假定有一个对象数组A，过滤掉不满足以下条件的对象：条件：性别女，年龄大于13岁，班级不为3班的123456789var personA = [ &#123;name: &apos;Lily&apos;,gender: &apos;female&apos;,age:16,class:1&#125;, &#123;name: &apos;Lucy&apos;,gender: &apos;female&apos;,age:14,class:2&#125;, &#123;name: &apos;Peter&apos;,gender: &apos;male&apos;,age:17,class:3&#125;,];var choosePerson = personA.filter(function(x)&#123; return x.gender === &apos;female&apos; &amp;&amp; x.age&gt;13 &amp;&amp;x.class !==3&#125;);console.log(choosePerson); //[&#123;name: &quot;Lily&quot;, gender: &quot;female&quot;, age: 16, class: 1&#125;,&#123;name: &quot;Lucy&quot;, gender: &quot;female&quot;, age: 14, class: 2&#125;] 场景三：根据对象A的id值，过滤掉B数组中与对象A中id值不符的元素12345678910var objA = &#123;id:1,title:&apos;haha&apos;&#125;;var filterId = [ &#123;id:1,content:&apos;filter&apos;&#125;, &#123;id:2,content:&apos;filter&apos;&#125;, &#123;id:1,content:&apos;filter2&apos;&#125;];filterId = filterId.filter(function(x)&#123; return x.id === objA.id;&#125;);console.log(filterId); //[&#123;id: 1, content: &quot;filter&quot;&#125;,&#123;id: 1, content: &quot;filter2&quot;&#125;] filter()过滤数组的过程：看了以上三个场景后，对filter的使用方法应该有所了解了，接下来，我们结合场景一看看filter是怎样实现过滤的 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们在遍历数组typeA时，会将当前类型的值放到迭代器函数里面，去对它进行匹配，因为我们拿到的是每个对象，当每个对象下的gender值为male时，则为匹配成功，会以return true的形式返回，并放到typeC数组中。如果匹配不成功，则返回false,且不会放到typeC数组中。 数组的查找：find()通过find()方法可以帮我们找到对应的东西。还是根据两个常用的场景来看看find()怎么用吧。 场景一：假定有一个对象数组，找到符合条件的对象并存储起来1234567891011121314151617181920//快速找到findA中姓名为&apos;Billy&apos;的对象var findA = [ &#123;name: &apos;Lucy&apos;&#125;, &#123;name: &apos;Peter&apos;&#125;, &#123;name: &apos;Billy&apos;&#125;];var thisA;//ES5之前：for循环for(var i=0;i&lt;findA.length;i++)&#123; if(findA[i].name === &apos;Billy&apos;)&#123; thisA = findA[i]; break; //找到之后结束循环，避免浪费时间 &#125;&#125;console.log(thisA); //&#123;name: &quot;Billy&quot;&#125;//ES6 find()：找到第一个符合条件的对象，就不会再次循环var thisB = findA.find(function(x)&#123; return x.name === &apos;Billy&apos;&#125;);console.log(thisB); //&#123;name: &quot;Billy&quot;&#125; 场景二：假定有一个对象数组，根据指定对象的条件找到数组中符合条件的对象123456789101112var findArr = [ &#123;name: &apos;Lucy&apos;,age: 13&#125;, &#123;name: &apos;Billy&apos;,age: 17&#125;, &#123;name: &apos;Peter&apos;,age: 13&#125; ]; var choosefindArr =&#123;name: &apos;Bob&apos;,age: 13&#125;; function choose(findArr,choosefindArr)&#123; return findArr.find(function(x)&#123; return x.age === choosefindArr.age; &#125;); &#125; console.log(choose(findArr,choosefindArr)); //&#123;name: &quot;Lucy&quot;, age: 13&#125; find()的工作流程：find()的特点在于：找到对应的条件，就不会继续往下执行。能帮助我们快速查找到对应的内容。接下来，我们根据场景1来看看它的工作模式是什么样的吧 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们遍历findA这个数组通过find()时，会将每个name放到迭代器函数中，去判断目前的name和我们想要的name是否相等。如果不相等，则会返回一个false,就没有任何东西；如果相等，则返回true，并将对应的内容返回到thisA中。 一真即真，一假即假的：every()、some()every()所有条件都满足，才返回true；some(),只要一个条件满足，就返回true()。 场景一：查询班级成员成绩达标情况，成绩大于60表示达标，小于60为不达标1234567891011121314151617181920212223242526var classMark = [ &#123;name: &apos;Lucy&apos;,mark: 90&#125;, &#123;name: &apos;Peter&apos;,mark: 80&#125;, &#123;name: &apos;Billy&apos;,mark: 20&#125;];//ES5之前：for循环 方法var markeveryOK = true; //成绩全部达标var marksomeOK = false; //成绩部分达标 for(var i=0;i&lt;classMark.length;i++)&#123; if(classMark[i].mark &lt; 60)&#123; markeveryOK = false; &#125;else&#123; marksomeOK = true; &#125; &#125; console.log(markeveryOK,marksomeOK); //false true//every()/some()方法; //成绩全部达标,一旦返回的是假，后续的东西就不会再去遍历了var markeveryOKES6 = classMark.every(function(x)&#123; return x.mark &gt; 60;&#125;);//成绩部分达标，一旦返回的是真，后续的东西就不会再去遍历了var marksomeOKES6 = classMark.some(function(x)&#123; return x.mark &gt;60;&#125;);console.log(markeveryOKES6,marksomeOKES6); //false true 场景二：一个表单页面，判断所有输入框内容的长度是否大于01234567891011121314151617// 获取输入框的内容function Field(value)&#123; this.value = value;&#125;// 判断当前输入框内容的长度是否大于0Field.prototype.validate = function()&#123; return this.value.length &gt; 0;&#125;var filedName = new Field(&apos;Lucy&apos;);var filedage = new Field(&apos;&apos;);var filedpassword = new Field(&apos;123456&apos;);var fieldArr = [filedName,filedage,filedpassword];// 用every方法判断是否所有输入框内容的长度都大于0var result = fieldArr.every(function(x)&#123; return x.validate();&#125;);console.log(result); //false every()的工作流程：every()的特点：一旦返回的是假，就不会再去遍历了。接下来我们结合场景一简单说下every()的工作流程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学生的成绩分别是：90，80，20。我们首先把”90”放到迭代器函数中，然后和我们的60进行匹配。90不小于60，所以markeveryOKES6为true。20小于60，所以markeveryOKES6为false。最终会将返回值用&amp;&amp;运算符输出，即一假即假。some() some()的工作流程：every()的特点：一旦返回的是真，就不会再去遍历了 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次把90放到迭代器函数中，marksomeOKES6为true。当some()返回为true时，则不再进行遍历。即一真即真 把数组聚合成结果 reduce()reduce()可以替代大多数数组的方法，比如forEach、map()等，接下来我们看看它是怎么替代和应用的 场景一：代替forEach()计算数组中所有值的总和12345var reduce =[10,20,30];var sum = reduce.reduce(function(x,y)&#123; return x+y;&#125;,10); //这里放初始值console.log(sum); //70 场景二：代替map()将数组中对象的某个属性抽离到另外一个数组中12345678910var reduceArr =[ &#123;name:&apos;Lucy&apos;,age:11&#125;, &#123;name:&apos;David&apos;,age:19&#125;, &#123;name:&apos;Billy&apos;,age:13&#125;];var choosereduceArr = reduceArr.reduce(function(x,y)&#123; x.push(y.name); return x;&#125;,[]);console.log(choosereduceArr); // [&quot;Lucy&quot;, &quot;David&quot;, &quot;Billy&quot;] 场景三：判断字符串中括号是否对称例如：（（（））） 对称（）（）（） 对称(（（） 不对称12345678910function bracket(string)&#123; // 先将字符串变为数组 return !string.split(&apos;&apos;).reduce(function(x,y)&#123; if(y === &quot;(&quot;)&#123;++x;&#125;; if(y === &quot;)&quot;)&#123;--x;&#125;; return x; &#125;,0);&#125;console.log(bracket(&apos;(())&apos;)); //trueconsole.log(bracket(&apos;(())))))&apos;)); //false reduce()的工作流程：接下来我们结合场景一看看reduce()是如何把数组聚合成结果的吧 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;场景一中reduce arr是10、20、30，当我们在遍历的时候，这个参数的初始化值为10，然后我们拿到的就是10+20，然后第二个值就为20，然后再次与迭代器函数里的值相加，以此类推得到最后一个结果。 reduceRight()从字面很好理解，reduce()遍历的顺序是从左往右，相反它的从右往左。和redece()的区别就是遍历顺序。这里就不多做解释了。 数组的检索indexOf()该方法将根据我们查找的对象，从头到尾的去检索数组，返回我们查找对象的位置1234567var arr = [1,2,3,-1,2,3];console.log(arr.indexOf(2)); //1console.log(arr.indexOf(99)); //-1console.log(arr.indexOf(1,0)); //0console.log(arr.indexOf(2,2)); //4console.log(arr.indexOf(2,-1)); //-1console.log(arr.indexOf(2,-3)); //-4 从以上的例子可以总结下indexOf()的使用方法indexOf(i,p)会返回从p位置开始检索的对象i，检索完成后返回对象i在数组中的位置i：必传参数，查找的对象p: 可传参数，从数组的哪个位置开始找 数组的检索lastndexOf()indexOf的区别就是，lastIndexOf是从右往左找的。1234var arr = [1,2,3,-1,2,3];console.log(arr.lastIndexOf(2)); //4console.log(arr.lastIndexOf(1,0)); //0console.log(arr.lastIndexOf(2,-1)); //4 数组的检索indexOf()该方法将根据我们查找的对象，从头到尾的去检索数组，返回我们查找对象的位置1234567var arr = [1,2,3,-1,2,3];console.log(arr.indexOf(2)); //1console.log(arr.indexOf(99)); //-1console.log(arr.indexOf(1,0)); //0console.log(arr.indexOf(2,2)); //4console.log(arr.indexOf(2,-1)); //-1console.log(arr.indexOf(2,-3)); //-4 从以上的例子可以总结下indexOf()的使用方法indexOf(i,p)会返回从p位置开始检索的对象i，检索完成后返回对象i在数组中的位置i：必传参数，查找的对象p: 可传参数，从数组的哪个位置开始找 判断是否为数组 isArray()我们来回顾下原先没有isArray()的时候，我们通常是怎么判断是否为数组的1234var obj = [1,2,3,-1,2,3];console.log(Object.prototype.toString.call(obj)); //[object Array]console.log(obj instanceof Array); //trueconsole.log(obj.constructor === Array); //true 有了isArray()后，我们可以直接使用这个方法来判断数组啦~1234var obj = [1,2,3,-1,2,3];var obj2 = &#123;name:&apos;Lucy&apos;&#125;;console.log(Array.isArray(obj)); //trueconsole.log(Array.isArray(obj2)); //false 以上篇幅有些长，主要介绍了ES6新增的一些常用数组，接下来第二篇，将简单回顾下ES5一些数组的常用方法吧~","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://gwjacqueline.github.io/tags/ES6/"},{"name":"数组","slug":"数组","permalink":"https://gwjacqueline.github.io/tags/数组/"}]},{"title":"移动端常见兼容性问题","slug":"移动端常见兼容性问题","date":"2019-04-01T08:12:27.000Z","updated":"2019-05-08T11:27:41.000Z","comments":true,"path":"移动端常见兼容性问题/","link":"","permalink":"https://gwjacqueline.github.io/移动端常见兼容性问题/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;本文主要想记录下最近工作中遇到的一些移动端兼容问题，便于日后能够快速解决一些 Bug。","text":"&nbsp;&nbsp;&nbsp;&nbsp;本文主要想记录下最近工作中遇到的一些移动端兼容问题，便于日后能够快速解决一些 Bug。 ios fixed 定位+长表单 主要代码：12345678&lt;body&gt; &lt;header&gt; &lt;!-- fixed定位的头部 --&gt; &lt;header&gt; &lt;section&gt; &lt;!-- 自然布局 --&gt; &lt;/section&gt;&lt;/body&gt; bug描述：只有在ios上出现：当section过长(有滚动条时)，表单获取焦点时。上图红色框的头部会掉落至绿色部分。 bug解决：造成问题的原因：当表单获取焦点，键盘弹出时，可视高度变小。解决方式：表单获取焦点时，把fixed定位改成absolute;失去焦点时，改回来。个人建议：在实际开发中，尽量少使用fixed定位。 Android footer 绝对定位 主要代码：1234567891011&lt;body&gt; &lt;header&gt; &lt;!-- absolute定位的头部 --&gt; &lt;header&gt; &lt;section&gt; &lt;!-- 自然布局 --&gt; &lt;/section&gt; &lt;section&gt; &lt;!-- fixed定位的footer --&gt; &lt;/section&gt;&lt;/body&gt; bug描述：只有在Android手机上出现：表单获取焦点时,系统键盘会将fixed定位的footer顶起来。 bug解决：造成问题的原因：系统键盘会顶走fixed布局元素。解决方式：1.表单获取焦点时，把fixed定位的元素改成static；失焦后，再改回来。2.表单获取焦点时，把fixed定位的元素设置为display:none；失焦后，再设置成为display:block。 ios 微信浏览器 长表单留白 bug描述：只有在ios微信浏览器上出现。当输入框聚焦，系统键盘把页面顶起后，键盘收起。会发现页面底部留白 bug解决：造成问题的原因：系统键盘弹出触发resize导致页面高度缩小。解决方式：12345$(&quot;input,textarea&quot;).blur(function () &#123; setTimeout(function () &#123; //若不加定时器，部分手机会失效 $(&quot;body&quot;).scrollTop($(body).scrollTop()+1); //让页面偷偷滚动一下，消除空白 &#125;,100);&#125;); transform弹窗不居中 主要代码：123456789101112/*弹窗*/.dialog-content &#123; position: absolute; top: 50%; left: 50%; z-index: 10003; width: 73%; padding-top: .66667rem; transform: translate(-50%,-50%); background-color: rgba(255,255,255,.95); border-radius: .21333rem;&#125; bug描述：在ios 8及以下的系统，弹窗不居中 bug解决：造成问题的原因：Safari支持代替的-webkit-transform属性，读取不到transform属性解决方式：加上-webkie-transform属性，注意兼容性写法顺序1234567891011121314/*弹窗*/.dialog-content &#123; position: absolute; top: 50%; left: 50%; z-index: 10003; width: 73%; padding-top: .66667rem; background-color: rgba(255,255,255,.95); border-radius: .21333rem; -webkit-transform: translate(-50%,-50%); //一定要加上兼容性的写法 -ms-transform: translate(-50%,-50%); //IE9以下不兼容，IE9支持代替的-ms-transform属性不过只支持2D transform: translate(-50%,-50%);&#125; ios 输入框背景色变黄 主要代码：1234567input&#123; border: none; background: 0 0; display: block; -webkit-tap-highlight-color: transparent; //只用于iOS。点击链接或者通过Javascript定义的可点击元素的时候，会出现一个半透明的灰色背景 -webkit-appearance: none; //消除输入框和按钮的原生外观，在iOS上加上这个属性才能给按钮和输入框自定义样式&#125; bug描述：自动填充表单时，输入框背景色变黄。 bug解决：造成问题的原因：如果不设置，autocomplete默认是on的解决方式：1.利用H5新增属性 autocomplete=”off”，直接关闭自动填充1&lt;input type=&quot;text&quot; autocomplete=&quot;off&quot;&gt; 2.给form表单增加autocomplete=”off”，一次性取消表单内所有输入框的自动填充功能123&lt;form autocomplete=&quot;off&quot;&gt; &lt;input type=&quot;text&quot; &gt;&lt;/form&gt; 3.利用css12345//给input设置内置阴影！阴影大小一定要比你的input本身大input:-webkit-autofill &#123; -webkit-box-shadow: 0 0 0px 1000px white inset !important;//输入框背景颜色 -webkit-text-fill-color: #000!important;//输入框文字颜色&#125; ios 弹出框被遮罩层盖住 主要代码：123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;header&gt; &lt;!-- 头部代码 --&gt; &lt;/header&gt; &lt;section class=&quot;content&quot;&gt; &lt;!-- 打开弹窗按钮 --&gt; &lt;section class=&quot;btn-wrap&quot;&gt; &lt;input value=&quot;打开&quot;&gt; &lt;/section&gt; &lt;!-- 弹出框 fixed定位--&gt; &lt;div class=&quot;keyboard&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;!-- 遮罩层 fixed定位--&gt; &lt;div class=&quot;mask-black&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;style&gt;.mask-black &#123; background-color: rgba(51,51,51,.75); position: fixed; z-index: 500; bottom: 0; right: 0; left: 0; top: 0;&#125;.keyboard &#123; position: fixed; bottom: 0; left: 0; width: 100%; z-index: 1000;&#125;&lt;/style&gt; bug描述：在PC端及安卓上显示正常，唯独在ios上弹窗被遮档 bug解决：造成问题的原因：虽然z-index的层级问题没错，但是代码结构不规范。个人感觉很多时候一些奇怪的bug来源于我们代码的不规范。解决方式：将弹出框移至外层123456789101112131415&lt;body&gt; &lt;header&gt; &lt;!-- 头部代码 --&gt; &lt;/header&gt; &lt;section class=&quot;content&quot;&gt; &lt;!-- 打开弹窗按钮 --&gt; &lt;section class=&quot;btn-wrap&quot;&gt; &lt;input value=&quot;打开&quot;&gt; &lt;/section&gt; &lt;/section&gt; &lt;!-- 弹出框 fixed定位--&gt; &lt;div class=&quot;keyboard&quot;&gt;&lt;/div&gt; //将弹出框移至外层 &lt;!-- 遮罩层 fixed定位--&gt; &lt;div class=&quot;mask-black&quot;&gt;&lt;/div&gt;&lt;/body&gt; ios 时间格式主要代码：1234var a=new Date(&apos;2017/01/01&apos;); //Sun Jan 01 2017 00:00:00 GMT+0800 (CST)var b=new Date(&apos;01/02&apos;); //Invalid Datevar date =new Date(&quot;2016/05/31 08:00&quot;); //Tue May 31 2016 08:00:00 GMT+0800 (CST)var date =new Date(&quot;2016-05-31 08:00&quot;); //Invalid Date bug 描述：ios 对 date()的支持不一样，ios 只传月日或则“/”为不合理日期,ios 必须传年月日,且分隔符为“-” bug 解决：ios 必须传年月日，且必须用“/”分隔 ios fixed 按钮上下飘动 主要代码：1234567891011121314&lt;body&gt; &lt;header&gt; &lt;!-- 头部代码 绝对定位--&gt; &lt;/header&gt; &lt;!-- 内容代码 绝对定位--&gt; &lt;section class=&quot;content&quot;&gt; &lt;!-- 列表 --&gt; &lt;ul&gt;&lt;/ul&gt; &lt;!-- fixed置底定位按钮 --&gt; &lt;section class=&quot;btn-wrap&quot;&gt; &lt;input value=&quot;打开&quot;&gt; &lt;/section&gt; &lt;/section&gt;&lt;/body&gt; bug描述：只出现在ios上，当列表ul过长时，快速滚动页面，fixed置底按钮会上下飘动 bug解决：解决方式：将fixed置底定位的按钮移到最外层123456789101112131415&lt;body&gt; &lt;header&gt; &lt;!-- 头部代码 绝对定位--&gt; &lt;/header&gt; &lt;!-- 内容代码 绝对定位--&gt; &lt;section class=&quot;content&quot;&gt; &lt;!-- 列表 --&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/section&gt; &lt;!-- fixed置底定位按钮 移到最外层--&gt; &lt;section class=&quot;btn-wrap&quot;&gt; &lt;input value=&quot;打开&quot;&gt; &lt;/section&gt;&lt;/body&gt; h5虚拟键盘，密码框假光标移动问题 描述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用h5虚拟键盘时，需要让输入框disabled,以至于没有系统光标。需要编写一个假光标，提升用户体验。因为输入框采用”type=”password”,所以会采用系统自带的密码遮掩点。每个系统密码遮掩点都不大一样。经过多台真机的多次调试，发现大致可分为四类：大部分安卓、vivo X9S、Vivo X20、ios。为了便于以后遇到类似问题，又需要大量时间进行调试，现在先记录下调试结果。 光标移动距离的计算： 光标移动距离=(密码个数*dotWidth)em;Ios: dotWidth=1vivo X9S: dotWidth=0.5Vivo X20: dotWidth=0.49其余机型：dotWidth=0.34获取机型的方法：123if(navigator.userAgent.indexOf(“vivo X9s”)!==-1)&#123; alert(&quot;是vivo X9s&quot;);&#125; 弹性盒子兼容问题描述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前做过基于Android的智能电视项目，最早的需求是说最低兼容到Android5.0以上，于是就疯狂舒畅自由的使用新版盒子模型的写法。可是需求总是多变的，在开发接近尾声的时候，改成了兼容到Android3还是4。于是在低版本电视上盒子布局的前端页面变得面目全非。导致后来在使用盒子模型的时候总是小心翼翼，毕竟低版本的电视和手机还是有人用的。现在就记录下常见盒子模型的兼容写法把，能够让我们在面对测试提出页面bug的时候，快速定位问题所在并且解决它~ 兼容写法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//flex 布局.flex&#123;display: -webkit-box; /_ 老版本语法 _/display: -moz-box; /_ 老版本语法: Firefox/display: -webkit-flex; /_ 新版本语法\\*/display: flex;&#125;//两端对齐.flex-between&#123;-webkit-box-pack: justify;-moz-justify-content: space-between;-webkit-justify-content: space-between;justify-content: space-between;&#125;//左右、上下居中.flex-center&#123;-webkit-box-pack: center; /_ 左右 _/-moz-justify-content: center;-webkit-justify-content: center;justify-content: center;-webkit-box-align: center; /_ 上下 _/-moz-align-items: center;-webkit-align-items: center;align-items: center;&#125;//垂直对齐.flex-column&#123;-webkit-box-direction: normal;-webkit-box-orient: vertical;-moz-flex-direction: column;-webkit-flex-direction: column;flex-direction: column;&#125;//盒子相应比例(scss 写法)@mixin flex-block($con:1)&#123; -webkit-box-flex: 1; -moz-box-flex: 1; -ms-flex: $con;-webkit-flex: $con; flex: $con;&#125;//引用方法：@include flex-block(\\$con),能够快速实现想要的比例 `","categories":[{"name":"css","slug":"css","permalink":"https://gwjacqueline.github.io/categories/css/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://gwjacqueline.github.io/tags/移动端/"},{"name":"兼容性","slug":"兼容性","permalink":"https://gwjacqueline.github.io/tags/兼容性/"}]},{"title":"重温OOP之原型与继承","slug":"重温OOP之原型链与继承","date":"2019-03-31T11:31:34.000Z","updated":"2019-04-21T11:54:39.000Z","comments":true,"path":"重温OOP之原型链与继承/","link":"","permalink":"https://gwjacqueline.github.io/重温OOP之原型链与继承/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JS 原型链与继承是 JS 中的重点，这篇文章将针对原型链和继承通过代码的方式略作总结。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JS 原型链与继承是 JS 中的重点，这篇文章将针对原型链和继承通过代码的方式略作总结。 原型链&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们通过 new 操作符创建对象的过程来说说原型链。 123456function Person(name) &#123; this.name = name; return name;&#125;let classes = new Person(&quot;Lucy&quot;);console.log(classes); // person &#123;name: &quot;Lucy&quot;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们用代码的形式来解析下以上用 new 操作符创建实例的过程。 1.var classes = {};&nbsp;&nbsp;&nbsp;&nbsp;//创建一个空对象2.classes.prop = Person.prototype&nbsp;&nbsp;&nbsp;&nbsp;//将空对象的proto成员指向 Person 函数对象的 prototype 成员对象3.Person.call(classes); &nbsp;&nbsp;&nbsp;&nbsp;//将 Person 函数的指针指向 classes注意我们需要牢记的是只有对象才有proto属性，只有函数才有 prototype 属性。由于在 js 中函数也是对象，所以函数也有prop属性。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这张图我们可以看到proto属性都是从一个对象指向他们的原型对象。当我们在访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会它的proto属性指向的那个父对象当中去找，如果父对象也不存在该属性，则会去再上一层父对象的proto属性指向的对象中找。如果还是没有找到，则会一层一层向上查找，一直到找到 null 为止，如果还没有找到，则返回 Undefined。像这种通过proto属性来连接对象直到 null 为止的一条链就是原型链。 注意：使用 new 来创建对象，调用构造函数的时候，如果 return 的是对象，则会返回该对象；如果 return 的是非对象，则会忽略返回值 12345function person() &#123; return 1;&#125;let classes = new person();console.log(classes); //person &#123;&#125; Object.prototype.toString.call(obj)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说完了原型链，我们来实际应用下把。Object.prototype.toString.call(obj)这个方法是检测对象类型最通用的办法。通过原型链的知识，我们看看为什么这个方法能检测数据类型,而obj.toString()只能将对应类型转成字符类型。 123456789console.log(Object.prototype.toString.call(&quot;Lucy&quot;)); //[object String]console.log(Object.prototype.toString.call([1, 2])); //[object Array]console.log(Object.prototype.toString.call(true)); //[object Boolean]console.log(Object.prototype.toString.call(new Date().getTime())); //[object Number]console.log(&quot;Lucy&quot;.toString()); //Lucyconsole.log([1, 2].toString()); //1,2console.log(true.toString()); //trueconsole.log(new Date().getTime().toString()); //1555840282073 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从代码可以推测出 toString 是 Object 的原型方法，而 Array,Boolean,Date 等是 Object 的实例，各自上都有 toString 方法。根据以上说的原型链，因为各自上已经有 toString 方法，所以调用的是各自的 toString 方法，而不会去调用 Object 原型上的 toString 方法，所以 obj.toString 只能将 obj 转成字符串类型。要想检验对象的类型，应该去调用 Object 原型上的 toSting 方法。接下来，我们将 String 上的 toString 方法删掉，来验证我们的猜测。 123456var string = &quot;Lucy&quot;;console.log(String.prototype.hasOwnProperty(&quot;toString&quot;)); //trueconsole.log(string.toString()); //Lucydelete String.prototype.toString;console.log(String.prototype.hasOwnProperty(&quot;toString&quot;)); //falseconsole.log(string.toString()); //&quot;[object String]&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在删掉了 String 上的 toString()后，再用 string.toString()方法调用时，因为 string 上没有 toSting()方法了，它就会沿着原型链，调用 Object 上的 toString 方法，所以才能返回与 Object.prototype.toString.call(obj)相同的结果。就验证了我们的猜测是对的。 继承&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来我们利用原型实现下继承。 123456789101112131415161718192021222324function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.hello = function() &#123; return `你好，我叫$&#123;this.name&#125;,我$&#123;this.age&#125;岁，很高兴认识你`;&#125;;Person.prototype.school = &quot;UV&quot;;function Student(name, age, className) &#123; Person.call(this, name, age); this.className = className;&#125;//Object.create():创建一个空对象，并且让这个对象的原型指向create()中的参数Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;Student.prototype.classRoom = function() &#123; return `我是$&#123;this.className&#125;班的`;&#125;;var demo = new Student(&quot;Lucy&quot;, 20, 11);console.log(demo.hello()); //你好，我叫Lucy,我20岁，很高兴认识你console.log(demo.school); // UVconsole.log(demo.classRoom()); // 我是11班的 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上代码中，我先定义了一个 Person 构造函数，并且在其原型上添加了一个 hello 方法和 school 属性。然后我又定义了一个 Student 函数并在原型上定义了一个 classRoom 方法。将 Student.prototype 的proto指向了 Person.prototype。完成了一个基础的继承例子。注意：1.不能用 Student.prototype = Person.prototype这样在增加 student.prototype 的同时也会增加 Person，维护性很差要指定 Student.prototype.constructor,如果没有指定的话，Student.prototype.constructor 会指向 Person标准的继承写法 12Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student; 接下来，我们看看上面这个代码的原型链吧","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://gwjacqueline.github.io/tags/面向对象/"},{"name":"原型链","slug":"原型链","permalink":"https://gwjacqueline.github.io/tags/原型链/"},{"name":"继承","slug":"继承","permalink":"https://gwjacqueline.github.io/tags/继承/"}]},{"title":"http请求","slug":"http请求","date":"2019-03-30T09:24:53.000Z","updated":"2019-04-21T11:50:15.000Z","comments":true,"path":"http请求/","link":"","permalink":"https://gwjacqueline.github.io/http请求/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇文章将从记录下 http 请求相关的一些内容。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇文章将从记录下 http 请求相关的一些内容。 HTTP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http 是计算机通过网络进行通信的规则。http 是一种无状态的连接，也就是说 http 不建立持久的连接，服务器端不保留连接的相关信息。比如：web 像服务器发送请求，服务器响应请求后，连接就被关闭了，处理的过程是没有记忆的，如果后续的处理要之前的一些传递信息，就要重新发送请求。 HTTP 的完整请求过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个完整的 HTTP 请求，通常有 7 个步骤。 1.建立 TCP 连接&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是上计算机网络的时候，老师经常挂在嘴上的三次握手，三次握手。第一次 🤝：主机向服务器发送建议连接的请求，第二次 🤝：服务器收到请求之后发送同意连接的信号，第三次 🤝：主机收到同意连接的信号后，向服务器发送确认信号。这个过程就采用了 TCP 连接。若其中一方没有收到确认的信号，TCP 协议就会要求再次发送信号。 2.WEB 浏览器向 WEB 服务器发送请求命令&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一旦建立了 TCP 连接，Web 浏览器就会向 Web 服务器发送请求命令 3.WEB 浏览器发送请求头信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Web 浏览器向 Web 服务器发送请求命令之后，需要将一些请求头、请求行和请求正文等头信息发送给服务器。接着浏览器再发送空白行来通知服务器，它结束了头信息的发送。 4.WEB 服务器应答&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Web 浏览器向服务器发出请求后，服务器会发出类似：”我收到了“的信号。 5.WEB 服务器发送应答头信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以 ”Content-Type“ 应答头信息的格式发送用户所请求的实际数据 6.WEB 服务器关闭 TCP 连接&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果浏览器或者服务器没有在头信息中加入”Connection:keep-alive“(TCP 连接在发送后将仍然保持打开状态,浏览器可以继续通过相同的连接发送请求。目的是为了节省每个请求建立新连接所需的时间，从而节约带宽)。一旦 Web 服务器向浏览器发送了请求数据，就会关闭 TCP 连接。 HTTP 请求组成 1.HTTP 请求的方法或动作：比如是 GET 请求还是 POST 请求2.正在请求的 URL，我们总是要知道请求的地址是啥把3.请求头，包含了一些客户端环境信息，身份验证信息等等4.请求体，也就是请求正文，请求正文中可以包含客户提交的查询字符串信息，表单信息等等 注意：请求头和请求体中有个空行表示：请求头已经结束了，接下来是请求体接下来我们来看看一个标准的 http 请求 GET 和 POST 的区别GET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get 是默认的 http 请求方法，get 请求一般是安全的，用于获取信息，而不是修改信息。换句话说，get 请求一般是用来查询，我们的查询不会影响数据本身。一般不用 get 请求来新建和修改操作。get 请求发送的信息对任何人都是可见的。因为所有的变量名和值都显示在 url 当中。也就是说 get 请求是用 url 来传递参数的。就因为如此，get 请求对发送的信息是有数量限制的。虽然变量是明文的，对任何人都可见，但是也有好处，就是把页面添加在书签里就可以使用。说了这么多，我们来总结下 get 把。 1.一般用于信息的获取 2.使用 url 来传递参数 3.对发送的信息有数量限制，一般在 2000 个字符 POST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对于 get 请求，post 请求就安全很多。从字面理解，posy 是向服务器发送一些信息，一般用于修改服务器上的资源。posy 一般用于从表单发送一些数据，这些数据并不在 url 里显示，对其他人是不可见的。所有的名称和值都会被嵌入 http 的请求体中。它对发送信息的数量没有限制。用简短的语句归纳下 post 吧。 1.一般用于修改服务器上的资源2.对所发送的信息无数量限制 HTTP 响应组成 1.一个数字和文字组成的状态码，用来显示请求成功还是请求失败2.响应头，响应头和请求头一样，包含很多有用的信息。例如服务器的类型、日期时间、内容类型和长度等等。3.响应体，也就是响应正文。例如从服务器传过来的字符串、代码等等。 接下来我们来看看一个标准的 http 响应 HTTP 状态码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态码的好处就是：有助于外部程序调试的效率和准确性。HTTP 状态码由 3 位数字构成，其中首位数字定义了状态码的类型。 1XX：信息类，表示收到 WEB 浏览器的请求，正在进一步的处理中2XX：成功，表示用户请求被正确接收，理解和处理。例如：200 OK3XX：重定向，表示请求没有成功，用户必须采取进一步的动作4XX：客户端错误，表示客户端提交的请求有错误。最常见的就是：404 NOT FOUND，代表客户端请求地址不存在。5XX：服务器错误，表示服务器不能完成对 HTTP 请求的处理。最经常出现的就是 500 错误，出现这个错误，大家都很头疼。","categories":[{"name":"js","slug":"js","permalink":"https://gwjacqueline.github.io/categories/js/"}],"tags":[{"name":"http","slug":"http","permalink":"https://gwjacqueline.github.io/tags/http/"}]}]}